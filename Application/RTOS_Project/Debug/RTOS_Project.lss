
RTOS_Project.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002736  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000005a  00800060  00002736  000027ca  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000662  008000ba  008000ba  00002824  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00002824  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00002854  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000448  00000000  00000000  00002890  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00005dfa  00000000  00000000  00002cd8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000153e  00000000  00000000  00008ad2  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00003539  00000000  00000000  0000a010  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000d88  00000000  00000000  0000d54c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000192b  00000000  00000000  0000e2d4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00005e92  00000000  00000000  0000fbff  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000004c8  00000000  00000000  00015a91  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 41 03 	jmp	0x682	; 0x682 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e6 e3       	ldi	r30, 0x36	; 54
      68:	f7 e2       	ldi	r31, 0x27	; 39
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	aa 3b       	cpi	r26, 0xBA	; 186
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	27 e0       	ldi	r18, 0x07	; 7
      78:	aa eb       	ldi	r26, 0xBA	; 186
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	ac 31       	cpi	r26, 0x1C	; 28
      82:	b2 07       	cpc	r27, r18
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 15 0c 	call	0x182a	; 0x182a <main>
      8a:	0c 94 99 13 	jmp	0x2732	; 0x2732 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <xEventGroupCreate>:
		uxReturn = pxEventBits->uxEventBits;
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return uxReturn;
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
      92:	cf 93       	push	r28
      94:	df 93       	push	r29
      96:	8b e0       	ldi	r24, 0x0B	; 11
      98:	90 e0       	ldi	r25, 0x00	; 0
      9a:	0e 94 44 03 	call	0x688	; 0x688 <pvPortMalloc>
      9e:	ec 01       	movw	r28, r24
      a0:	00 97       	sbiw	r24, 0x00	; 0
      a2:	31 f0       	breq	.+12     	; 0xb0 <xEventGroupCreate+0x1e>
      a4:	fc 01       	movw	r30, r24
      a6:	11 92       	st	Z+, r1
      a8:	11 92       	st	Z+, r1
      aa:	cf 01       	movw	r24, r30
      ac:	0e 94 61 01 	call	0x2c2	; 0x2c2 <vListInitialise>
      b0:	ce 01       	movw	r24, r28
      b2:	df 91       	pop	r29
      b4:	cf 91       	pop	r28
      b6:	08 95       	ret

000000b8 <xEventGroupWaitBits>:
      b8:	af 92       	push	r10
      ba:	bf 92       	push	r11
      bc:	cf 92       	push	r12
      be:	df 92       	push	r13
      c0:	ef 92       	push	r14
      c2:	ff 92       	push	r15
      c4:	0f 93       	push	r16
      c6:	1f 93       	push	r17
      c8:	cf 93       	push	r28
      ca:	df 93       	push	r29
      cc:	7c 01       	movw	r14, r24
      ce:	6b 01       	movw	r12, r22
      d0:	a4 2e       	mov	r10, r20
      d2:	b2 2e       	mov	r11, r18
      d4:	0e 94 17 08 	call	0x102e	; 0x102e <vTaskSuspendAll>
      d8:	f7 01       	movw	r30, r14
      da:	c0 81       	ld	r28, Z
      dc:	d1 81       	ldd	r29, Z+1	; 0x01
      de:	b1 10       	cpse	r11, r1
      e0:	08 c0       	rjmp	.+16     	; 0xf2 <xEventGroupWaitBits+0x3a>
      e2:	81 e0       	ldi	r24, 0x01	; 1
      e4:	9e 01       	movw	r18, r28
      e6:	2c 21       	and	r18, r12
      e8:	3d 21       	and	r19, r13
      ea:	23 2b       	or	r18, r19
      ec:	51 f4       	brne	.+20     	; 0x102 <xEventGroupWaitBits+0x4a>
      ee:	80 e0       	ldi	r24, 0x00	; 0
      f0:	08 c0       	rjmp	.+16     	; 0x102 <xEventGroupWaitBits+0x4a>
      f2:	81 e0       	ldi	r24, 0x01	; 1
      f4:	9e 01       	movw	r18, r28
      f6:	2c 21       	and	r18, r12
      f8:	3d 21       	and	r19, r13
      fa:	2c 15       	cp	r18, r12
      fc:	3d 05       	cpc	r19, r13
      fe:	09 f0       	breq	.+2      	; 0x102 <xEventGroupWaitBits+0x4a>
     100:	80 e0       	ldi	r24, 0x00	; 0
     102:	88 23       	and	r24, r24
     104:	61 f0       	breq	.+24     	; 0x11e <xEventGroupWaitBits+0x66>
     106:	aa 20       	and	r10, r10
     108:	09 f4       	brne	.+2      	; 0x10c <xEventGroupWaitBits+0x54>
     10a:	50 c0       	rjmp	.+160    	; 0x1ac <xEventGroupWaitBits+0xf4>
     10c:	b6 01       	movw	r22, r12
     10e:	60 95       	com	r22
     110:	70 95       	com	r23
     112:	6c 23       	and	r22, r28
     114:	7d 23       	and	r23, r29
     116:	f7 01       	movw	r30, r14
     118:	71 83       	std	Z+1, r23	; 0x01
     11a:	60 83       	st	Z, r22
     11c:	47 c0       	rjmp	.+142    	; 0x1ac <xEventGroupWaitBits+0xf4>
     11e:	01 15       	cp	r16, r1
     120:	11 05       	cpc	r17, r1
     122:	09 f4       	brne	.+2      	; 0x126 <xEventGroupWaitBits+0x6e>
     124:	43 c0       	rjmp	.+134    	; 0x1ac <xEventGroupWaitBits+0xf4>
     126:	aa 20       	and	r10, r10
     128:	19 f0       	breq	.+6      	; 0x130 <xEventGroupWaitBits+0x78>
     12a:	60 e0       	ldi	r22, 0x00	; 0
     12c:	71 e0       	ldi	r23, 0x01	; 1
     12e:	02 c0       	rjmp	.+4      	; 0x134 <xEventGroupWaitBits+0x7c>
     130:	60 e0       	ldi	r22, 0x00	; 0
     132:	70 e0       	ldi	r23, 0x00	; 0
     134:	b1 10       	cpse	r11, r1
     136:	74 60       	ori	r23, 0x04	; 4
     138:	6c 29       	or	r22, r12
     13a:	7d 29       	or	r23, r13
     13c:	a8 01       	movw	r20, r16
     13e:	c7 01       	movw	r24, r14
     140:	02 96       	adiw	r24, 0x02	; 2
     142:	0e 94 1f 0a 	call	0x143e	; 0x143e <vTaskPlaceOnUnorderedEventList>
     146:	0e 94 e6 08 	call	0x11cc	; 0x11cc <xTaskResumeAll>
     14a:	81 11       	cpse	r24, r1
     14c:	02 c0       	rjmp	.+4      	; 0x152 <xEventGroupWaitBits+0x9a>
     14e:	0e 94 8d 02 	call	0x51a	; 0x51a <vPortYield>
     152:	0e 94 fd 0a 	call	0x15fa	; 0x15fa <uxTaskResetEventItemValue>
     156:	91 fd       	sbrc	r25, 1
     158:	26 c0       	rjmp	.+76     	; 0x1a6 <xEventGroupWaitBits+0xee>
     15a:	0f b6       	in	r0, 0x3f	; 63
     15c:	f8 94       	cli
     15e:	0f 92       	push	r0
     160:	f7 01       	movw	r30, r14
     162:	80 81       	ld	r24, Z
     164:	91 81       	ldd	r25, Z+1	; 0x01
     166:	b1 10       	cpse	r11, r1
     168:	08 c0       	rjmp	.+16     	; 0x17a <xEventGroupWaitBits+0xc2>
     16a:	21 e0       	ldi	r18, 0x01	; 1
     16c:	a6 01       	movw	r20, r12
     16e:	48 23       	and	r20, r24
     170:	59 23       	and	r21, r25
     172:	45 2b       	or	r20, r21
     174:	51 f4       	brne	.+20     	; 0x18a <xEventGroupWaitBits+0xd2>
     176:	20 e0       	ldi	r18, 0x00	; 0
     178:	08 c0       	rjmp	.+16     	; 0x18a <xEventGroupWaitBits+0xd2>
     17a:	21 e0       	ldi	r18, 0x01	; 1
     17c:	a6 01       	movw	r20, r12
     17e:	48 23       	and	r20, r24
     180:	59 23       	and	r21, r25
     182:	4c 15       	cp	r20, r12
     184:	5d 05       	cpc	r21, r13
     186:	09 f0       	breq	.+2      	; 0x18a <xEventGroupWaitBits+0xd2>
     188:	20 e0       	ldi	r18, 0x00	; 0
     18a:	22 23       	and	r18, r18
     18c:	51 f0       	breq	.+20     	; 0x1a2 <xEventGroupWaitBits+0xea>
     18e:	aa 20       	and	r10, r10
     190:	41 f0       	breq	.+16     	; 0x1a2 <xEventGroupWaitBits+0xea>
     192:	b6 01       	movw	r22, r12
     194:	60 95       	com	r22
     196:	70 95       	com	r23
     198:	68 23       	and	r22, r24
     19a:	79 23       	and	r23, r25
     19c:	f7 01       	movw	r30, r14
     19e:	71 83       	std	Z+1, r23	; 0x01
     1a0:	60 83       	st	Z, r22
     1a2:	0f 90       	pop	r0
     1a4:	0f be       	out	0x3f, r0	; 63
     1a6:	ec 01       	movw	r28, r24
     1a8:	dd 27       	eor	r29, r29
     1aa:	02 c0       	rjmp	.+4      	; 0x1b0 <xEventGroupWaitBits+0xf8>
     1ac:	0e 94 e6 08 	call	0x11cc	; 0x11cc <xTaskResumeAll>
     1b0:	ce 01       	movw	r24, r28
     1b2:	df 91       	pop	r29
     1b4:	cf 91       	pop	r28
     1b6:	1f 91       	pop	r17
     1b8:	0f 91       	pop	r16
     1ba:	ff 90       	pop	r15
     1bc:	ef 90       	pop	r14
     1be:	df 90       	pop	r13
     1c0:	cf 90       	pop	r12
     1c2:	bf 90       	pop	r11
     1c4:	af 90       	pop	r10
     1c6:	08 95       	ret

000001c8 <xEventGroupClearBits>:
     1c8:	fc 01       	movw	r30, r24
     1ca:	0f b6       	in	r0, 0x3f	; 63
     1cc:	f8 94       	cli
     1ce:	0f 92       	push	r0
     1d0:	80 81       	ld	r24, Z
     1d2:	91 81       	ldd	r25, Z+1	; 0x01
     1d4:	60 95       	com	r22
     1d6:	70 95       	com	r23
     1d8:	68 23       	and	r22, r24
     1da:	79 23       	and	r23, r25
     1dc:	71 83       	std	Z+1, r23	; 0x01
     1de:	60 83       	st	Z, r22
     1e0:	0f 90       	pop	r0
     1e2:	0f be       	out	0x3f, r0	; 63
     1e4:	08 95       	ret

000001e6 <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
     1e6:	af 92       	push	r10
     1e8:	bf 92       	push	r11
     1ea:	cf 92       	push	r12
     1ec:	df 92       	push	r13
     1ee:	ef 92       	push	r14
     1f0:	ff 92       	push	r15
     1f2:	0f 93       	push	r16
     1f4:	1f 93       	push	r17
     1f6:	cf 93       	push	r28
     1f8:	df 93       	push	r29
     1fa:	7c 01       	movw	r14, r24
     1fc:	8b 01       	movw	r16, r22
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	pxList = &( pxEventBits->xTasksWaitingForBits );
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     1fe:	ec 01       	movw	r28, r24
     200:	25 96       	adiw	r28, 0x05	; 5
	vTaskSuspendAll();
     202:	0e 94 17 08 	call	0x102e	; 0x102e <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
     206:	d7 01       	movw	r26, r14
     208:	17 96       	adiw	r26, 0x07	; 7
     20a:	ed 91       	ld	r30, X+
     20c:	fc 91       	ld	r31, X
     20e:	18 97       	sbiw	r26, 0x08	; 8

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
     210:	8d 91       	ld	r24, X+
     212:	9c 91       	ld	r25, X
     214:	11 97       	sbiw	r26, 0x01	; 1
     216:	08 2b       	or	r16, r24
     218:	19 2b       	or	r17, r25
     21a:	0d 93       	st	X+, r16
     21c:	1c 93       	st	X, r17

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
     21e:	ce 17       	cp	r28, r30
     220:	df 07       	cpc	r29, r31
     222:	a1 f1       	breq	.+104    	; 0x28c <xEventGroupSetBits+0xa6>
     224:	00 e0       	ldi	r16, 0x00	; 0
     226:	10 e0       	ldi	r17, 0x00	; 0
			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
				{
					xMatchFound = pdTRUE;
     228:	bb 24       	eor	r11, r11
     22a:	b3 94       	inc	r11
     22c:	a1 2c       	mov	r10, r1
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
		{
			pxNext = listGET_NEXT( pxListItem );
     22e:	c2 80       	ldd	r12, Z+2	; 0x02
     230:	d3 80       	ldd	r13, Z+3	; 0x03
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
     232:	80 81       	ld	r24, Z
     234:	91 81       	ldd	r25, Z+1	; 0x01
			xMatchFound = pdFALSE;

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
     236:	9c 01       	movw	r18, r24
     238:	33 27       	eor	r19, r19

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
     23a:	92 fd       	sbrc	r25, 2
     23c:	0a c0       	rjmp	.+20     	; 0x252 <xEventGroupSetBits+0x6c>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
				{
					xMatchFound = pdTRUE;
     23e:	d7 01       	movw	r26, r14
     240:	6d 91       	ld	r22, X+
     242:	7c 91       	ld	r23, X
     244:	62 23       	and	r22, r18
     246:	73 23       	and	r23, r19
     248:	4b 2d       	mov	r20, r11
     24a:	67 2b       	or	r22, r23
     24c:	61 f4       	brne	.+24     	; 0x266 <xEventGroupSetBits+0x80>
     24e:	4a 2d       	mov	r20, r10
     250:	0a c0       	rjmp	.+20     	; 0x266 <xEventGroupSetBits+0x80>
     252:	d7 01       	movw	r26, r14
     254:	6d 91       	ld	r22, X+
     256:	7c 91       	ld	r23, X
     258:	62 23       	and	r22, r18
     25a:	73 23       	and	r23, r19
     25c:	4b 2d       	mov	r20, r11
     25e:	62 17       	cp	r22, r18
     260:	73 07       	cpc	r23, r19
     262:	09 f0       	breq	.+2      	; 0x266 <xEventGroupSetBits+0x80>
     264:	4a 2d       	mov	r20, r10
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
     266:	44 23       	and	r20, r20
     268:	59 f0       	breq	.+22     	; 0x280 <xEventGroupSetBits+0x9a>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
     26a:	90 ff       	sbrs	r25, 0
     26c:	02 c0       	rjmp	.+4      	; 0x272 <xEventGroupSetBits+0x8c>
				{
					uxBitsToClear |= uxBitsWaitedFor;
     26e:	02 2b       	or	r16, r18
     270:	13 2b       	or	r17, r19
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
     272:	d7 01       	movw	r26, r14
     274:	6d 91       	ld	r22, X+
     276:	7c 91       	ld	r23, X
     278:	72 60       	ori	r23, 0x02	; 2
     27a:	cf 01       	movw	r24, r30
     27c:	0e 94 80 0a 	call	0x1500	; 0x1500 <vTaskRemoveFromUnorderedEventList>
     280:	ec 2d       	mov	r30, r12
     282:	fd 2d       	mov	r31, r13

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
     284:	ce 17       	cp	r28, r30
     286:	df 07       	cpc	r29, r31
     288:	91 f6       	brne	.-92     	; 0x22e <xEventGroupSetBits+0x48>
     28a:	02 c0       	rjmp	.+4      	; 0x290 <xEventGroupSetBits+0xaa>
EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t const * pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
     28c:	00 e0       	ldi	r16, 0x00	; 0
     28e:	10 e0       	ldi	r17, 0x00	; 0
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
     290:	00 95       	com	r16
     292:	10 95       	com	r17
     294:	f7 01       	movw	r30, r14
     296:	80 81       	ld	r24, Z
     298:	91 81       	ldd	r25, Z+1	; 0x01
     29a:	08 23       	and	r16, r24
     29c:	19 23       	and	r17, r25
     29e:	11 83       	std	Z+1, r17	; 0x01
     2a0:	00 83       	st	Z, r16
	}
	( void ) xTaskResumeAll();
     2a2:	0e 94 e6 08 	call	0x11cc	; 0x11cc <xTaskResumeAll>

	return pxEventBits->uxEventBits;
}
     2a6:	d7 01       	movw	r26, r14
     2a8:	8d 91       	ld	r24, X+
     2aa:	9c 91       	ld	r25, X
     2ac:	df 91       	pop	r29
     2ae:	cf 91       	pop	r28
     2b0:	1f 91       	pop	r17
     2b2:	0f 91       	pop	r16
     2b4:	ff 90       	pop	r15
     2b6:	ef 90       	pop	r14
     2b8:	df 90       	pop	r13
     2ba:	cf 90       	pop	r12
     2bc:	bf 90       	pop	r11
     2be:	af 90       	pop	r10
     2c0:	08 95       	ret

000002c2 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     2c2:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     2c4:	03 96       	adiw	r24, 0x03	; 3
     2c6:	92 83       	std	Z+2, r25	; 0x02
     2c8:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     2ca:	2f ef       	ldi	r18, 0xFF	; 255
     2cc:	3f ef       	ldi	r19, 0xFF	; 255
     2ce:	34 83       	std	Z+4, r19	; 0x04
     2d0:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     2d2:	96 83       	std	Z+6, r25	; 0x06
     2d4:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     2d6:	90 87       	std	Z+8, r25	; 0x08
     2d8:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     2da:	10 82       	st	Z, r1
     2dc:	08 95       	ret

000002de <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
     2de:	fc 01       	movw	r30, r24
     2e0:	11 86       	std	Z+9, r1	; 0x09
     2e2:	10 86       	std	Z+8, r1	; 0x08
     2e4:	08 95       	ret

000002e6 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     2e6:	cf 93       	push	r28
     2e8:	df 93       	push	r29
     2ea:	9c 01       	movw	r18, r24
     2ec:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     2ee:	dc 01       	movw	r26, r24
     2f0:	11 96       	adiw	r26, 0x01	; 1
     2f2:	cd 91       	ld	r28, X+
     2f4:	dc 91       	ld	r29, X
     2f6:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     2f8:	d3 83       	std	Z+3, r29	; 0x03
     2fa:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     2fc:	8c 81       	ldd	r24, Y+4	; 0x04
     2fe:	9d 81       	ldd	r25, Y+5	; 0x05
     300:	95 83       	std	Z+5, r25	; 0x05
     302:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     304:	8c 81       	ldd	r24, Y+4	; 0x04
     306:	9d 81       	ldd	r25, Y+5	; 0x05
     308:	dc 01       	movw	r26, r24
     30a:	13 96       	adiw	r26, 0x03	; 3
     30c:	7c 93       	st	X, r23
     30e:	6e 93       	st	-X, r22
     310:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     312:	7d 83       	std	Y+5, r23	; 0x05
     314:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
     316:	31 87       	std	Z+9, r19	; 0x09
     318:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     31a:	f9 01       	movw	r30, r18
     31c:	80 81       	ld	r24, Z
     31e:	8f 5f       	subi	r24, 0xFF	; 255
     320:	80 83       	st	Z, r24
}
     322:	df 91       	pop	r29
     324:	cf 91       	pop	r28
     326:	08 95       	ret

00000328 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     328:	cf 93       	push	r28
     32a:	df 93       	push	r29
     32c:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     32e:	48 81       	ld	r20, Y
     330:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     332:	4f 3f       	cpi	r20, 0xFF	; 255
     334:	2f ef       	ldi	r18, 0xFF	; 255
     336:	52 07       	cpc	r21, r18
     338:	21 f4       	brne	.+8      	; 0x342 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     33a:	fc 01       	movw	r30, r24
     33c:	a7 81       	ldd	r26, Z+7	; 0x07
     33e:	b0 85       	ldd	r27, Z+8	; 0x08
     340:	0d c0       	rjmp	.+26     	; 0x35c <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
     342:	dc 01       	movw	r26, r24
     344:	13 96       	adiw	r26, 0x03	; 3
     346:	01 c0       	rjmp	.+2      	; 0x34a <vListInsert+0x22>
     348:	df 01       	movw	r26, r30
     34a:	12 96       	adiw	r26, 0x02	; 2
     34c:	ed 91       	ld	r30, X+
     34e:	fc 91       	ld	r31, X
     350:	13 97       	sbiw	r26, 0x03	; 3
     352:	20 81       	ld	r18, Z
     354:	31 81       	ldd	r19, Z+1	; 0x01
     356:	42 17       	cp	r20, r18
     358:	53 07       	cpc	r21, r19
     35a:	b0 f7       	brcc	.-20     	; 0x348 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     35c:	12 96       	adiw	r26, 0x02	; 2
     35e:	ed 91       	ld	r30, X+
     360:	fc 91       	ld	r31, X
     362:	13 97       	sbiw	r26, 0x03	; 3
     364:	fb 83       	std	Y+3, r31	; 0x03
     366:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     368:	d5 83       	std	Z+5, r29	; 0x05
     36a:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     36c:	bd 83       	std	Y+5, r27	; 0x05
     36e:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     370:	13 96       	adiw	r26, 0x03	; 3
     372:	dc 93       	st	X, r29
     374:	ce 93       	st	-X, r28
     376:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
     378:	99 87       	std	Y+9, r25	; 0x09
     37a:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     37c:	fc 01       	movw	r30, r24
     37e:	20 81       	ld	r18, Z
     380:	2f 5f       	subi	r18, 0xFF	; 255
     382:	20 83       	st	Z, r18
}
     384:	df 91       	pop	r29
     386:	cf 91       	pop	r28
     388:	08 95       	ret

0000038a <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     38a:	cf 93       	push	r28
     38c:	df 93       	push	r29
     38e:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
     390:	a0 85       	ldd	r26, Z+8	; 0x08
     392:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     394:	c2 81       	ldd	r28, Z+2	; 0x02
     396:	d3 81       	ldd	r29, Z+3	; 0x03
     398:	84 81       	ldd	r24, Z+4	; 0x04
     39a:	95 81       	ldd	r25, Z+5	; 0x05
     39c:	9d 83       	std	Y+5, r25	; 0x05
     39e:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     3a0:	c4 81       	ldd	r28, Z+4	; 0x04
     3a2:	d5 81       	ldd	r29, Z+5	; 0x05
     3a4:	82 81       	ldd	r24, Z+2	; 0x02
     3a6:	93 81       	ldd	r25, Z+3	; 0x03
     3a8:	9b 83       	std	Y+3, r25	; 0x03
     3aa:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     3ac:	11 96       	adiw	r26, 0x01	; 1
     3ae:	8d 91       	ld	r24, X+
     3b0:	9c 91       	ld	r25, X
     3b2:	12 97       	sbiw	r26, 0x02	; 2
     3b4:	e8 17       	cp	r30, r24
     3b6:	f9 07       	cpc	r31, r25
     3b8:	31 f4       	brne	.+12     	; 0x3c6 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     3ba:	84 81       	ldd	r24, Z+4	; 0x04
     3bc:	95 81       	ldd	r25, Z+5	; 0x05
     3be:	12 96       	adiw	r26, 0x02	; 2
     3c0:	9c 93       	st	X, r25
     3c2:	8e 93       	st	-X, r24
     3c4:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
     3c6:	11 86       	std	Z+9, r1	; 0x09
     3c8:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     3ca:	8c 91       	ld	r24, X
     3cc:	81 50       	subi	r24, 0x01	; 1
     3ce:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
     3d0:	8c 91       	ld	r24, X
}
     3d2:	df 91       	pop	r29
     3d4:	cf 91       	pop	r28
     3d6:	08 95       	ret

000003d8 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     3d8:	31 e1       	ldi	r19, 0x11	; 17
     3da:	fc 01       	movw	r30, r24
     3dc:	30 83       	st	Z, r19
     3de:	31 97       	sbiw	r30, 0x01	; 1
     3e0:	22 e2       	ldi	r18, 0x22	; 34
     3e2:	20 83       	st	Z, r18
     3e4:	31 97       	sbiw	r30, 0x01	; 1
     3e6:	a3 e3       	ldi	r26, 0x33	; 51
     3e8:	a0 83       	st	Z, r26
     3ea:	31 97       	sbiw	r30, 0x01	; 1
     3ec:	60 83       	st	Z, r22
     3ee:	31 97       	sbiw	r30, 0x01	; 1
     3f0:	70 83       	st	Z, r23
     3f2:	31 97       	sbiw	r30, 0x01	; 1
     3f4:	10 82       	st	Z, r1
     3f6:	31 97       	sbiw	r30, 0x01	; 1
     3f8:	60 e8       	ldi	r22, 0x80	; 128
     3fa:	60 83       	st	Z, r22
     3fc:	31 97       	sbiw	r30, 0x01	; 1
     3fe:	10 82       	st	Z, r1
     400:	31 97       	sbiw	r30, 0x01	; 1
     402:	62 e0       	ldi	r22, 0x02	; 2
     404:	60 83       	st	Z, r22
     406:	31 97       	sbiw	r30, 0x01	; 1
     408:	63 e0       	ldi	r22, 0x03	; 3
     40a:	60 83       	st	Z, r22
     40c:	31 97       	sbiw	r30, 0x01	; 1
     40e:	64 e0       	ldi	r22, 0x04	; 4
     410:	60 83       	st	Z, r22
     412:	31 97       	sbiw	r30, 0x01	; 1
     414:	65 e0       	ldi	r22, 0x05	; 5
     416:	60 83       	st	Z, r22
     418:	31 97       	sbiw	r30, 0x01	; 1
     41a:	66 e0       	ldi	r22, 0x06	; 6
     41c:	60 83       	st	Z, r22
     41e:	31 97       	sbiw	r30, 0x01	; 1
     420:	67 e0       	ldi	r22, 0x07	; 7
     422:	60 83       	st	Z, r22
     424:	31 97       	sbiw	r30, 0x01	; 1
     426:	68 e0       	ldi	r22, 0x08	; 8
     428:	60 83       	st	Z, r22
     42a:	31 97       	sbiw	r30, 0x01	; 1
     42c:	69 e0       	ldi	r22, 0x09	; 9
     42e:	60 83       	st	Z, r22
     430:	31 97       	sbiw	r30, 0x01	; 1
     432:	60 e1       	ldi	r22, 0x10	; 16
     434:	60 83       	st	Z, r22
     436:	31 97       	sbiw	r30, 0x01	; 1
     438:	30 83       	st	Z, r19
     43a:	31 97       	sbiw	r30, 0x01	; 1
     43c:	32 e1       	ldi	r19, 0x12	; 18
     43e:	30 83       	st	Z, r19
     440:	31 97       	sbiw	r30, 0x01	; 1
     442:	33 e1       	ldi	r19, 0x13	; 19
     444:	30 83       	st	Z, r19
     446:	31 97       	sbiw	r30, 0x01	; 1
     448:	34 e1       	ldi	r19, 0x14	; 20
     44a:	30 83       	st	Z, r19
     44c:	31 97       	sbiw	r30, 0x01	; 1
     44e:	35 e1       	ldi	r19, 0x15	; 21
     450:	30 83       	st	Z, r19
     452:	31 97       	sbiw	r30, 0x01	; 1
     454:	36 e1       	ldi	r19, 0x16	; 22
     456:	30 83       	st	Z, r19
     458:	31 97       	sbiw	r30, 0x01	; 1
     45a:	37 e1       	ldi	r19, 0x17	; 23
     45c:	30 83       	st	Z, r19
     45e:	31 97       	sbiw	r30, 0x01	; 1
     460:	38 e1       	ldi	r19, 0x18	; 24
     462:	30 83       	st	Z, r19
     464:	31 97       	sbiw	r30, 0x01	; 1
     466:	39 e1       	ldi	r19, 0x19	; 25
     468:	30 83       	st	Z, r19
     46a:	31 97       	sbiw	r30, 0x01	; 1
     46c:	30 e2       	ldi	r19, 0x20	; 32
     46e:	30 83       	st	Z, r19
     470:	31 97       	sbiw	r30, 0x01	; 1
     472:	31 e2       	ldi	r19, 0x21	; 33
     474:	30 83       	st	Z, r19
     476:	31 97       	sbiw	r30, 0x01	; 1
     478:	20 83       	st	Z, r18
     47a:	31 97       	sbiw	r30, 0x01	; 1
     47c:	23 e2       	ldi	r18, 0x23	; 35
     47e:	20 83       	st	Z, r18
     480:	31 97       	sbiw	r30, 0x01	; 1
     482:	40 83       	st	Z, r20
     484:	31 97       	sbiw	r30, 0x01	; 1
     486:	50 83       	st	Z, r21
     488:	31 97       	sbiw	r30, 0x01	; 1
     48a:	26 e2       	ldi	r18, 0x26	; 38
     48c:	20 83       	st	Z, r18
     48e:	31 97       	sbiw	r30, 0x01	; 1
     490:	27 e2       	ldi	r18, 0x27	; 39
     492:	20 83       	st	Z, r18
     494:	31 97       	sbiw	r30, 0x01	; 1
     496:	28 e2       	ldi	r18, 0x28	; 40
     498:	20 83       	st	Z, r18
     49a:	31 97       	sbiw	r30, 0x01	; 1
     49c:	29 e2       	ldi	r18, 0x29	; 41
     49e:	20 83       	st	Z, r18
     4a0:	31 97       	sbiw	r30, 0x01	; 1
     4a2:	20 e3       	ldi	r18, 0x30	; 48
     4a4:	20 83       	st	Z, r18
     4a6:	31 97       	sbiw	r30, 0x01	; 1
     4a8:	21 e3       	ldi	r18, 0x31	; 49
     4aa:	20 83       	st	Z, r18
     4ac:	86 97       	sbiw	r24, 0x26	; 38
     4ae:	08 95       	ret

000004b0 <xPortStartScheduler>:
     4b0:	1b bc       	out	0x2b, r1	; 43
     4b2:	8c e7       	ldi	r24, 0x7C	; 124
     4b4:	8a bd       	out	0x2a, r24	; 42
     4b6:	8b e0       	ldi	r24, 0x0B	; 11
     4b8:	8e bd       	out	0x2e, r24	; 46
     4ba:	89 b7       	in	r24, 0x39	; 57
     4bc:	80 61       	ori	r24, 0x10	; 16
     4be:	89 bf       	out	0x39, r24	; 57
     4c0:	a0 91 ff 06 	lds	r26, 0x06FF	; 0x8006ff <pxCurrentTCB>
     4c4:	b0 91 00 07 	lds	r27, 0x0700	; 0x800700 <pxCurrentTCB+0x1>
     4c8:	cd 91       	ld	r28, X+
     4ca:	cd bf       	out	0x3d, r28	; 61
     4cc:	dd 91       	ld	r29, X+
     4ce:	de bf       	out	0x3e, r29	; 62
     4d0:	ff 91       	pop	r31
     4d2:	ef 91       	pop	r30
     4d4:	df 91       	pop	r29
     4d6:	cf 91       	pop	r28
     4d8:	bf 91       	pop	r27
     4da:	af 91       	pop	r26
     4dc:	9f 91       	pop	r25
     4de:	8f 91       	pop	r24
     4e0:	7f 91       	pop	r23
     4e2:	6f 91       	pop	r22
     4e4:	5f 91       	pop	r21
     4e6:	4f 91       	pop	r20
     4e8:	3f 91       	pop	r19
     4ea:	2f 91       	pop	r18
     4ec:	1f 91       	pop	r17
     4ee:	0f 91       	pop	r16
     4f0:	ff 90       	pop	r15
     4f2:	ef 90       	pop	r14
     4f4:	df 90       	pop	r13
     4f6:	cf 90       	pop	r12
     4f8:	bf 90       	pop	r11
     4fa:	af 90       	pop	r10
     4fc:	9f 90       	pop	r9
     4fe:	8f 90       	pop	r8
     500:	7f 90       	pop	r7
     502:	6f 90       	pop	r6
     504:	5f 90       	pop	r5
     506:	4f 90       	pop	r4
     508:	3f 90       	pop	r3
     50a:	2f 90       	pop	r2
     50c:	1f 90       	pop	r1
     50e:	0f 90       	pop	r0
     510:	0f be       	out	0x3f, r0	; 63
     512:	0f 90       	pop	r0
     514:	08 95       	ret
     516:	81 e0       	ldi	r24, 0x01	; 1
     518:	08 95       	ret

0000051a <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     51a:	0f 92       	push	r0
     51c:	0f b6       	in	r0, 0x3f	; 63
     51e:	f8 94       	cli
     520:	0f 92       	push	r0
     522:	1f 92       	push	r1
     524:	11 24       	eor	r1, r1
     526:	2f 92       	push	r2
     528:	3f 92       	push	r3
     52a:	4f 92       	push	r4
     52c:	5f 92       	push	r5
     52e:	6f 92       	push	r6
     530:	7f 92       	push	r7
     532:	8f 92       	push	r8
     534:	9f 92       	push	r9
     536:	af 92       	push	r10
     538:	bf 92       	push	r11
     53a:	cf 92       	push	r12
     53c:	df 92       	push	r13
     53e:	ef 92       	push	r14
     540:	ff 92       	push	r15
     542:	0f 93       	push	r16
     544:	1f 93       	push	r17
     546:	2f 93       	push	r18
     548:	3f 93       	push	r19
     54a:	4f 93       	push	r20
     54c:	5f 93       	push	r21
     54e:	6f 93       	push	r22
     550:	7f 93       	push	r23
     552:	8f 93       	push	r24
     554:	9f 93       	push	r25
     556:	af 93       	push	r26
     558:	bf 93       	push	r27
     55a:	cf 93       	push	r28
     55c:	df 93       	push	r29
     55e:	ef 93       	push	r30
     560:	ff 93       	push	r31
     562:	a0 91 ff 06 	lds	r26, 0x06FF	; 0x8006ff <pxCurrentTCB>
     566:	b0 91 00 07 	lds	r27, 0x0700	; 0x800700 <pxCurrentTCB+0x1>
     56a:	0d b6       	in	r0, 0x3d	; 61
     56c:	0d 92       	st	X+, r0
     56e:	0e b6       	in	r0, 0x3e	; 62
     570:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     572:	0e 94 a7 09 	call	0x134e	; 0x134e <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     576:	a0 91 ff 06 	lds	r26, 0x06FF	; 0x8006ff <pxCurrentTCB>
     57a:	b0 91 00 07 	lds	r27, 0x0700	; 0x800700 <pxCurrentTCB+0x1>
     57e:	cd 91       	ld	r28, X+
     580:	cd bf       	out	0x3d, r28	; 61
     582:	dd 91       	ld	r29, X+
     584:	de bf       	out	0x3e, r29	; 62
     586:	ff 91       	pop	r31
     588:	ef 91       	pop	r30
     58a:	df 91       	pop	r29
     58c:	cf 91       	pop	r28
     58e:	bf 91       	pop	r27
     590:	af 91       	pop	r26
     592:	9f 91       	pop	r25
     594:	8f 91       	pop	r24
     596:	7f 91       	pop	r23
     598:	6f 91       	pop	r22
     59a:	5f 91       	pop	r21
     59c:	4f 91       	pop	r20
     59e:	3f 91       	pop	r19
     5a0:	2f 91       	pop	r18
     5a2:	1f 91       	pop	r17
     5a4:	0f 91       	pop	r16
     5a6:	ff 90       	pop	r15
     5a8:	ef 90       	pop	r14
     5aa:	df 90       	pop	r13
     5ac:	cf 90       	pop	r12
     5ae:	bf 90       	pop	r11
     5b0:	af 90       	pop	r10
     5b2:	9f 90       	pop	r9
     5b4:	8f 90       	pop	r8
     5b6:	7f 90       	pop	r7
     5b8:	6f 90       	pop	r6
     5ba:	5f 90       	pop	r5
     5bc:	4f 90       	pop	r4
     5be:	3f 90       	pop	r3
     5c0:	2f 90       	pop	r2
     5c2:	1f 90       	pop	r1
     5c4:	0f 90       	pop	r0
     5c6:	0f be       	out	0x3f, r0	; 63
     5c8:	0f 90       	pop	r0

	asm volatile ( "ret" );
     5ca:	08 95       	ret

000005cc <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     5cc:	0f 92       	push	r0
     5ce:	0f b6       	in	r0, 0x3f	; 63
     5d0:	f8 94       	cli
     5d2:	0f 92       	push	r0
     5d4:	1f 92       	push	r1
     5d6:	11 24       	eor	r1, r1
     5d8:	2f 92       	push	r2
     5da:	3f 92       	push	r3
     5dc:	4f 92       	push	r4
     5de:	5f 92       	push	r5
     5e0:	6f 92       	push	r6
     5e2:	7f 92       	push	r7
     5e4:	8f 92       	push	r8
     5e6:	9f 92       	push	r9
     5e8:	af 92       	push	r10
     5ea:	bf 92       	push	r11
     5ec:	cf 92       	push	r12
     5ee:	df 92       	push	r13
     5f0:	ef 92       	push	r14
     5f2:	ff 92       	push	r15
     5f4:	0f 93       	push	r16
     5f6:	1f 93       	push	r17
     5f8:	2f 93       	push	r18
     5fa:	3f 93       	push	r19
     5fc:	4f 93       	push	r20
     5fe:	5f 93       	push	r21
     600:	6f 93       	push	r22
     602:	7f 93       	push	r23
     604:	8f 93       	push	r24
     606:	9f 93       	push	r25
     608:	af 93       	push	r26
     60a:	bf 93       	push	r27
     60c:	cf 93       	push	r28
     60e:	df 93       	push	r29
     610:	ef 93       	push	r30
     612:	ff 93       	push	r31
     614:	a0 91 ff 06 	lds	r26, 0x06FF	; 0x8006ff <pxCurrentTCB>
     618:	b0 91 00 07 	lds	r27, 0x0700	; 0x800700 <pxCurrentTCB+0x1>
     61c:	0d b6       	in	r0, 0x3d	; 61
     61e:	0d 92       	st	X+, r0
     620:	0e b6       	in	r0, 0x3e	; 62
     622:	0d 92       	st	X+, r0
	xTaskIncrementTick(); //****************************************************
     624:	0e 94 27 08 	call	0x104e	; 0x104e <xTaskIncrementTick>
	vTaskSwitchContext();
     628:	0e 94 a7 09 	call	0x134e	; 0x134e <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     62c:	a0 91 ff 06 	lds	r26, 0x06FF	; 0x8006ff <pxCurrentTCB>
     630:	b0 91 00 07 	lds	r27, 0x0700	; 0x800700 <pxCurrentTCB+0x1>
     634:	cd 91       	ld	r28, X+
     636:	cd bf       	out	0x3d, r28	; 61
     638:	dd 91       	ld	r29, X+
     63a:	de bf       	out	0x3e, r29	; 62
     63c:	ff 91       	pop	r31
     63e:	ef 91       	pop	r30
     640:	df 91       	pop	r29
     642:	cf 91       	pop	r28
     644:	bf 91       	pop	r27
     646:	af 91       	pop	r26
     648:	9f 91       	pop	r25
     64a:	8f 91       	pop	r24
     64c:	7f 91       	pop	r23
     64e:	6f 91       	pop	r22
     650:	5f 91       	pop	r21
     652:	4f 91       	pop	r20
     654:	3f 91       	pop	r19
     656:	2f 91       	pop	r18
     658:	1f 91       	pop	r17
     65a:	0f 91       	pop	r16
     65c:	ff 90       	pop	r15
     65e:	ef 90       	pop	r14
     660:	df 90       	pop	r13
     662:	cf 90       	pop	r12
     664:	bf 90       	pop	r11
     666:	af 90       	pop	r10
     668:	9f 90       	pop	r9
     66a:	8f 90       	pop	r8
     66c:	7f 90       	pop	r7
     66e:	6f 90       	pop	r6
     670:	5f 90       	pop	r5
     672:	4f 90       	pop	r4
     674:	3f 90       	pop	r3
     676:	2f 90       	pop	r2
     678:	1f 90       	pop	r1
     67a:	0f 90       	pop	r0
     67c:	0f be       	out	0x3f, r0	; 63
     67e:	0f 90       	pop	r0

	asm volatile ( "ret" );
     680:	08 95       	ret

00000682 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void  TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void  TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     682:	0e 94 e6 02 	call	0x5cc	; 0x5cc <vPortYieldFromTick>
		asm volatile ( "reti" );
     686:	18 95       	reti

00000688 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     688:	cf 93       	push	r28
     68a:	df 93       	push	r29
     68c:	ec 01       	movw	r28, r24
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
     68e:	0e 94 17 08 	call	0x102e	; 0x102e <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     692:	80 91 ba 00 	lds	r24, 0x00BA	; 0x8000ba <__data_end>
     696:	90 91 bb 00 	lds	r25, 0x00BB	; 0x8000bb <__data_end+0x1>
     69a:	89 2b       	or	r24, r25
     69c:	31 f4       	brne	.+12     	; 0x6aa <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
     69e:	8f eb       	ldi	r24, 0xBF	; 191
     6a0:	90 e0       	ldi	r25, 0x00	; 0
     6a2:	90 93 bb 00 	sts	0x00BB, r25	; 0x8000bb <__data_end+0x1>
     6a6:	80 93 ba 00 	sts	0x00BA, r24	; 0x8000ba <__data_end>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     6aa:	20 91 bc 00 	lds	r18, 0x00BC	; 0x8000bc <xNextFreeByte>
     6ae:	30 91 bd 00 	lds	r19, 0x00BD	; 0x8000bd <xNextFreeByte+0x1>
     6b2:	c9 01       	movw	r24, r18
     6b4:	8c 0f       	add	r24, r28
     6b6:	9d 1f       	adc	r25, r29
     6b8:	8b 3d       	cpi	r24, 0xDB	; 219
     6ba:	45 e0       	ldi	r20, 0x05	; 5
     6bc:	94 07       	cpc	r25, r20
     6be:	70 f4       	brcc	.+28     	; 0x6dc <pvPortMalloc+0x54>
     6c0:	28 17       	cp	r18, r24
     6c2:	39 07       	cpc	r19, r25
     6c4:	70 f4       	brcc	.+28     	; 0x6e2 <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     6c6:	c0 91 ba 00 	lds	r28, 0x00BA	; 0x8000ba <__data_end>
     6ca:	d0 91 bb 00 	lds	r29, 0x00BB	; 0x8000bb <__data_end+0x1>
     6ce:	c2 0f       	add	r28, r18
     6d0:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
     6d2:	90 93 bd 00 	sts	0x00BD, r25	; 0x8000bd <xNextFreeByte+0x1>
     6d6:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <xNextFreeByte>
     6da:	05 c0       	rjmp	.+10     	; 0x6e6 <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     6dc:	c0 e0       	ldi	r28, 0x00	; 0
     6de:	d0 e0       	ldi	r29, 0x00	; 0
     6e0:	02 c0       	rjmp	.+4      	; 0x6e6 <pvPortMalloc+0x5e>
     6e2:	c0 e0       	ldi	r28, 0x00	; 0
     6e4:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     6e6:	0e 94 e6 08 	call	0x11cc	; 0x11cc <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     6ea:	ce 01       	movw	r24, r28
     6ec:	df 91       	pop	r29
     6ee:	cf 91       	pop	r28
     6f0:	08 95       	ret

000006f2 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     6f2:	08 95       	ret

000006f4 <prvIsQueueEmpty>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     6f4:	0f b6       	in	r0, 0x3f	; 63
     6f6:	f8 94       	cli
     6f8:	0f 92       	push	r0
     6fa:	fc 01       	movw	r30, r24
     6fc:	92 8d       	ldd	r25, Z+26	; 0x1a
     6fe:	0f 90       	pop	r0
     700:	0f be       	out	0x3f, r0	; 63
     702:	81 e0       	ldi	r24, 0x01	; 1
     704:	91 11       	cpse	r25, r1
     706:	80 e0       	ldi	r24, 0x00	; 0
     708:	08 95       	ret

0000070a <prvCopyDataToQueue>:
     70a:	0f 93       	push	r16
     70c:	1f 93       	push	r17
     70e:	cf 93       	push	r28
     710:	df 93       	push	r29
     712:	ec 01       	movw	r28, r24
     714:	04 2f       	mov	r16, r20
     716:	1a 8d       	ldd	r17, Y+26	; 0x1a
     718:	4c 8d       	ldd	r20, Y+28	; 0x1c
     71a:	44 23       	and	r20, r20
     71c:	b9 f1       	breq	.+110    	; 0x78c <prvCopyDataToQueue+0x82>
     71e:	01 11       	cpse	r16, r1
     720:	16 c0       	rjmp	.+44     	; 0x74e <prvCopyDataToQueue+0x44>
     722:	50 e0       	ldi	r21, 0x00	; 0
     724:	8a 81       	ldd	r24, Y+2	; 0x02
     726:	9b 81       	ldd	r25, Y+3	; 0x03
     728:	0e 94 90 13 	call	0x2720	; 0x2720 <memcpy>
     72c:	2c 8d       	ldd	r18, Y+28	; 0x1c
     72e:	8a 81       	ldd	r24, Y+2	; 0x02
     730:	9b 81       	ldd	r25, Y+3	; 0x03
     732:	82 0f       	add	r24, r18
     734:	91 1d       	adc	r25, r1
     736:	9b 83       	std	Y+3, r25	; 0x03
     738:	8a 83       	std	Y+2, r24	; 0x02
     73a:	2c 81       	ldd	r18, Y+4	; 0x04
     73c:	3d 81       	ldd	r19, Y+5	; 0x05
     73e:	82 17       	cp	r24, r18
     740:	93 07       	cpc	r25, r19
     742:	20 f1       	brcs	.+72     	; 0x78c <prvCopyDataToQueue+0x82>
     744:	88 81       	ld	r24, Y
     746:	99 81       	ldd	r25, Y+1	; 0x01
     748:	9b 83       	std	Y+3, r25	; 0x03
     74a:	8a 83       	std	Y+2, r24	; 0x02
     74c:	1f c0       	rjmp	.+62     	; 0x78c <prvCopyDataToQueue+0x82>
     74e:	50 e0       	ldi	r21, 0x00	; 0
     750:	8e 81       	ldd	r24, Y+6	; 0x06
     752:	9f 81       	ldd	r25, Y+7	; 0x07
     754:	0e 94 90 13 	call	0x2720	; 0x2720 <memcpy>
     758:	8c 8d       	ldd	r24, Y+28	; 0x1c
     75a:	90 e0       	ldi	r25, 0x00	; 0
     75c:	91 95       	neg	r25
     75e:	81 95       	neg	r24
     760:	91 09       	sbc	r25, r1
     762:	2e 81       	ldd	r18, Y+6	; 0x06
     764:	3f 81       	ldd	r19, Y+7	; 0x07
     766:	28 0f       	add	r18, r24
     768:	39 1f       	adc	r19, r25
     76a:	3f 83       	std	Y+7, r19	; 0x07
     76c:	2e 83       	std	Y+6, r18	; 0x06
     76e:	48 81       	ld	r20, Y
     770:	59 81       	ldd	r21, Y+1	; 0x01
     772:	24 17       	cp	r18, r20
     774:	35 07       	cpc	r19, r21
     776:	30 f4       	brcc	.+12     	; 0x784 <prvCopyDataToQueue+0x7a>
     778:	2c 81       	ldd	r18, Y+4	; 0x04
     77a:	3d 81       	ldd	r19, Y+5	; 0x05
     77c:	82 0f       	add	r24, r18
     77e:	93 1f       	adc	r25, r19
     780:	9f 83       	std	Y+7, r25	; 0x07
     782:	8e 83       	std	Y+6, r24	; 0x06
     784:	02 30       	cpi	r16, 0x02	; 2
     786:	11 f4       	brne	.+4      	; 0x78c <prvCopyDataToQueue+0x82>
     788:	11 11       	cpse	r17, r1
     78a:	11 50       	subi	r17, 0x01	; 1
     78c:	1f 5f       	subi	r17, 0xFF	; 255
     78e:	1a 8f       	std	Y+26, r17	; 0x1a
     790:	80 e0       	ldi	r24, 0x00	; 0
     792:	df 91       	pop	r29
     794:	cf 91       	pop	r28
     796:	1f 91       	pop	r17
     798:	0f 91       	pop	r16
     79a:	08 95       	ret

0000079c <prvCopyDataFromQueue>:
     79c:	fc 01       	movw	r30, r24
     79e:	44 8d       	ldd	r20, Z+28	; 0x1c
     7a0:	44 23       	and	r20, r20
     7a2:	a9 f0       	breq	.+42     	; 0x7ce <prvCopyDataFromQueue+0x32>
     7a4:	50 e0       	ldi	r21, 0x00	; 0
     7a6:	26 81       	ldd	r18, Z+6	; 0x06
     7a8:	37 81       	ldd	r19, Z+7	; 0x07
     7aa:	24 0f       	add	r18, r20
     7ac:	35 1f       	adc	r19, r21
     7ae:	37 83       	std	Z+7, r19	; 0x07
     7b0:	26 83       	std	Z+6, r18	; 0x06
     7b2:	84 81       	ldd	r24, Z+4	; 0x04
     7b4:	95 81       	ldd	r25, Z+5	; 0x05
     7b6:	28 17       	cp	r18, r24
     7b8:	39 07       	cpc	r19, r25
     7ba:	20 f0       	brcs	.+8      	; 0x7c4 <prvCopyDataFromQueue+0x28>
     7bc:	80 81       	ld	r24, Z
     7be:	91 81       	ldd	r25, Z+1	; 0x01
     7c0:	97 83       	std	Z+7, r25	; 0x07
     7c2:	86 83       	std	Z+6, r24	; 0x06
     7c4:	cb 01       	movw	r24, r22
     7c6:	66 81       	ldd	r22, Z+6	; 0x06
     7c8:	77 81       	ldd	r23, Z+7	; 0x07
     7ca:	0e 94 90 13 	call	0x2720	; 0x2720 <memcpy>
     7ce:	08 95       	ret

000007d0 <prvUnlockQueue>:
     7d0:	ef 92       	push	r14
     7d2:	ff 92       	push	r15
     7d4:	0f 93       	push	r16
     7d6:	1f 93       	push	r17
     7d8:	cf 93       	push	r28
     7da:	8c 01       	movw	r16, r24
     7dc:	0f b6       	in	r0, 0x3f	; 63
     7de:	f8 94       	cli
     7e0:	0f 92       	push	r0
     7e2:	fc 01       	movw	r30, r24
     7e4:	c6 8d       	ldd	r28, Z+30	; 0x1e
     7e6:	1c 16       	cp	r1, r28
     7e8:	ac f4       	brge	.+42     	; 0x814 <prvUnlockQueue+0x44>
     7ea:	81 89       	ldd	r24, Z+17	; 0x11
     7ec:	81 11       	cpse	r24, r1
     7ee:	06 c0       	rjmp	.+12     	; 0x7fc <prvUnlockQueue+0x2c>
     7f0:	11 c0       	rjmp	.+34     	; 0x814 <prvUnlockQueue+0x44>
     7f2:	f8 01       	movw	r30, r16
     7f4:	81 89       	ldd	r24, Z+17	; 0x11
     7f6:	81 11       	cpse	r24, r1
     7f8:	05 c0       	rjmp	.+10     	; 0x804 <prvUnlockQueue+0x34>
     7fa:	0c c0       	rjmp	.+24     	; 0x814 <prvUnlockQueue+0x44>
     7fc:	78 01       	movw	r14, r16
     7fe:	f1 e1       	ldi	r31, 0x11	; 17
     800:	ef 0e       	add	r14, r31
     802:	f1 1c       	adc	r15, r1
     804:	c7 01       	movw	r24, r14
     806:	0e 94 38 0a 	call	0x1470	; 0x1470 <xTaskRemoveFromEventList>
     80a:	81 11       	cpse	r24, r1
     80c:	0e 94 f9 0a 	call	0x15f2	; 0x15f2 <vTaskMissedYield>
     810:	c1 50       	subi	r28, 0x01	; 1
     812:	79 f7       	brne	.-34     	; 0x7f2 <prvUnlockQueue+0x22>
     814:	8f ef       	ldi	r24, 0xFF	; 255
     816:	f8 01       	movw	r30, r16
     818:	86 8f       	std	Z+30, r24	; 0x1e
     81a:	0f 90       	pop	r0
     81c:	0f be       	out	0x3f, r0	; 63
     81e:	0f b6       	in	r0, 0x3f	; 63
     820:	f8 94       	cli
     822:	0f 92       	push	r0
     824:	c5 8d       	ldd	r28, Z+29	; 0x1d
     826:	1c 16       	cp	r1, r28
     828:	ac f4       	brge	.+42     	; 0x854 <prvUnlockQueue+0x84>
     82a:	80 85       	ldd	r24, Z+8	; 0x08
     82c:	81 11       	cpse	r24, r1
     82e:	06 c0       	rjmp	.+12     	; 0x83c <prvUnlockQueue+0x6c>
     830:	11 c0       	rjmp	.+34     	; 0x854 <prvUnlockQueue+0x84>
     832:	f8 01       	movw	r30, r16
     834:	80 85       	ldd	r24, Z+8	; 0x08
     836:	81 11       	cpse	r24, r1
     838:	05 c0       	rjmp	.+10     	; 0x844 <prvUnlockQueue+0x74>
     83a:	0c c0       	rjmp	.+24     	; 0x854 <prvUnlockQueue+0x84>
     83c:	78 01       	movw	r14, r16
     83e:	f8 e0       	ldi	r31, 0x08	; 8
     840:	ef 0e       	add	r14, r31
     842:	f1 1c       	adc	r15, r1
     844:	c7 01       	movw	r24, r14
     846:	0e 94 38 0a 	call	0x1470	; 0x1470 <xTaskRemoveFromEventList>
     84a:	81 11       	cpse	r24, r1
     84c:	0e 94 f9 0a 	call	0x15f2	; 0x15f2 <vTaskMissedYield>
     850:	c1 50       	subi	r28, 0x01	; 1
     852:	79 f7       	brne	.-34     	; 0x832 <prvUnlockQueue+0x62>
     854:	8f ef       	ldi	r24, 0xFF	; 255
     856:	f8 01       	movw	r30, r16
     858:	85 8f       	std	Z+29, r24	; 0x1d
     85a:	0f 90       	pop	r0
     85c:	0f be       	out	0x3f, r0	; 63
     85e:	cf 91       	pop	r28
     860:	1f 91       	pop	r17
     862:	0f 91       	pop	r16
     864:	ff 90       	pop	r15
     866:	ef 90       	pop	r14
     868:	08 95       	ret

0000086a <xQueueGenericReset>:
     86a:	cf 93       	push	r28
     86c:	df 93       	push	r29
     86e:	ec 01       	movw	r28, r24
     870:	0f b6       	in	r0, 0x3f	; 63
     872:	f8 94       	cli
     874:	0f 92       	push	r0
     876:	e8 81       	ld	r30, Y
     878:	f9 81       	ldd	r31, Y+1	; 0x01
     87a:	8b 8d       	ldd	r24, Y+27	; 0x1b
     87c:	2c 8d       	ldd	r18, Y+28	; 0x1c
     87e:	90 e0       	ldi	r25, 0x00	; 0
     880:	30 e0       	ldi	r19, 0x00	; 0
     882:	82 9f       	mul	r24, r18
     884:	a0 01       	movw	r20, r0
     886:	83 9f       	mul	r24, r19
     888:	50 0d       	add	r21, r0
     88a:	92 9f       	mul	r25, r18
     88c:	50 0d       	add	r21, r0
     88e:	11 24       	eor	r1, r1
     890:	4e 0f       	add	r20, r30
     892:	5f 1f       	adc	r21, r31
     894:	5d 83       	std	Y+5, r21	; 0x05
     896:	4c 83       	std	Y+4, r20	; 0x04
     898:	1a 8e       	std	Y+26, r1	; 0x1a
     89a:	fb 83       	std	Y+3, r31	; 0x03
     89c:	ea 83       	std	Y+2, r30	; 0x02
     89e:	01 97       	sbiw	r24, 0x01	; 1
     8a0:	82 9f       	mul	r24, r18
     8a2:	a0 01       	movw	r20, r0
     8a4:	83 9f       	mul	r24, r19
     8a6:	50 0d       	add	r21, r0
     8a8:	92 9f       	mul	r25, r18
     8aa:	50 0d       	add	r21, r0
     8ac:	11 24       	eor	r1, r1
     8ae:	cf 01       	movw	r24, r30
     8b0:	84 0f       	add	r24, r20
     8b2:	95 1f       	adc	r25, r21
     8b4:	9f 83       	std	Y+7, r25	; 0x07
     8b6:	8e 83       	std	Y+6, r24	; 0x06
     8b8:	8f ef       	ldi	r24, 0xFF	; 255
     8ba:	8d 8f       	std	Y+29, r24	; 0x1d
     8bc:	8e 8f       	std	Y+30, r24	; 0x1e
     8be:	61 11       	cpse	r22, r1
     8c0:	0c c0       	rjmp	.+24     	; 0x8da <xQueueGenericReset+0x70>
     8c2:	88 85       	ldd	r24, Y+8	; 0x08
     8c4:	88 23       	and	r24, r24
     8c6:	89 f0       	breq	.+34     	; 0x8ea <xQueueGenericReset+0x80>
     8c8:	ce 01       	movw	r24, r28
     8ca:	08 96       	adiw	r24, 0x08	; 8
     8cc:	0e 94 38 0a 	call	0x1470	; 0x1470 <xTaskRemoveFromEventList>
     8d0:	88 23       	and	r24, r24
     8d2:	59 f0       	breq	.+22     	; 0x8ea <xQueueGenericReset+0x80>
     8d4:	0e 94 8d 02 	call	0x51a	; 0x51a <vPortYield>
     8d8:	08 c0       	rjmp	.+16     	; 0x8ea <xQueueGenericReset+0x80>
     8da:	ce 01       	movw	r24, r28
     8dc:	08 96       	adiw	r24, 0x08	; 8
     8de:	0e 94 61 01 	call	0x2c2	; 0x2c2 <vListInitialise>
     8e2:	ce 01       	movw	r24, r28
     8e4:	41 96       	adiw	r24, 0x11	; 17
     8e6:	0e 94 61 01 	call	0x2c2	; 0x2c2 <vListInitialise>
     8ea:	0f 90       	pop	r0
     8ec:	0f be       	out	0x3f, r0	; 63
     8ee:	81 e0       	ldi	r24, 0x01	; 1
     8f0:	df 91       	pop	r29
     8f2:	cf 91       	pop	r28
     8f4:	08 95       	ret

000008f6 <xQueueGenericCreate>:
     8f6:	0f 93       	push	r16
     8f8:	1f 93       	push	r17
     8fa:	cf 93       	push	r28
     8fc:	df 93       	push	r29
     8fe:	08 2f       	mov	r16, r24
     900:	16 2f       	mov	r17, r22
     902:	86 9f       	mul	r24, r22
     904:	c0 01       	movw	r24, r0
     906:	11 24       	eor	r1, r1
     908:	4f 96       	adiw	r24, 0x1f	; 31
     90a:	0e 94 44 03 	call	0x688	; 0x688 <pvPortMalloc>
     90e:	ec 01       	movw	r28, r24
     910:	00 97       	sbiw	r24, 0x00	; 0
     912:	71 f0       	breq	.+28     	; 0x930 <xQueueGenericCreate+0x3a>
     914:	11 11       	cpse	r17, r1
     916:	03 c0       	rjmp	.+6      	; 0x91e <xQueueGenericCreate+0x28>
     918:	99 83       	std	Y+1, r25	; 0x01
     91a:	88 83       	st	Y, r24
     91c:	03 c0       	rjmp	.+6      	; 0x924 <xQueueGenericCreate+0x2e>
     91e:	4f 96       	adiw	r24, 0x1f	; 31
     920:	99 83       	std	Y+1, r25	; 0x01
     922:	88 83       	st	Y, r24
     924:	0b 8f       	std	Y+27, r16	; 0x1b
     926:	1c 8f       	std	Y+28, r17	; 0x1c
     928:	61 e0       	ldi	r22, 0x01	; 1
     92a:	ce 01       	movw	r24, r28
     92c:	0e 94 35 04 	call	0x86a	; 0x86a <xQueueGenericReset>
     930:	ce 01       	movw	r24, r28
     932:	df 91       	pop	r29
     934:	cf 91       	pop	r28
     936:	1f 91       	pop	r17
     938:	0f 91       	pop	r16
     93a:	08 95       	ret

0000093c <xQueueGenericSend>:
     93c:	9f 92       	push	r9
     93e:	af 92       	push	r10
     940:	bf 92       	push	r11
     942:	cf 92       	push	r12
     944:	df 92       	push	r13
     946:	ef 92       	push	r14
     948:	ff 92       	push	r15
     94a:	0f 93       	push	r16
     94c:	1f 93       	push	r17
     94e:	cf 93       	push	r28
     950:	df 93       	push	r29
     952:	00 d0       	rcall	.+0      	; 0x954 <xQueueGenericSend+0x18>
     954:	00 d0       	rcall	.+0      	; 0x956 <xQueueGenericSend+0x1a>
     956:	1f 92       	push	r1
     958:	cd b7       	in	r28, 0x3d	; 61
     95a:	de b7       	in	r29, 0x3e	; 62
     95c:	8c 01       	movw	r16, r24
     95e:	6b 01       	movw	r12, r22
     960:	5d 83       	std	Y+5, r21	; 0x05
     962:	4c 83       	std	Y+4, r20	; 0x04
     964:	a2 2e       	mov	r10, r18
     966:	b1 2c       	mov	r11, r1
     968:	99 24       	eor	r9, r9
     96a:	93 94       	inc	r9
     96c:	7c 01       	movw	r14, r24
     96e:	88 e0       	ldi	r24, 0x08	; 8
     970:	e8 0e       	add	r14, r24
     972:	f1 1c       	adc	r15, r1
     974:	0f b6       	in	r0, 0x3f	; 63
     976:	f8 94       	cli
     978:	0f 92       	push	r0
     97a:	f8 01       	movw	r30, r16
     97c:	92 8d       	ldd	r25, Z+26	; 0x1a
     97e:	83 8d       	ldd	r24, Z+27	; 0x1b
     980:	98 17       	cp	r25, r24
     982:	18 f0       	brcs	.+6      	; 0x98a <xQueueGenericSend+0x4e>
     984:	f2 e0       	ldi	r31, 0x02	; 2
     986:	af 12       	cpse	r10, r31
     988:	19 c0       	rjmp	.+50     	; 0x9bc <xQueueGenericSend+0x80>
     98a:	4a 2d       	mov	r20, r10
     98c:	b6 01       	movw	r22, r12
     98e:	c8 01       	movw	r24, r16
     990:	0e 94 85 03 	call	0x70a	; 0x70a <prvCopyDataToQueue>
     994:	f8 01       	movw	r30, r16
     996:	91 89       	ldd	r25, Z+17	; 0x11
     998:	99 23       	and	r25, r25
     99a:	49 f0       	breq	.+18     	; 0x9ae <xQueueGenericSend+0x72>
     99c:	c8 01       	movw	r24, r16
     99e:	41 96       	adiw	r24, 0x11	; 17
     9a0:	0e 94 38 0a 	call	0x1470	; 0x1470 <xTaskRemoveFromEventList>
     9a4:	88 23       	and	r24, r24
     9a6:	31 f0       	breq	.+12     	; 0x9b4 <xQueueGenericSend+0x78>
     9a8:	0e 94 8d 02 	call	0x51a	; 0x51a <vPortYield>
     9ac:	03 c0       	rjmp	.+6      	; 0x9b4 <xQueueGenericSend+0x78>
     9ae:	81 11       	cpse	r24, r1
     9b0:	0e 94 8d 02 	call	0x51a	; 0x51a <vPortYield>
     9b4:	0f 90       	pop	r0
     9b6:	0f be       	out	0x3f, r0	; 63
     9b8:	81 e0       	ldi	r24, 0x01	; 1
     9ba:	50 c0       	rjmp	.+160    	; 0xa5c <xQueueGenericSend+0x120>
     9bc:	8c 81       	ldd	r24, Y+4	; 0x04
     9be:	9d 81       	ldd	r25, Y+5	; 0x05
     9c0:	89 2b       	or	r24, r25
     9c2:	21 f4       	brne	.+8      	; 0x9cc <xQueueGenericSend+0x90>
     9c4:	0f 90       	pop	r0
     9c6:	0f be       	out	0x3f, r0	; 63
     9c8:	80 e0       	ldi	r24, 0x00	; 0
     9ca:	48 c0       	rjmp	.+144    	; 0xa5c <xQueueGenericSend+0x120>
     9cc:	b1 10       	cpse	r11, r1
     9ce:	05 c0       	rjmp	.+10     	; 0x9da <xQueueGenericSend+0x9e>
     9d0:	ce 01       	movw	r24, r28
     9d2:	01 96       	adiw	r24, 0x01	; 1
     9d4:	0e 94 b8 0a 	call	0x1570	; 0x1570 <vTaskInternalSetTimeOutState>
     9d8:	b9 2c       	mov	r11, r9
     9da:	0f 90       	pop	r0
     9dc:	0f be       	out	0x3f, r0	; 63
     9de:	0e 94 17 08 	call	0x102e	; 0x102e <vTaskSuspendAll>
     9e2:	0f b6       	in	r0, 0x3f	; 63
     9e4:	f8 94       	cli
     9e6:	0f 92       	push	r0
     9e8:	f8 01       	movw	r30, r16
     9ea:	85 8d       	ldd	r24, Z+29	; 0x1d
     9ec:	8f 3f       	cpi	r24, 0xFF	; 255
     9ee:	09 f4       	brne	.+2      	; 0x9f2 <xQueueGenericSend+0xb6>
     9f0:	15 8e       	std	Z+29, r1	; 0x1d
     9f2:	f8 01       	movw	r30, r16
     9f4:	86 8d       	ldd	r24, Z+30	; 0x1e
     9f6:	8f 3f       	cpi	r24, 0xFF	; 255
     9f8:	09 f4       	brne	.+2      	; 0x9fc <xQueueGenericSend+0xc0>
     9fa:	16 8e       	std	Z+30, r1	; 0x1e
     9fc:	0f 90       	pop	r0
     9fe:	0f be       	out	0x3f, r0	; 63
     a00:	be 01       	movw	r22, r28
     a02:	6c 5f       	subi	r22, 0xFC	; 252
     a04:	7f 4f       	sbci	r23, 0xFF	; 255
     a06:	ce 01       	movw	r24, r28
     a08:	01 96       	adiw	r24, 0x01	; 1
     a0a:	0e 94 c3 0a 	call	0x1586	; 0x1586 <xTaskCheckForTimeOut>
     a0e:	81 11       	cpse	r24, r1
     a10:	1f c0       	rjmp	.+62     	; 0xa50 <xQueueGenericSend+0x114>
     a12:	0f b6       	in	r0, 0x3f	; 63
     a14:	f8 94       	cli
     a16:	0f 92       	push	r0
     a18:	f8 01       	movw	r30, r16
     a1a:	92 8d       	ldd	r25, Z+26	; 0x1a
     a1c:	0f 90       	pop	r0
     a1e:	0f be       	out	0x3f, r0	; 63
     a20:	83 8d       	ldd	r24, Z+27	; 0x1b
     a22:	98 13       	cpse	r25, r24
     a24:	0f c0       	rjmp	.+30     	; 0xa44 <xQueueGenericSend+0x108>
     a26:	6c 81       	ldd	r22, Y+4	; 0x04
     a28:	7d 81       	ldd	r23, Y+5	; 0x05
     a2a:	c7 01       	movw	r24, r14
     a2c:	0e 94 0d 0a 	call	0x141a	; 0x141a <vTaskPlaceOnEventList>
     a30:	c8 01       	movw	r24, r16
     a32:	0e 94 e8 03 	call	0x7d0	; 0x7d0 <prvUnlockQueue>
     a36:	0e 94 e6 08 	call	0x11cc	; 0x11cc <xTaskResumeAll>
     a3a:	81 11       	cpse	r24, r1
     a3c:	9b cf       	rjmp	.-202    	; 0x974 <xQueueGenericSend+0x38>
     a3e:	0e 94 8d 02 	call	0x51a	; 0x51a <vPortYield>
     a42:	98 cf       	rjmp	.-208    	; 0x974 <xQueueGenericSend+0x38>
     a44:	c8 01       	movw	r24, r16
     a46:	0e 94 e8 03 	call	0x7d0	; 0x7d0 <prvUnlockQueue>
     a4a:	0e 94 e6 08 	call	0x11cc	; 0x11cc <xTaskResumeAll>
     a4e:	92 cf       	rjmp	.-220    	; 0x974 <xQueueGenericSend+0x38>
     a50:	c8 01       	movw	r24, r16
     a52:	0e 94 e8 03 	call	0x7d0	; 0x7d0 <prvUnlockQueue>
     a56:	0e 94 e6 08 	call	0x11cc	; 0x11cc <xTaskResumeAll>
     a5a:	80 e0       	ldi	r24, 0x00	; 0
     a5c:	0f 90       	pop	r0
     a5e:	0f 90       	pop	r0
     a60:	0f 90       	pop	r0
     a62:	0f 90       	pop	r0
     a64:	0f 90       	pop	r0
     a66:	df 91       	pop	r29
     a68:	cf 91       	pop	r28
     a6a:	1f 91       	pop	r17
     a6c:	0f 91       	pop	r16
     a6e:	ff 90       	pop	r15
     a70:	ef 90       	pop	r14
     a72:	df 90       	pop	r13
     a74:	cf 90       	pop	r12
     a76:	bf 90       	pop	r11
     a78:	af 90       	pop	r10
     a7a:	9f 90       	pop	r9
     a7c:	08 95       	ret

00000a7e <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
     a7e:	9f 92       	push	r9
     a80:	af 92       	push	r10
     a82:	bf 92       	push	r11
     a84:	cf 92       	push	r12
     a86:	df 92       	push	r13
     a88:	ef 92       	push	r14
     a8a:	ff 92       	push	r15
     a8c:	0f 93       	push	r16
     a8e:	1f 93       	push	r17
     a90:	cf 93       	push	r28
     a92:	df 93       	push	r29
     a94:	00 d0       	rcall	.+0      	; 0xa96 <xQueueReceive+0x18>
     a96:	00 d0       	rcall	.+0      	; 0xa98 <xQueueReceive+0x1a>
     a98:	1f 92       	push	r1
     a9a:	cd b7       	in	r28, 0x3d	; 61
     a9c:	de b7       	in	r29, 0x3e	; 62
     a9e:	8c 01       	movw	r16, r24
     aa0:	5b 01       	movw	r10, r22
     aa2:	5d 83       	std	Y+5, r21	; 0x05
     aa4:	4c 83       	std	Y+4, r20	; 0x04
BaseType_t xEntryTimeSet = pdFALSE;
     aa6:	e1 2c       	mov	r14, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
     aa8:	99 24       	eor	r9, r9
     aaa:	93 94       	inc	r9
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     aac:	6c 01       	movw	r12, r24
     aae:	81 e1       	ldi	r24, 0x11	; 17
     ab0:	c8 0e       	add	r12, r24
     ab2:	d1 1c       	adc	r13, r1
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
     ab4:	0f b6       	in	r0, 0x3f	; 63
     ab6:	f8 94       	cli
     ab8:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
     aba:	f8 01       	movw	r30, r16
     abc:	f2 8c       	ldd	r15, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
     abe:	ff 20       	and	r15, r15
     ac0:	a9 f0       	breq	.+42     	; 0xaec <xQueueReceive+0x6e>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
     ac2:	b5 01       	movw	r22, r10
     ac4:	c8 01       	movw	r24, r16
     ac6:	0e 94 ce 03 	call	0x79c	; 0x79c <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
     aca:	fa 94       	dec	r15
     acc:	f8 01       	movw	r30, r16
     ace:	f2 8e       	std	Z+26, r15	; 0x1a

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     ad0:	80 85       	ldd	r24, Z+8	; 0x08
     ad2:	88 23       	and	r24, r24
     ad4:	39 f0       	breq	.+14     	; 0xae4 <xQueueReceive+0x66>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     ad6:	c8 01       	movw	r24, r16
     ad8:	08 96       	adiw	r24, 0x08	; 8
     ada:	0e 94 38 0a 	call	0x1470	; 0x1470 <xTaskRemoveFromEventList>
     ade:	81 11       	cpse	r24, r1
					{
						queueYIELD_IF_USING_PREEMPTION();
     ae0:	0e 94 8d 02 	call	0x51a	; 0x51a <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
     ae4:	0f 90       	pop	r0
     ae6:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
     ae8:	81 e0       	ldi	r24, 0x01	; 1
     aea:	51 c0       	rjmp	.+162    	; 0xb8e <xQueueReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
     aec:	8c 81       	ldd	r24, Y+4	; 0x04
     aee:	9d 81       	ldd	r25, Y+5	; 0x05
     af0:	89 2b       	or	r24, r25
     af2:	21 f4       	brne	.+8      	; 0xafc <xQueueReceive+0x7e>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     af4:	0f 90       	pop	r0
     af6:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
     af8:	80 e0       	ldi	r24, 0x00	; 0
     afa:	49 c0       	rjmp	.+146    	; 0xb8e <xQueueReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
     afc:	e1 10       	cpse	r14, r1
     afe:	05 c0       	rjmp	.+10     	; 0xb0a <xQueueReceive+0x8c>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
     b00:	ce 01       	movw	r24, r28
     b02:	01 96       	adiw	r24, 0x01	; 1
     b04:	0e 94 b8 0a 	call	0x1570	; 0x1570 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
     b08:	e9 2c       	mov	r14, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
     b0a:	0f 90       	pop	r0
     b0c:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     b0e:	0e 94 17 08 	call	0x102e	; 0x102e <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     b12:	0f b6       	in	r0, 0x3f	; 63
     b14:	f8 94       	cli
     b16:	0f 92       	push	r0
     b18:	f8 01       	movw	r30, r16
     b1a:	85 8d       	ldd	r24, Z+29	; 0x1d
     b1c:	8f 3f       	cpi	r24, 0xFF	; 255
     b1e:	09 f4       	brne	.+2      	; 0xb22 <xQueueReceive+0xa4>
     b20:	15 8e       	std	Z+29, r1	; 0x1d
     b22:	f8 01       	movw	r30, r16
     b24:	86 8d       	ldd	r24, Z+30	; 0x1e
     b26:	8f 3f       	cpi	r24, 0xFF	; 255
     b28:	09 f4       	brne	.+2      	; 0xb2c <xQueueReceive+0xae>
     b2a:	16 8e       	std	Z+30, r1	; 0x1e
     b2c:	0f 90       	pop	r0
     b2e:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     b30:	be 01       	movw	r22, r28
     b32:	6c 5f       	subi	r22, 0xFC	; 252
     b34:	7f 4f       	sbci	r23, 0xFF	; 255
     b36:	ce 01       	movw	r24, r28
     b38:	01 96       	adiw	r24, 0x01	; 1
     b3a:	0e 94 c3 0a 	call	0x1586	; 0x1586 <xTaskCheckForTimeOut>
     b3e:	81 11       	cpse	r24, r1
     b40:	1a c0       	rjmp	.+52     	; 0xb76 <xQueueReceive+0xf8>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     b42:	c8 01       	movw	r24, r16
     b44:	0e 94 7a 03 	call	0x6f4	; 0x6f4 <prvIsQueueEmpty>
     b48:	88 23       	and	r24, r24
     b4a:	79 f0       	breq	.+30     	; 0xb6a <xQueueReceive+0xec>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     b4c:	6c 81       	ldd	r22, Y+4	; 0x04
     b4e:	7d 81       	ldd	r23, Y+5	; 0x05
     b50:	c6 01       	movw	r24, r12
     b52:	0e 94 0d 0a 	call	0x141a	; 0x141a <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
     b56:	c8 01       	movw	r24, r16
     b58:	0e 94 e8 03 	call	0x7d0	; 0x7d0 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
     b5c:	0e 94 e6 08 	call	0x11cc	; 0x11cc <xTaskResumeAll>
     b60:	81 11       	cpse	r24, r1
     b62:	a8 cf       	rjmp	.-176    	; 0xab4 <xQueueReceive+0x36>
				{
					portYIELD_WITHIN_API();
     b64:	0e 94 8d 02 	call	0x51a	; 0x51a <vPortYield>
     b68:	a5 cf       	rjmp	.-182    	; 0xab4 <xQueueReceive+0x36>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
     b6a:	c8 01       	movw	r24, r16
     b6c:	0e 94 e8 03 	call	0x7d0	; 0x7d0 <prvUnlockQueue>
				( void ) xTaskResumeAll();
     b70:	0e 94 e6 08 	call	0x11cc	; 0x11cc <xTaskResumeAll>
     b74:	9f cf       	rjmp	.-194    	; 0xab4 <xQueueReceive+0x36>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
     b76:	c8 01       	movw	r24, r16
     b78:	0e 94 e8 03 	call	0x7d0	; 0x7d0 <prvUnlockQueue>
			( void ) xTaskResumeAll();
     b7c:	0e 94 e6 08 	call	0x11cc	; 0x11cc <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     b80:	c8 01       	movw	r24, r16
     b82:	0e 94 7a 03 	call	0x6f4	; 0x6f4 <prvIsQueueEmpty>
     b86:	88 23       	and	r24, r24
     b88:	09 f4       	brne	.+2      	; 0xb8c <xQueueReceive+0x10e>
     b8a:	94 cf       	rjmp	.-216    	; 0xab4 <xQueueReceive+0x36>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
     b8c:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
     b8e:	0f 90       	pop	r0
     b90:	0f 90       	pop	r0
     b92:	0f 90       	pop	r0
     b94:	0f 90       	pop	r0
     b96:	0f 90       	pop	r0
     b98:	df 91       	pop	r29
     b9a:	cf 91       	pop	r28
     b9c:	1f 91       	pop	r17
     b9e:	0f 91       	pop	r16
     ba0:	ff 90       	pop	r15
     ba2:	ef 90       	pop	r14
     ba4:	df 90       	pop	r13
     ba6:	cf 90       	pop	r12
     ba8:	bf 90       	pop	r11
     baa:	af 90       	pop	r10
     bac:	9f 90       	pop	r9
     bae:	08 95       	ret

00000bb0 <prvResetNextTaskUnblockTime>:
	taskENTER_CRITICAL();
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
		pxTimeOut->xTimeOnEntering = xTickCount;
	}
	taskEXIT_CRITICAL();
     bb0:	e0 91 c7 06 	lds	r30, 0x06C7	; 0x8006c7 <pxDelayedTaskList>
     bb4:	f0 91 c8 06 	lds	r31, 0x06C8	; 0x8006c8 <pxDelayedTaskList+0x1>
     bb8:	80 81       	ld	r24, Z
     bba:	81 11       	cpse	r24, r1
     bbc:	07 c0       	rjmp	.+14     	; 0xbcc <prvResetNextTaskUnblockTime+0x1c>
     bbe:	8f ef       	ldi	r24, 0xFF	; 255
     bc0:	9f ef       	ldi	r25, 0xFF	; 255
     bc2:	90 93 9e 06 	sts	0x069E, r25	; 0x80069e <xNextTaskUnblockTime+0x1>
     bc6:	80 93 9d 06 	sts	0x069D, r24	; 0x80069d <xNextTaskUnblockTime>
     bca:	08 95       	ret
     bcc:	e0 91 c7 06 	lds	r30, 0x06C7	; 0x8006c7 <pxDelayedTaskList>
     bd0:	f0 91 c8 06 	lds	r31, 0x06C8	; 0x8006c8 <pxDelayedTaskList+0x1>
     bd4:	05 80       	ldd	r0, Z+5	; 0x05
     bd6:	f6 81       	ldd	r31, Z+6	; 0x06
     bd8:	e0 2d       	mov	r30, r0
     bda:	80 81       	ld	r24, Z
     bdc:	91 81       	ldd	r25, Z+1	; 0x01
     bde:	90 93 9e 06 	sts	0x069E, r25	; 0x80069e <xNextTaskUnblockTime+0x1>
     be2:	80 93 9d 06 	sts	0x069D, r24	; 0x80069d <xNextTaskUnblockTime>
     be6:	08 95       	ret

00000be8 <prvAddCurrentTaskToDelayedList>:
     be8:	ff 92       	push	r15
     bea:	0f 93       	push	r16
     bec:	1f 93       	push	r17
     bee:	cf 93       	push	r28
     bf0:	df 93       	push	r29
     bf2:	ec 01       	movw	r28, r24
     bf4:	f6 2e       	mov	r15, r22
     bf6:	00 91 a6 06 	lds	r16, 0x06A6	; 0x8006a6 <xTickCount>
     bfa:	10 91 a7 06 	lds	r17, 0x06A7	; 0x8006a7 <xTickCount+0x1>
     bfe:	80 91 ff 06 	lds	r24, 0x06FF	; 0x8006ff <pxCurrentTCB>
     c02:	90 91 00 07 	lds	r25, 0x0700	; 0x800700 <pxCurrentTCB+0x1>
     c06:	02 96       	adiw	r24, 0x02	; 2
     c08:	0e 94 c5 01 	call	0x38a	; 0x38a <uxListRemove>
     c0c:	cf 3f       	cpi	r28, 0xFF	; 255
     c0e:	8f ef       	ldi	r24, 0xFF	; 255
     c10:	d8 07       	cpc	r29, r24
     c12:	69 f4       	brne	.+26     	; 0xc2e <prvAddCurrentTaskToDelayedList+0x46>
     c14:	ff 20       	and	r15, r15
     c16:	59 f0       	breq	.+22     	; 0xc2e <prvAddCurrentTaskToDelayedList+0x46>
     c18:	60 91 ff 06 	lds	r22, 0x06FF	; 0x8006ff <pxCurrentTCB>
     c1c:	70 91 00 07 	lds	r23, 0x0700	; 0x800700 <pxCurrentTCB+0x1>
     c20:	6e 5f       	subi	r22, 0xFE	; 254
     c22:	7f 4f       	sbci	r23, 0xFF	; 255
     c24:	89 ea       	ldi	r24, 0xA9	; 169
     c26:	96 e0       	ldi	r25, 0x06	; 6
     c28:	0e 94 73 01 	call	0x2e6	; 0x2e6 <vListInsertEnd>
     c2c:	2f c0       	rjmp	.+94     	; 0xc8c <prvAddCurrentTaskToDelayedList+0xa4>
     c2e:	c0 0f       	add	r28, r16
     c30:	d1 1f       	adc	r29, r17
     c32:	e0 91 ff 06 	lds	r30, 0x06FF	; 0x8006ff <pxCurrentTCB>
     c36:	f0 91 00 07 	lds	r31, 0x0700	; 0x800700 <pxCurrentTCB+0x1>
     c3a:	d3 83       	std	Z+3, r29	; 0x03
     c3c:	c2 83       	std	Z+2, r28	; 0x02
     c3e:	c0 17       	cp	r28, r16
     c40:	d1 07       	cpc	r29, r17
     c42:	68 f4       	brcc	.+26     	; 0xc5e <prvAddCurrentTaskToDelayedList+0x76>
     c44:	60 91 ff 06 	lds	r22, 0x06FF	; 0x8006ff <pxCurrentTCB>
     c48:	70 91 00 07 	lds	r23, 0x0700	; 0x800700 <pxCurrentTCB+0x1>
     c4c:	80 91 c5 06 	lds	r24, 0x06C5	; 0x8006c5 <pxOverflowDelayedTaskList>
     c50:	90 91 c6 06 	lds	r25, 0x06C6	; 0x8006c6 <pxOverflowDelayedTaskList+0x1>
     c54:	6e 5f       	subi	r22, 0xFE	; 254
     c56:	7f 4f       	sbci	r23, 0xFF	; 255
     c58:	0e 94 94 01 	call	0x328	; 0x328 <vListInsert>
     c5c:	17 c0       	rjmp	.+46     	; 0xc8c <prvAddCurrentTaskToDelayedList+0xa4>
     c5e:	60 91 ff 06 	lds	r22, 0x06FF	; 0x8006ff <pxCurrentTCB>
     c62:	70 91 00 07 	lds	r23, 0x0700	; 0x800700 <pxCurrentTCB+0x1>
     c66:	80 91 c7 06 	lds	r24, 0x06C7	; 0x8006c7 <pxDelayedTaskList>
     c6a:	90 91 c8 06 	lds	r25, 0x06C8	; 0x8006c8 <pxDelayedTaskList+0x1>
     c6e:	6e 5f       	subi	r22, 0xFE	; 254
     c70:	7f 4f       	sbci	r23, 0xFF	; 255
     c72:	0e 94 94 01 	call	0x328	; 0x328 <vListInsert>
     c76:	80 91 9d 06 	lds	r24, 0x069D	; 0x80069d <xNextTaskUnblockTime>
     c7a:	90 91 9e 06 	lds	r25, 0x069E	; 0x80069e <xNextTaskUnblockTime+0x1>
     c7e:	c8 17       	cp	r28, r24
     c80:	d9 07       	cpc	r29, r25
     c82:	20 f4       	brcc	.+8      	; 0xc8c <prvAddCurrentTaskToDelayedList+0xa4>
     c84:	d0 93 9e 06 	sts	0x069E, r29	; 0x80069e <xNextTaskUnblockTime+0x1>
     c88:	c0 93 9d 06 	sts	0x069D, r28	; 0x80069d <xNextTaskUnblockTime>
     c8c:	df 91       	pop	r29
     c8e:	cf 91       	pop	r28
     c90:	1f 91       	pop	r17
     c92:	0f 91       	pop	r16
     c94:	ff 90       	pop	r15
     c96:	08 95       	ret

00000c98 <prvIdleTask>:
     c98:	03 eb       	ldi	r16, 0xB3	; 179
     c9a:	16 e0       	ldi	r17, 0x06	; 6
     c9c:	0f 2e       	mov	r0, r31
     c9e:	fb ed       	ldi	r31, 0xDB	; 219
     ca0:	ef 2e       	mov	r14, r31
     ca2:	f6 e0       	ldi	r31, 0x06	; 6
     ca4:	ff 2e       	mov	r15, r31
     ca6:	f0 2d       	mov	r31, r0
     ca8:	80 91 b2 06 	lds	r24, 0x06B2	; 0x8006b2 <uxDeletedTasksWaitingCleanUp>
     cac:	88 23       	and	r24, r24
     cae:	29 f1       	breq	.+74     	; 0xcfa <prvIdleTask+0x62>
     cb0:	0f b6       	in	r0, 0x3f	; 63
     cb2:	f8 94       	cli
     cb4:	0f 92       	push	r0
     cb6:	d8 01       	movw	r26, r16
     cb8:	15 96       	adiw	r26, 0x05	; 5
     cba:	ed 91       	ld	r30, X+
     cbc:	fc 91       	ld	r31, X
     cbe:	16 97       	sbiw	r26, 0x06	; 6
     cc0:	c6 81       	ldd	r28, Z+6	; 0x06
     cc2:	d7 81       	ldd	r29, Z+7	; 0x07
     cc4:	ce 01       	movw	r24, r28
     cc6:	02 96       	adiw	r24, 0x02	; 2
     cc8:	0e 94 c5 01 	call	0x38a	; 0x38a <uxListRemove>
     ccc:	80 91 a8 06 	lds	r24, 0x06A8	; 0x8006a8 <uxCurrentNumberOfTasks>
     cd0:	81 50       	subi	r24, 0x01	; 1
     cd2:	80 93 a8 06 	sts	0x06A8, r24	; 0x8006a8 <uxCurrentNumberOfTasks>
     cd6:	80 91 b2 06 	lds	r24, 0x06B2	; 0x8006b2 <uxDeletedTasksWaitingCleanUp>
     cda:	81 50       	subi	r24, 0x01	; 1
     cdc:	80 93 b2 06 	sts	0x06B2, r24	; 0x8006b2 <uxDeletedTasksWaitingCleanUp>
     ce0:	0f 90       	pop	r0
     ce2:	0f be       	out	0x3f, r0	; 63
     ce4:	8f 89       	ldd	r24, Y+23	; 0x17
     ce6:	98 8d       	ldd	r25, Y+24	; 0x18
     ce8:	0e 94 79 03 	call	0x6f2	; 0x6f2 <vPortFree>
     cec:	ce 01       	movw	r24, r28
     cee:	0e 94 79 03 	call	0x6f2	; 0x6f2 <vPortFree>
     cf2:	80 91 b2 06 	lds	r24, 0x06B2	; 0x8006b2 <uxDeletedTasksWaitingCleanUp>
     cf6:	81 11       	cpse	r24, r1
     cf8:	db cf       	rjmp	.-74     	; 0xcb0 <prvIdleTask+0x18>
     cfa:	f7 01       	movw	r30, r14
     cfc:	80 81       	ld	r24, Z
     cfe:	82 30       	cpi	r24, 0x02	; 2
     d00:	10 f0       	brcs	.+4      	; 0xd06 <prvIdleTask+0x6e>
     d02:	0e 94 8d 02 	call	0x51a	; 0x51a <vPortYield>
     d06:	0e 94 af 0c 	call	0x195e	; 0x195e <vApplicationIdleHook>
     d0a:	ce cf       	rjmp	.-100    	; 0xca8 <prvIdleTask+0x10>

00000d0c <xTaskCreate>:
     d0c:	4f 92       	push	r4
     d0e:	5f 92       	push	r5
     d10:	6f 92       	push	r6
     d12:	7f 92       	push	r7
     d14:	8f 92       	push	r8
     d16:	9f 92       	push	r9
     d18:	af 92       	push	r10
     d1a:	bf 92       	push	r11
     d1c:	cf 92       	push	r12
     d1e:	df 92       	push	r13
     d20:	ef 92       	push	r14
     d22:	ff 92       	push	r15
     d24:	0f 93       	push	r16
     d26:	cf 93       	push	r28
     d28:	df 93       	push	r29
     d2a:	4c 01       	movw	r8, r24
     d2c:	6b 01       	movw	r12, r22
     d2e:	5a 01       	movw	r10, r20
     d30:	29 01       	movw	r4, r18
     d32:	ca 01       	movw	r24, r20
     d34:	0e 94 44 03 	call	0x688	; 0x688 <pvPortMalloc>
     d38:	3c 01       	movw	r6, r24
     d3a:	89 2b       	or	r24, r25
     d3c:	09 f4       	brne	.+2      	; 0xd40 <xTaskCreate+0x34>
     d3e:	e7 c0       	rjmp	.+462    	; 0xf0e <xTaskCreate+0x202>
     d40:	86 e2       	ldi	r24, 0x26	; 38
     d42:	90 e0       	ldi	r25, 0x00	; 0
     d44:	0e 94 44 03 	call	0x688	; 0x688 <pvPortMalloc>
     d48:	ec 01       	movw	r28, r24
     d4a:	89 2b       	or	r24, r25
     d4c:	59 f0       	breq	.+22     	; 0xd64 <xTaskCreate+0x58>
     d4e:	78 8e       	std	Y+24, r7	; 0x18
     d50:	6f 8a       	std	Y+23, r6	; 0x17
     d52:	81 e0       	ldi	r24, 0x01	; 1
     d54:	a8 1a       	sub	r10, r24
     d56:	b1 08       	sbc	r11, r1
     d58:	a6 0c       	add	r10, r6
     d5a:	b7 1c       	adc	r11, r7
     d5c:	c1 14       	cp	r12, r1
     d5e:	d1 04       	cpc	r13, r1
     d60:	29 f4       	brne	.+10     	; 0xd6c <xTaskCreate+0x60>
     d62:	20 c0       	rjmp	.+64     	; 0xda4 <xTaskCreate+0x98>
     d64:	c3 01       	movw	r24, r6
     d66:	0e 94 79 03 	call	0x6f2	; 0x6f2 <vPortFree>
     d6a:	d1 c0       	rjmp	.+418    	; 0xf0e <xTaskCreate+0x202>
     d6c:	d6 01       	movw	r26, r12
     d6e:	8c 91       	ld	r24, X
     d70:	89 8f       	std	Y+25, r24	; 0x19
     d72:	8c 91       	ld	r24, X
     d74:	88 23       	and	r24, r24
     d76:	a1 f0       	breq	.+40     	; 0xda0 <xTaskCreate+0x94>
     d78:	ae 01       	movw	r20, r28
     d7a:	46 5e       	subi	r20, 0xE6	; 230
     d7c:	5f 4f       	sbci	r21, 0xFF	; 255
     d7e:	f6 01       	movw	r30, r12
     d80:	31 96       	adiw	r30, 0x01	; 1
     d82:	b8 e0       	ldi	r27, 0x08	; 8
     d84:	cb 0e       	add	r12, r27
     d86:	d1 1c       	adc	r13, r1
     d88:	cf 01       	movw	r24, r30
     d8a:	21 91       	ld	r18, Z+
     d8c:	da 01       	movw	r26, r20
     d8e:	2d 93       	st	X+, r18
     d90:	ad 01       	movw	r20, r26
     d92:	dc 01       	movw	r26, r24
     d94:	8c 91       	ld	r24, X
     d96:	88 23       	and	r24, r24
     d98:	19 f0       	breq	.+6      	; 0xda0 <xTaskCreate+0x94>
     d9a:	ec 15       	cp	r30, r12
     d9c:	fd 05       	cpc	r31, r13
     d9e:	a1 f7       	brne	.-24     	; 0xd88 <xTaskCreate+0x7c>
     da0:	18 a2       	std	Y+32, r1	; 0x20
     da2:	01 c0       	rjmp	.+2      	; 0xda6 <xTaskCreate+0x9a>
     da4:	19 8e       	std	Y+25, r1	; 0x19
     da6:	04 30       	cpi	r16, 0x04	; 4
     da8:	08 f0       	brcs	.+2      	; 0xdac <xTaskCreate+0xa0>
     daa:	03 e0       	ldi	r16, 0x03	; 3
     dac:	0e 8b       	std	Y+22, r16	; 0x16
     dae:	6e 01       	movw	r12, r28
     db0:	b2 e0       	ldi	r27, 0x02	; 2
     db2:	cb 0e       	add	r12, r27
     db4:	d1 1c       	adc	r13, r1
     db6:	c6 01       	movw	r24, r12
     db8:	0e 94 6f 01 	call	0x2de	; 0x2de <vListInitialiseItem>
     dbc:	ce 01       	movw	r24, r28
     dbe:	0c 96       	adiw	r24, 0x0c	; 12
     dc0:	0e 94 6f 01 	call	0x2de	; 0x2de <vListInitialiseItem>
     dc4:	d9 87       	std	Y+9, r29	; 0x09
     dc6:	c8 87       	std	Y+8, r28	; 0x08
     dc8:	84 e0       	ldi	r24, 0x04	; 4
     dca:	90 e0       	ldi	r25, 0x00	; 0
     dcc:	80 1b       	sub	r24, r16
     dce:	91 09       	sbc	r25, r1
     dd0:	9d 87       	std	Y+13, r25	; 0x0d
     dd2:	8c 87       	std	Y+12, r24	; 0x0c
     dd4:	db 8b       	std	Y+19, r29	; 0x13
     dd6:	ca 8b       	std	Y+18, r28	; 0x12
     dd8:	19 a2       	std	Y+33, r1	; 0x21
     dda:	1a a2       	std	Y+34, r1	; 0x22
     ddc:	1b a2       	std	Y+35, r1	; 0x23
     dde:	1c a2       	std	Y+36, r1	; 0x24
     de0:	1d a2       	std	Y+37, r1	; 0x25
     de2:	a2 01       	movw	r20, r4
     de4:	b4 01       	movw	r22, r8
     de6:	c5 01       	movw	r24, r10
     de8:	0e 94 ec 01 	call	0x3d8	; 0x3d8 <pxPortInitialiseStack>
     dec:	99 83       	std	Y+1, r25	; 0x01
     dee:	88 83       	st	Y, r24
     df0:	e1 14       	cp	r14, r1
     df2:	f1 04       	cpc	r15, r1
     df4:	19 f0       	breq	.+6      	; 0xdfc <xTaskCreate+0xf0>
     df6:	f7 01       	movw	r30, r14
     df8:	d1 83       	std	Z+1, r29	; 0x01
     dfa:	c0 83       	st	Z, r28
     dfc:	0f b6       	in	r0, 0x3f	; 63
     dfe:	f8 94       	cli
     e00:	0f 92       	push	r0
     e02:	80 91 a8 06 	lds	r24, 0x06A8	; 0x8006a8 <uxCurrentNumberOfTasks>
     e06:	8f 5f       	subi	r24, 0xFF	; 255
     e08:	80 93 a8 06 	sts	0x06A8, r24	; 0x8006a8 <uxCurrentNumberOfTasks>
     e0c:	80 91 ff 06 	lds	r24, 0x06FF	; 0x8006ff <pxCurrentTCB>
     e10:	90 91 00 07 	lds	r25, 0x0700	; 0x800700 <pxCurrentTCB+0x1>
     e14:	89 2b       	or	r24, r25
     e16:	d1 f5       	brne	.+116    	; 0xe8c <xTaskCreate+0x180>
     e18:	d0 93 00 07 	sts	0x0700, r29	; 0x800700 <pxCurrentTCB+0x1>
     e1c:	c0 93 ff 06 	sts	0x06FF, r28	; 0x8006ff <pxCurrentTCB>
     e20:	80 91 a8 06 	lds	r24, 0x06A8	; 0x8006a8 <uxCurrentNumberOfTasks>
     e24:	81 30       	cpi	r24, 0x01	; 1
     e26:	09 f0       	breq	.+2      	; 0xe2a <xTaskCreate+0x11e>
     e28:	41 c0       	rjmp	.+130    	; 0xeac <xTaskCreate+0x1a0>
     e2a:	8b ed       	ldi	r24, 0xDB	; 219
     e2c:	96 e0       	ldi	r25, 0x06	; 6
     e2e:	0e 94 61 01 	call	0x2c2	; 0x2c2 <vListInitialise>
     e32:	84 ee       	ldi	r24, 0xE4	; 228
     e34:	96 e0       	ldi	r25, 0x06	; 6
     e36:	0e 94 61 01 	call	0x2c2	; 0x2c2 <vListInitialise>
     e3a:	8d ee       	ldi	r24, 0xED	; 237
     e3c:	96 e0       	ldi	r25, 0x06	; 6
     e3e:	0e 94 61 01 	call	0x2c2	; 0x2c2 <vListInitialise>
     e42:	86 ef       	ldi	r24, 0xF6	; 246
     e44:	96 e0       	ldi	r25, 0x06	; 6
     e46:	0e 94 61 01 	call	0x2c2	; 0x2c2 <vListInitialise>
     e4a:	82 ed       	ldi	r24, 0xD2	; 210
     e4c:	96 e0       	ldi	r25, 0x06	; 6
     e4e:	0e 94 61 01 	call	0x2c2	; 0x2c2 <vListInitialise>
     e52:	89 ec       	ldi	r24, 0xC9	; 201
     e54:	96 e0       	ldi	r25, 0x06	; 6
     e56:	0e 94 61 01 	call	0x2c2	; 0x2c2 <vListInitialise>
     e5a:	8c eb       	ldi	r24, 0xBC	; 188
     e5c:	96 e0       	ldi	r25, 0x06	; 6
     e5e:	0e 94 61 01 	call	0x2c2	; 0x2c2 <vListInitialise>
     e62:	83 eb       	ldi	r24, 0xB3	; 179
     e64:	96 e0       	ldi	r25, 0x06	; 6
     e66:	0e 94 61 01 	call	0x2c2	; 0x2c2 <vListInitialise>
     e6a:	89 ea       	ldi	r24, 0xA9	; 169
     e6c:	96 e0       	ldi	r25, 0x06	; 6
     e6e:	0e 94 61 01 	call	0x2c2	; 0x2c2 <vListInitialise>
     e72:	82 ed       	ldi	r24, 0xD2	; 210
     e74:	96 e0       	ldi	r25, 0x06	; 6
     e76:	90 93 c8 06 	sts	0x06C8, r25	; 0x8006c8 <pxDelayedTaskList+0x1>
     e7a:	80 93 c7 06 	sts	0x06C7, r24	; 0x8006c7 <pxDelayedTaskList>
     e7e:	89 ec       	ldi	r24, 0xC9	; 201
     e80:	96 e0       	ldi	r25, 0x06	; 6
     e82:	90 93 c6 06 	sts	0x06C6, r25	; 0x8006c6 <pxOverflowDelayedTaskList+0x1>
     e86:	80 93 c5 06 	sts	0x06C5, r24	; 0x8006c5 <pxOverflowDelayedTaskList>
     e8a:	10 c0       	rjmp	.+32     	; 0xeac <xTaskCreate+0x1a0>
     e8c:	80 91 a4 06 	lds	r24, 0x06A4	; 0x8006a4 <xSchedulerRunning>
     e90:	81 11       	cpse	r24, r1
     e92:	0c c0       	rjmp	.+24     	; 0xeac <xTaskCreate+0x1a0>
     e94:	e0 91 ff 06 	lds	r30, 0x06FF	; 0x8006ff <pxCurrentTCB>
     e98:	f0 91 00 07 	lds	r31, 0x0700	; 0x800700 <pxCurrentTCB+0x1>
     e9c:	96 89       	ldd	r25, Z+22	; 0x16
     e9e:	8e 89       	ldd	r24, Y+22	; 0x16
     ea0:	89 17       	cp	r24, r25
     ea2:	20 f0       	brcs	.+8      	; 0xeac <xTaskCreate+0x1a0>
     ea4:	d0 93 00 07 	sts	0x0700, r29	; 0x800700 <pxCurrentTCB+0x1>
     ea8:	c0 93 ff 06 	sts	0x06FF, r28	; 0x8006ff <pxCurrentTCB>
     eac:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <uxTaskNumber>
     eb0:	8f 5f       	subi	r24, 0xFF	; 255
     eb2:	80 93 9f 06 	sts	0x069F, r24	; 0x80069f <uxTaskNumber>
     eb6:	8e 89       	ldd	r24, Y+22	; 0x16
     eb8:	90 91 a5 06 	lds	r25, 0x06A5	; 0x8006a5 <uxTopReadyPriority>
     ebc:	98 17       	cp	r25, r24
     ebe:	10 f4       	brcc	.+4      	; 0xec4 <xTaskCreate+0x1b8>
     ec0:	80 93 a5 06 	sts	0x06A5, r24	; 0x8006a5 <uxTopReadyPriority>
     ec4:	90 e0       	ldi	r25, 0x00	; 0
     ec6:	9c 01       	movw	r18, r24
     ec8:	22 0f       	add	r18, r18
     eca:	33 1f       	adc	r19, r19
     ecc:	22 0f       	add	r18, r18
     ece:	33 1f       	adc	r19, r19
     ed0:	22 0f       	add	r18, r18
     ed2:	33 1f       	adc	r19, r19
     ed4:	82 0f       	add	r24, r18
     ed6:	93 1f       	adc	r25, r19
     ed8:	b6 01       	movw	r22, r12
     eda:	85 52       	subi	r24, 0x25	; 37
     edc:	99 4f       	sbci	r25, 0xF9	; 249
     ede:	0e 94 73 01 	call	0x2e6	; 0x2e6 <vListInsertEnd>
     ee2:	0f 90       	pop	r0
     ee4:	0f be       	out	0x3f, r0	; 63
     ee6:	80 91 a4 06 	lds	r24, 0x06A4	; 0x8006a4 <xSchedulerRunning>
     eea:	88 23       	and	r24, r24
     eec:	61 f0       	breq	.+24     	; 0xf06 <xTaskCreate+0x1fa>
     eee:	e0 91 ff 06 	lds	r30, 0x06FF	; 0x8006ff <pxCurrentTCB>
     ef2:	f0 91 00 07 	lds	r31, 0x0700	; 0x800700 <pxCurrentTCB+0x1>
     ef6:	96 89       	ldd	r25, Z+22	; 0x16
     ef8:	8e 89       	ldd	r24, Y+22	; 0x16
     efa:	98 17       	cp	r25, r24
     efc:	30 f4       	brcc	.+12     	; 0xf0a <xTaskCreate+0x1fe>
     efe:	0e 94 8d 02 	call	0x51a	; 0x51a <vPortYield>
     f02:	81 e0       	ldi	r24, 0x01	; 1
     f04:	05 c0       	rjmp	.+10     	; 0xf10 <xTaskCreate+0x204>
     f06:	81 e0       	ldi	r24, 0x01	; 1
     f08:	03 c0       	rjmp	.+6      	; 0xf10 <xTaskCreate+0x204>
     f0a:	81 e0       	ldi	r24, 0x01	; 1
     f0c:	01 c0       	rjmp	.+2      	; 0xf10 <xTaskCreate+0x204>
     f0e:	8f ef       	ldi	r24, 0xFF	; 255
     f10:	df 91       	pop	r29
     f12:	cf 91       	pop	r28
     f14:	0f 91       	pop	r16
     f16:	ff 90       	pop	r15
     f18:	ef 90       	pop	r14
     f1a:	df 90       	pop	r13
     f1c:	cf 90       	pop	r12
     f1e:	bf 90       	pop	r11
     f20:	af 90       	pop	r10
     f22:	9f 90       	pop	r9
     f24:	8f 90       	pop	r8
     f26:	7f 90       	pop	r7
     f28:	6f 90       	pop	r6
     f2a:	5f 90       	pop	r5
     f2c:	4f 90       	pop	r4
     f2e:	08 95       	ret

00000f30 <vTaskDelete>:
     f30:	0f 93       	push	r16
     f32:	1f 93       	push	r17
     f34:	cf 93       	push	r28
     f36:	df 93       	push	r29
     f38:	ec 01       	movw	r28, r24
     f3a:	0f b6       	in	r0, 0x3f	; 63
     f3c:	f8 94       	cli
     f3e:	0f 92       	push	r0
     f40:	89 2b       	or	r24, r25
     f42:	21 f4       	brne	.+8      	; 0xf4c <vTaskDelete+0x1c>
     f44:	c0 91 ff 06 	lds	r28, 0x06FF	; 0x8006ff <pxCurrentTCB>
     f48:	d0 91 00 07 	lds	r29, 0x0700	; 0x800700 <pxCurrentTCB+0x1>
     f4c:	8e 01       	movw	r16, r28
     f4e:	0e 5f       	subi	r16, 0xFE	; 254
     f50:	1f 4f       	sbci	r17, 0xFF	; 255
     f52:	c8 01       	movw	r24, r16
     f54:	0e 94 c5 01 	call	0x38a	; 0x38a <uxListRemove>
     f58:	8c 89       	ldd	r24, Y+20	; 0x14
     f5a:	9d 89       	ldd	r25, Y+21	; 0x15
     f5c:	89 2b       	or	r24, r25
     f5e:	21 f0       	breq	.+8      	; 0xf68 <vTaskDelete+0x38>
     f60:	ce 01       	movw	r24, r28
     f62:	0c 96       	adiw	r24, 0x0c	; 12
     f64:	0e 94 c5 01 	call	0x38a	; 0x38a <uxListRemove>
     f68:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <uxTaskNumber>
     f6c:	8f 5f       	subi	r24, 0xFF	; 255
     f6e:	80 93 9f 06 	sts	0x069F, r24	; 0x80069f <uxTaskNumber>
     f72:	80 91 ff 06 	lds	r24, 0x06FF	; 0x8006ff <pxCurrentTCB>
     f76:	90 91 00 07 	lds	r25, 0x0700	; 0x800700 <pxCurrentTCB+0x1>
     f7a:	c8 17       	cp	r28, r24
     f7c:	d9 07       	cpc	r29, r25
     f7e:	59 f4       	brne	.+22     	; 0xf96 <vTaskDelete+0x66>
     f80:	b8 01       	movw	r22, r16
     f82:	83 eb       	ldi	r24, 0xB3	; 179
     f84:	96 e0       	ldi	r25, 0x06	; 6
     f86:	0e 94 73 01 	call	0x2e6	; 0x2e6 <vListInsertEnd>
     f8a:	80 91 b2 06 	lds	r24, 0x06B2	; 0x8006b2 <uxDeletedTasksWaitingCleanUp>
     f8e:	8f 5f       	subi	r24, 0xFF	; 255
     f90:	80 93 b2 06 	sts	0x06B2, r24	; 0x8006b2 <uxDeletedTasksWaitingCleanUp>
     f94:	0e c0       	rjmp	.+28     	; 0xfb2 <vTaskDelete+0x82>
     f96:	80 91 a8 06 	lds	r24, 0x06A8	; 0x8006a8 <uxCurrentNumberOfTasks>
     f9a:	81 50       	subi	r24, 0x01	; 1
     f9c:	80 93 a8 06 	sts	0x06A8, r24	; 0x8006a8 <uxCurrentNumberOfTasks>
     fa0:	8f 89       	ldd	r24, Y+23	; 0x17
     fa2:	98 8d       	ldd	r25, Y+24	; 0x18
     fa4:	0e 94 79 03 	call	0x6f2	; 0x6f2 <vPortFree>
     fa8:	ce 01       	movw	r24, r28
     faa:	0e 94 79 03 	call	0x6f2	; 0x6f2 <vPortFree>
     fae:	0e 94 d8 05 	call	0xbb0	; 0xbb0 <prvResetNextTaskUnblockTime>
     fb2:	0f 90       	pop	r0
     fb4:	0f be       	out	0x3f, r0	; 63
     fb6:	80 91 a4 06 	lds	r24, 0x06A4	; 0x8006a4 <xSchedulerRunning>
     fba:	88 23       	and	r24, r24
     fbc:	49 f0       	breq	.+18     	; 0xfd0 <vTaskDelete+0xa0>
     fbe:	80 91 ff 06 	lds	r24, 0x06FF	; 0x8006ff <pxCurrentTCB>
     fc2:	90 91 00 07 	lds	r25, 0x0700	; 0x800700 <pxCurrentTCB+0x1>
     fc6:	c8 17       	cp	r28, r24
     fc8:	d9 07       	cpc	r29, r25
     fca:	11 f4       	brne	.+4      	; 0xfd0 <vTaskDelete+0xa0>
     fcc:	0e 94 8d 02 	call	0x51a	; 0x51a <vPortYield>
     fd0:	df 91       	pop	r29
     fd2:	cf 91       	pop	r28
     fd4:	1f 91       	pop	r17
     fd6:	0f 91       	pop	r16
     fd8:	08 95       	ret

00000fda <vTaskStartScheduler>:
     fda:	ef 92       	push	r14
     fdc:	ff 92       	push	r15
     fde:	0f 93       	push	r16
     fe0:	0f 2e       	mov	r0, r31
     fe2:	fb e9       	ldi	r31, 0x9B	; 155
     fe4:	ef 2e       	mov	r14, r31
     fe6:	f6 e0       	ldi	r31, 0x06	; 6
     fe8:	ff 2e       	mov	r15, r31
     fea:	f0 2d       	mov	r31, r0
     fec:	00 e0       	ldi	r16, 0x00	; 0
     fee:	20 e0       	ldi	r18, 0x00	; 0
     ff0:	30 e0       	ldi	r19, 0x00	; 0
     ff2:	45 e5       	ldi	r20, 0x55	; 85
     ff4:	50 e0       	ldi	r21, 0x00	; 0
     ff6:	62 e6       	ldi	r22, 0x62	; 98
     ff8:	70 e0       	ldi	r23, 0x00	; 0
     ffa:	8c e4       	ldi	r24, 0x4C	; 76
     ffc:	96 e0       	ldi	r25, 0x06	; 6
     ffe:	0e 94 86 06 	call	0xd0c	; 0xd0c <xTaskCreate>
    1002:	81 30       	cpi	r24, 0x01	; 1
    1004:	81 f4       	brne	.+32     	; 0x1026 <vTaskStartScheduler+0x4c>
    1006:	f8 94       	cli
    1008:	8f ef       	ldi	r24, 0xFF	; 255
    100a:	9f ef       	ldi	r25, 0xFF	; 255
    100c:	90 93 9e 06 	sts	0x069E, r25	; 0x80069e <xNextTaskUnblockTime+0x1>
    1010:	80 93 9d 06 	sts	0x069D, r24	; 0x80069d <xNextTaskUnblockTime>
    1014:	81 e0       	ldi	r24, 0x01	; 1
    1016:	80 93 a4 06 	sts	0x06A4, r24	; 0x8006a4 <xSchedulerRunning>
    101a:	10 92 a7 06 	sts	0x06A7, r1	; 0x8006a7 <xTickCount+0x1>
    101e:	10 92 a6 06 	sts	0x06A6, r1	; 0x8006a6 <xTickCount>
    1022:	0e 94 58 02 	call	0x4b0	; 0x4b0 <xPortStartScheduler>
    1026:	0f 91       	pop	r16
    1028:	ff 90       	pop	r15
    102a:	ef 90       	pop	r14
    102c:	08 95       	ret

0000102e <vTaskSuspendAll>:
    102e:	80 91 9a 06 	lds	r24, 0x069A	; 0x80069a <uxSchedulerSuspended>
    1032:	8f 5f       	subi	r24, 0xFF	; 255
    1034:	80 93 9a 06 	sts	0x069A, r24	; 0x80069a <uxSchedulerSuspended>
    1038:	08 95       	ret

0000103a <xTaskGetTickCount>:
    103a:	0f b6       	in	r0, 0x3f	; 63
    103c:	f8 94       	cli
    103e:	0f 92       	push	r0
    1040:	80 91 a6 06 	lds	r24, 0x06A6	; 0x8006a6 <xTickCount>
    1044:	90 91 a7 06 	lds	r25, 0x06A7	; 0x8006a7 <xTickCount+0x1>
    1048:	0f 90       	pop	r0
    104a:	0f be       	out	0x3f, r0	; 63
    104c:	08 95       	ret

0000104e <xTaskIncrementTick>:
    104e:	cf 92       	push	r12
    1050:	df 92       	push	r13
    1052:	ef 92       	push	r14
    1054:	ff 92       	push	r15
    1056:	0f 93       	push	r16
    1058:	1f 93       	push	r17
    105a:	cf 93       	push	r28
    105c:	df 93       	push	r29
    105e:	80 91 9a 06 	lds	r24, 0x069A	; 0x80069a <uxSchedulerSuspended>
    1062:	81 11       	cpse	r24, r1
    1064:	9f c0       	rjmp	.+318    	; 0x11a4 <xTaskIncrementTick+0x156>
    1066:	e0 90 a6 06 	lds	r14, 0x06A6	; 0x8006a6 <xTickCount>
    106a:	f0 90 a7 06 	lds	r15, 0x06A7	; 0x8006a7 <xTickCount+0x1>
    106e:	8f ef       	ldi	r24, 0xFF	; 255
    1070:	e8 1a       	sub	r14, r24
    1072:	f8 0a       	sbc	r15, r24
    1074:	f0 92 a7 06 	sts	0x06A7, r15	; 0x8006a7 <xTickCount+0x1>
    1078:	e0 92 a6 06 	sts	0x06A6, r14	; 0x8006a6 <xTickCount>
    107c:	e1 14       	cp	r14, r1
    107e:	f1 04       	cpc	r15, r1
    1080:	b9 f4       	brne	.+46     	; 0x10b0 <xTaskIncrementTick+0x62>
    1082:	80 91 c7 06 	lds	r24, 0x06C7	; 0x8006c7 <pxDelayedTaskList>
    1086:	90 91 c8 06 	lds	r25, 0x06C8	; 0x8006c8 <pxDelayedTaskList+0x1>
    108a:	20 91 c5 06 	lds	r18, 0x06C5	; 0x8006c5 <pxOverflowDelayedTaskList>
    108e:	30 91 c6 06 	lds	r19, 0x06C6	; 0x8006c6 <pxOverflowDelayedTaskList+0x1>
    1092:	30 93 c8 06 	sts	0x06C8, r19	; 0x8006c8 <pxDelayedTaskList+0x1>
    1096:	20 93 c7 06 	sts	0x06C7, r18	; 0x8006c7 <pxDelayedTaskList>
    109a:	90 93 c6 06 	sts	0x06C6, r25	; 0x8006c6 <pxOverflowDelayedTaskList+0x1>
    109e:	80 93 c5 06 	sts	0x06C5, r24	; 0x8006c5 <pxOverflowDelayedTaskList>
    10a2:	80 91 a0 06 	lds	r24, 0x06A0	; 0x8006a0 <xNumOfOverflows>
    10a6:	8f 5f       	subi	r24, 0xFF	; 255
    10a8:	80 93 a0 06 	sts	0x06A0, r24	; 0x8006a0 <xNumOfOverflows>
    10ac:	0e 94 d8 05 	call	0xbb0	; 0xbb0 <prvResetNextTaskUnblockTime>
    10b0:	80 91 9d 06 	lds	r24, 0x069D	; 0x80069d <xNextTaskUnblockTime>
    10b4:	90 91 9e 06 	lds	r25, 0x069E	; 0x80069e <xNextTaskUnblockTime+0x1>
    10b8:	e8 16       	cp	r14, r24
    10ba:	f9 06       	cpc	r15, r25
    10bc:	10 f4       	brcc	.+4      	; 0x10c2 <xTaskIncrementTick+0x74>
    10be:	d1 2c       	mov	r13, r1
    10c0:	53 c0       	rjmp	.+166    	; 0x1168 <xTaskIncrementTick+0x11a>
    10c2:	d1 2c       	mov	r13, r1
    10c4:	cc 24       	eor	r12, r12
    10c6:	c3 94       	inc	r12
    10c8:	e0 91 c7 06 	lds	r30, 0x06C7	; 0x8006c7 <pxDelayedTaskList>
    10cc:	f0 91 c8 06 	lds	r31, 0x06C8	; 0x8006c8 <pxDelayedTaskList+0x1>
    10d0:	80 81       	ld	r24, Z
    10d2:	81 11       	cpse	r24, r1
    10d4:	07 c0       	rjmp	.+14     	; 0x10e4 <xTaskIncrementTick+0x96>
    10d6:	8f ef       	ldi	r24, 0xFF	; 255
    10d8:	9f ef       	ldi	r25, 0xFF	; 255
    10da:	90 93 9e 06 	sts	0x069E, r25	; 0x80069e <xNextTaskUnblockTime+0x1>
    10de:	80 93 9d 06 	sts	0x069D, r24	; 0x80069d <xNextTaskUnblockTime>
    10e2:	42 c0       	rjmp	.+132    	; 0x1168 <xTaskIncrementTick+0x11a>
    10e4:	e0 91 c7 06 	lds	r30, 0x06C7	; 0x8006c7 <pxDelayedTaskList>
    10e8:	f0 91 c8 06 	lds	r31, 0x06C8	; 0x8006c8 <pxDelayedTaskList+0x1>
    10ec:	05 80       	ldd	r0, Z+5	; 0x05
    10ee:	f6 81       	ldd	r31, Z+6	; 0x06
    10f0:	e0 2d       	mov	r30, r0
    10f2:	c6 81       	ldd	r28, Z+6	; 0x06
    10f4:	d7 81       	ldd	r29, Z+7	; 0x07
    10f6:	8a 81       	ldd	r24, Y+2	; 0x02
    10f8:	9b 81       	ldd	r25, Y+3	; 0x03
    10fa:	e8 16       	cp	r14, r24
    10fc:	f9 06       	cpc	r15, r25
    10fe:	28 f4       	brcc	.+10     	; 0x110a <xTaskIncrementTick+0xbc>
    1100:	90 93 9e 06 	sts	0x069E, r25	; 0x80069e <xNextTaskUnblockTime+0x1>
    1104:	80 93 9d 06 	sts	0x069D, r24	; 0x80069d <xNextTaskUnblockTime>
    1108:	2f c0       	rjmp	.+94     	; 0x1168 <xTaskIncrementTick+0x11a>
    110a:	8e 01       	movw	r16, r28
    110c:	0e 5f       	subi	r16, 0xFE	; 254
    110e:	1f 4f       	sbci	r17, 0xFF	; 255
    1110:	c8 01       	movw	r24, r16
    1112:	0e 94 c5 01 	call	0x38a	; 0x38a <uxListRemove>
    1116:	8c 89       	ldd	r24, Y+20	; 0x14
    1118:	9d 89       	ldd	r25, Y+21	; 0x15
    111a:	89 2b       	or	r24, r25
    111c:	21 f0       	breq	.+8      	; 0x1126 <xTaskIncrementTick+0xd8>
    111e:	ce 01       	movw	r24, r28
    1120:	0c 96       	adiw	r24, 0x0c	; 12
    1122:	0e 94 c5 01 	call	0x38a	; 0x38a <uxListRemove>
    1126:	8e 89       	ldd	r24, Y+22	; 0x16
    1128:	90 91 a5 06 	lds	r25, 0x06A5	; 0x8006a5 <uxTopReadyPriority>
    112c:	98 17       	cp	r25, r24
    112e:	10 f4       	brcc	.+4      	; 0x1134 <xTaskIncrementTick+0xe6>
    1130:	80 93 a5 06 	sts	0x06A5, r24	; 0x8006a5 <uxTopReadyPriority>
    1134:	90 e0       	ldi	r25, 0x00	; 0
    1136:	9c 01       	movw	r18, r24
    1138:	22 0f       	add	r18, r18
    113a:	33 1f       	adc	r19, r19
    113c:	22 0f       	add	r18, r18
    113e:	33 1f       	adc	r19, r19
    1140:	22 0f       	add	r18, r18
    1142:	33 1f       	adc	r19, r19
    1144:	82 0f       	add	r24, r18
    1146:	93 1f       	adc	r25, r19
    1148:	b8 01       	movw	r22, r16
    114a:	85 52       	subi	r24, 0x25	; 37
    114c:	99 4f       	sbci	r25, 0xF9	; 249
    114e:	0e 94 73 01 	call	0x2e6	; 0x2e6 <vListInsertEnd>
    1152:	e0 91 ff 06 	lds	r30, 0x06FF	; 0x8006ff <pxCurrentTCB>
    1156:	f0 91 00 07 	lds	r31, 0x0700	; 0x800700 <pxCurrentTCB+0x1>
    115a:	9e 89       	ldd	r25, Y+22	; 0x16
    115c:	86 89       	ldd	r24, Z+22	; 0x16
    115e:	98 17       	cp	r25, r24
    1160:	08 f4       	brcc	.+2      	; 0x1164 <xTaskIncrementTick+0x116>
    1162:	b2 cf       	rjmp	.-156    	; 0x10c8 <xTaskIncrementTick+0x7a>
    1164:	dc 2c       	mov	r13, r12
    1166:	b0 cf       	rjmp	.-160    	; 0x10c8 <xTaskIncrementTick+0x7a>
    1168:	e0 91 ff 06 	lds	r30, 0x06FF	; 0x8006ff <pxCurrentTCB>
    116c:	f0 91 00 07 	lds	r31, 0x0700	; 0x800700 <pxCurrentTCB+0x1>
    1170:	86 89       	ldd	r24, Z+22	; 0x16
    1172:	90 e0       	ldi	r25, 0x00	; 0
    1174:	fc 01       	movw	r30, r24
    1176:	ee 0f       	add	r30, r30
    1178:	ff 1f       	adc	r31, r31
    117a:	ee 0f       	add	r30, r30
    117c:	ff 1f       	adc	r31, r31
    117e:	ee 0f       	add	r30, r30
    1180:	ff 1f       	adc	r31, r31
    1182:	8e 0f       	add	r24, r30
    1184:	9f 1f       	adc	r25, r31
    1186:	fc 01       	movw	r30, r24
    1188:	e5 52       	subi	r30, 0x25	; 37
    118a:	f9 4f       	sbci	r31, 0xF9	; 249
    118c:	80 81       	ld	r24, Z
    118e:	82 30       	cpi	r24, 0x02	; 2
    1190:	10 f0       	brcs	.+4      	; 0x1196 <xTaskIncrementTick+0x148>
    1192:	dd 24       	eor	r13, r13
    1194:	d3 94       	inc	r13
    1196:	80 91 a1 06 	lds	r24, 0x06A1	; 0x8006a1 <xYieldPending>
    119a:	88 23       	and	r24, r24
    119c:	69 f0       	breq	.+26     	; 0x11b8 <xTaskIncrementTick+0x16a>
    119e:	dd 24       	eor	r13, r13
    11a0:	d3 94       	inc	r13
    11a2:	0a c0       	rjmp	.+20     	; 0x11b8 <xTaskIncrementTick+0x16a>
    11a4:	80 91 a2 06 	lds	r24, 0x06A2	; 0x8006a2 <xPendedTicks>
    11a8:	90 91 a3 06 	lds	r25, 0x06A3	; 0x8006a3 <xPendedTicks+0x1>
    11ac:	01 96       	adiw	r24, 0x01	; 1
    11ae:	90 93 a3 06 	sts	0x06A3, r25	; 0x8006a3 <xPendedTicks+0x1>
    11b2:	80 93 a2 06 	sts	0x06A2, r24	; 0x8006a2 <xPendedTicks>
    11b6:	d1 2c       	mov	r13, r1
    11b8:	8d 2d       	mov	r24, r13
    11ba:	df 91       	pop	r29
    11bc:	cf 91       	pop	r28
    11be:	1f 91       	pop	r17
    11c0:	0f 91       	pop	r16
    11c2:	ff 90       	pop	r15
    11c4:	ef 90       	pop	r14
    11c6:	df 90       	pop	r13
    11c8:	cf 90       	pop	r12
    11ca:	08 95       	ret

000011cc <xTaskResumeAll>:
    11cc:	df 92       	push	r13
    11ce:	ef 92       	push	r14
    11d0:	ff 92       	push	r15
    11d2:	0f 93       	push	r16
    11d4:	1f 93       	push	r17
    11d6:	cf 93       	push	r28
    11d8:	df 93       	push	r29
    11da:	0f b6       	in	r0, 0x3f	; 63
    11dc:	f8 94       	cli
    11de:	0f 92       	push	r0
    11e0:	80 91 9a 06 	lds	r24, 0x069A	; 0x80069a <uxSchedulerSuspended>
    11e4:	81 50       	subi	r24, 0x01	; 1
    11e6:	80 93 9a 06 	sts	0x069A, r24	; 0x80069a <uxSchedulerSuspended>
    11ea:	80 91 9a 06 	lds	r24, 0x069A	; 0x80069a <uxSchedulerSuspended>
    11ee:	81 11       	cpse	r24, r1
    11f0:	63 c0       	rjmp	.+198    	; 0x12b8 <xTaskResumeAll+0xec>
    11f2:	80 91 a8 06 	lds	r24, 0x06A8	; 0x8006a8 <uxCurrentNumberOfTasks>
    11f6:	81 11       	cpse	r24, r1
    11f8:	33 c0       	rjmp	.+102    	; 0x1260 <xTaskResumeAll+0x94>
    11fa:	61 c0       	rjmp	.+194    	; 0x12be <xTaskResumeAll+0xf2>
    11fc:	d7 01       	movw	r26, r14
    11fe:	15 96       	adiw	r26, 0x05	; 5
    1200:	ed 91       	ld	r30, X+
    1202:	fc 91       	ld	r31, X
    1204:	16 97       	sbiw	r26, 0x06	; 6
    1206:	c6 81       	ldd	r28, Z+6	; 0x06
    1208:	d7 81       	ldd	r29, Z+7	; 0x07
    120a:	ce 01       	movw	r24, r28
    120c:	0c 96       	adiw	r24, 0x0c	; 12
    120e:	0e 94 c5 01 	call	0x38a	; 0x38a <uxListRemove>
    1212:	8e 01       	movw	r16, r28
    1214:	0e 5f       	subi	r16, 0xFE	; 254
    1216:	1f 4f       	sbci	r17, 0xFF	; 255
    1218:	c8 01       	movw	r24, r16
    121a:	0e 94 c5 01 	call	0x38a	; 0x38a <uxListRemove>
    121e:	8e 89       	ldd	r24, Y+22	; 0x16
    1220:	90 91 a5 06 	lds	r25, 0x06A5	; 0x8006a5 <uxTopReadyPriority>
    1224:	98 17       	cp	r25, r24
    1226:	10 f4       	brcc	.+4      	; 0x122c <xTaskResumeAll+0x60>
    1228:	80 93 a5 06 	sts	0x06A5, r24	; 0x8006a5 <uxTopReadyPriority>
    122c:	90 e0       	ldi	r25, 0x00	; 0
    122e:	9c 01       	movw	r18, r24
    1230:	22 0f       	add	r18, r18
    1232:	33 1f       	adc	r19, r19
    1234:	22 0f       	add	r18, r18
    1236:	33 1f       	adc	r19, r19
    1238:	22 0f       	add	r18, r18
    123a:	33 1f       	adc	r19, r19
    123c:	82 0f       	add	r24, r18
    123e:	93 1f       	adc	r25, r19
    1240:	b8 01       	movw	r22, r16
    1242:	85 52       	subi	r24, 0x25	; 37
    1244:	99 4f       	sbci	r25, 0xF9	; 249
    1246:	0e 94 73 01 	call	0x2e6	; 0x2e6 <vListInsertEnd>
    124a:	e0 91 ff 06 	lds	r30, 0x06FF	; 0x8006ff <pxCurrentTCB>
    124e:	f0 91 00 07 	lds	r31, 0x0700	; 0x800700 <pxCurrentTCB+0x1>
    1252:	9e 89       	ldd	r25, Y+22	; 0x16
    1254:	86 89       	ldd	r24, Z+22	; 0x16
    1256:	98 17       	cp	r25, r24
    1258:	68 f0       	brcs	.+26     	; 0x1274 <xTaskResumeAll+0xa8>
    125a:	d0 92 a1 06 	sts	0x06A1, r13	; 0x8006a1 <xYieldPending>
    125e:	0a c0       	rjmp	.+20     	; 0x1274 <xTaskResumeAll+0xa8>
    1260:	c0 e0       	ldi	r28, 0x00	; 0
    1262:	d0 e0       	ldi	r29, 0x00	; 0
    1264:	0f 2e       	mov	r0, r31
    1266:	fc eb       	ldi	r31, 0xBC	; 188
    1268:	ef 2e       	mov	r14, r31
    126a:	f6 e0       	ldi	r31, 0x06	; 6
    126c:	ff 2e       	mov	r15, r31
    126e:	f0 2d       	mov	r31, r0
    1270:	dd 24       	eor	r13, r13
    1272:	d3 94       	inc	r13
    1274:	f7 01       	movw	r30, r14
    1276:	80 81       	ld	r24, Z
    1278:	81 11       	cpse	r24, r1
    127a:	c0 cf       	rjmp	.-128    	; 0x11fc <xTaskResumeAll+0x30>
    127c:	cd 2b       	or	r28, r29
    127e:	11 f0       	breq	.+4      	; 0x1284 <xTaskResumeAll+0xb8>
    1280:	0e 94 d8 05 	call	0xbb0	; 0xbb0 <prvResetNextTaskUnblockTime>
    1284:	c0 91 a2 06 	lds	r28, 0x06A2	; 0x8006a2 <xPendedTicks>
    1288:	d0 91 a3 06 	lds	r29, 0x06A3	; 0x8006a3 <xPendedTicks+0x1>
    128c:	20 97       	sbiw	r28, 0x00	; 0
    128e:	61 f0       	breq	.+24     	; 0x12a8 <xTaskResumeAll+0xdc>
    1290:	11 e0       	ldi	r17, 0x01	; 1
    1292:	0e 94 27 08 	call	0x104e	; 0x104e <xTaskIncrementTick>
    1296:	81 11       	cpse	r24, r1
    1298:	10 93 a1 06 	sts	0x06A1, r17	; 0x8006a1 <xYieldPending>
    129c:	21 97       	sbiw	r28, 0x01	; 1
    129e:	c9 f7       	brne	.-14     	; 0x1292 <xTaskResumeAll+0xc6>
    12a0:	10 92 a3 06 	sts	0x06A3, r1	; 0x8006a3 <xPendedTicks+0x1>
    12a4:	10 92 a2 06 	sts	0x06A2, r1	; 0x8006a2 <xPendedTicks>
    12a8:	80 91 a1 06 	lds	r24, 0x06A1	; 0x8006a1 <xYieldPending>
    12ac:	88 23       	and	r24, r24
    12ae:	31 f0       	breq	.+12     	; 0x12bc <xTaskResumeAll+0xf0>
    12b0:	0e 94 8d 02 	call	0x51a	; 0x51a <vPortYield>
    12b4:	81 e0       	ldi	r24, 0x01	; 1
    12b6:	03 c0       	rjmp	.+6      	; 0x12be <xTaskResumeAll+0xf2>
    12b8:	80 e0       	ldi	r24, 0x00	; 0
    12ba:	01 c0       	rjmp	.+2      	; 0x12be <xTaskResumeAll+0xf2>
    12bc:	80 e0       	ldi	r24, 0x00	; 0
    12be:	0f 90       	pop	r0
    12c0:	0f be       	out	0x3f, r0	; 63
    12c2:	df 91       	pop	r29
    12c4:	cf 91       	pop	r28
    12c6:	1f 91       	pop	r17
    12c8:	0f 91       	pop	r16
    12ca:	ff 90       	pop	r15
    12cc:	ef 90       	pop	r14
    12ce:	df 90       	pop	r13
    12d0:	08 95       	ret

000012d2 <vTaskDelayUntil>:
    12d2:	0f 93       	push	r16
    12d4:	1f 93       	push	r17
    12d6:	cf 93       	push	r28
    12d8:	df 93       	push	r29
    12da:	8c 01       	movw	r16, r24
    12dc:	eb 01       	movw	r28, r22
    12de:	0e 94 17 08 	call	0x102e	; 0x102e <vTaskSuspendAll>
    12e2:	40 91 a6 06 	lds	r20, 0x06A6	; 0x8006a6 <xTickCount>
    12e6:	50 91 a7 06 	lds	r21, 0x06A7	; 0x8006a7 <xTickCount+0x1>
    12ea:	f8 01       	movw	r30, r16
    12ec:	20 81       	ld	r18, Z
    12ee:	31 81       	ldd	r19, Z+1	; 0x01
    12f0:	c9 01       	movw	r24, r18
    12f2:	8c 0f       	add	r24, r28
    12f4:	9d 1f       	adc	r25, r29
    12f6:	42 17       	cp	r20, r18
    12f8:	53 07       	cpc	r21, r19
    12fa:	48 f4       	brcc	.+18     	; 0x130e <vTaskDelayUntil+0x3c>
    12fc:	82 17       	cp	r24, r18
    12fe:	93 07       	cpc	r25, r19
    1300:	e8 f4       	brcc	.+58     	; 0x133c <vTaskDelayUntil+0x6a>
    1302:	91 83       	std	Z+1, r25	; 0x01
    1304:	80 83       	st	Z, r24
    1306:	48 17       	cp	r20, r24
    1308:	59 07       	cpc	r21, r25
    130a:	68 f4       	brcc	.+26     	; 0x1326 <vTaskDelayUntil+0x54>
    130c:	07 c0       	rjmp	.+14     	; 0x131c <vTaskDelayUntil+0x4a>
    130e:	82 17       	cp	r24, r18
    1310:	93 07       	cpc	r25, r19
    1312:	80 f0       	brcs	.+32     	; 0x1334 <vTaskDelayUntil+0x62>
    1314:	48 17       	cp	r20, r24
    1316:	59 07       	cpc	r21, r25
    1318:	68 f0       	brcs	.+26     	; 0x1334 <vTaskDelayUntil+0x62>
    131a:	10 c0       	rjmp	.+32     	; 0x133c <vTaskDelayUntil+0x6a>
    131c:	60 e0       	ldi	r22, 0x00	; 0
    131e:	84 1b       	sub	r24, r20
    1320:	95 0b       	sbc	r25, r21
    1322:	0e 94 f4 05 	call	0xbe8	; 0xbe8 <prvAddCurrentTaskToDelayedList>
    1326:	0e 94 e6 08 	call	0x11cc	; 0x11cc <xTaskResumeAll>
    132a:	81 11       	cpse	r24, r1
    132c:	0b c0       	rjmp	.+22     	; 0x1344 <vTaskDelayUntil+0x72>
    132e:	0e 94 8d 02 	call	0x51a	; 0x51a <vPortYield>
    1332:	08 c0       	rjmp	.+16     	; 0x1344 <vTaskDelayUntil+0x72>
    1334:	f8 01       	movw	r30, r16
    1336:	91 83       	std	Z+1, r25	; 0x01
    1338:	80 83       	st	Z, r24
    133a:	f0 cf       	rjmp	.-32     	; 0x131c <vTaskDelayUntil+0x4a>
    133c:	f8 01       	movw	r30, r16
    133e:	91 83       	std	Z+1, r25	; 0x01
    1340:	80 83       	st	Z, r24
    1342:	f1 cf       	rjmp	.-30     	; 0x1326 <vTaskDelayUntil+0x54>
    1344:	df 91       	pop	r29
    1346:	cf 91       	pop	r28
    1348:	1f 91       	pop	r17
    134a:	0f 91       	pop	r16
    134c:	08 95       	ret

0000134e <vTaskSwitchContext>:
    134e:	80 91 9a 06 	lds	r24, 0x069A	; 0x80069a <uxSchedulerSuspended>
    1352:	88 23       	and	r24, r24
    1354:	21 f0       	breq	.+8      	; 0x135e <vTaskSwitchContext+0x10>
    1356:	81 e0       	ldi	r24, 0x01	; 1
    1358:	80 93 a1 06 	sts	0x06A1, r24	; 0x8006a1 <xYieldPending>
    135c:	08 95       	ret
    135e:	10 92 a1 06 	sts	0x06A1, r1	; 0x8006a1 <xYieldPending>
    1362:	20 91 a5 06 	lds	r18, 0x06A5	; 0x8006a5 <uxTopReadyPriority>
    1366:	82 2f       	mov	r24, r18
    1368:	90 e0       	ldi	r25, 0x00	; 0
    136a:	fc 01       	movw	r30, r24
    136c:	ee 0f       	add	r30, r30
    136e:	ff 1f       	adc	r31, r31
    1370:	ee 0f       	add	r30, r30
    1372:	ff 1f       	adc	r31, r31
    1374:	ee 0f       	add	r30, r30
    1376:	ff 1f       	adc	r31, r31
    1378:	e8 0f       	add	r30, r24
    137a:	f9 1f       	adc	r31, r25
    137c:	e5 52       	subi	r30, 0x25	; 37
    137e:	f9 4f       	sbci	r31, 0xF9	; 249
    1380:	30 81       	ld	r19, Z
    1382:	31 11       	cpse	r19, r1
    1384:	11 c0       	rjmp	.+34     	; 0x13a8 <vTaskSwitchContext+0x5a>
    1386:	21 50       	subi	r18, 0x01	; 1
    1388:	82 2f       	mov	r24, r18
    138a:	90 e0       	ldi	r25, 0x00	; 0
    138c:	fc 01       	movw	r30, r24
    138e:	ee 0f       	add	r30, r30
    1390:	ff 1f       	adc	r31, r31
    1392:	ee 0f       	add	r30, r30
    1394:	ff 1f       	adc	r31, r31
    1396:	ee 0f       	add	r30, r30
    1398:	ff 1f       	adc	r31, r31
    139a:	e8 0f       	add	r30, r24
    139c:	f9 1f       	adc	r31, r25
    139e:	e5 52       	subi	r30, 0x25	; 37
    13a0:	f9 4f       	sbci	r31, 0xF9	; 249
    13a2:	30 81       	ld	r19, Z
    13a4:	33 23       	and	r19, r19
    13a6:	79 f3       	breq	.-34     	; 0x1386 <vTaskSwitchContext+0x38>
    13a8:	ac 01       	movw	r20, r24
    13aa:	44 0f       	add	r20, r20
    13ac:	55 1f       	adc	r21, r21
    13ae:	44 0f       	add	r20, r20
    13b0:	55 1f       	adc	r21, r21
    13b2:	44 0f       	add	r20, r20
    13b4:	55 1f       	adc	r21, r21
    13b6:	48 0f       	add	r20, r24
    13b8:	59 1f       	adc	r21, r25
    13ba:	da 01       	movw	r26, r20
    13bc:	a5 52       	subi	r26, 0x25	; 37
    13be:	b9 4f       	sbci	r27, 0xF9	; 249
    13c0:	11 96       	adiw	r26, 0x01	; 1
    13c2:	ed 91       	ld	r30, X+
    13c4:	fc 91       	ld	r31, X
    13c6:	12 97       	sbiw	r26, 0x02	; 2
    13c8:	02 80       	ldd	r0, Z+2	; 0x02
    13ca:	f3 81       	ldd	r31, Z+3	; 0x03
    13cc:	e0 2d       	mov	r30, r0
    13ce:	12 96       	adiw	r26, 0x02	; 2
    13d0:	fc 93       	st	X, r31
    13d2:	ee 93       	st	-X, r30
    13d4:	11 97       	sbiw	r26, 0x01	; 1
    13d6:	42 52       	subi	r20, 0x22	; 34
    13d8:	59 4f       	sbci	r21, 0xF9	; 249
    13da:	e4 17       	cp	r30, r20
    13dc:	f5 07       	cpc	r31, r21
    13de:	29 f4       	brne	.+10     	; 0x13ea <vTaskSwitchContext+0x9c>
    13e0:	42 81       	ldd	r20, Z+2	; 0x02
    13e2:	53 81       	ldd	r21, Z+3	; 0x03
    13e4:	fd 01       	movw	r30, r26
    13e6:	52 83       	std	Z+2, r21	; 0x02
    13e8:	41 83       	std	Z+1, r20	; 0x01
    13ea:	fc 01       	movw	r30, r24
    13ec:	ee 0f       	add	r30, r30
    13ee:	ff 1f       	adc	r31, r31
    13f0:	ee 0f       	add	r30, r30
    13f2:	ff 1f       	adc	r31, r31
    13f4:	ee 0f       	add	r30, r30
    13f6:	ff 1f       	adc	r31, r31
    13f8:	8e 0f       	add	r24, r30
    13fa:	9f 1f       	adc	r25, r31
    13fc:	fc 01       	movw	r30, r24
    13fe:	e5 52       	subi	r30, 0x25	; 37
    1400:	f9 4f       	sbci	r31, 0xF9	; 249
    1402:	01 80       	ldd	r0, Z+1	; 0x01
    1404:	f2 81       	ldd	r31, Z+2	; 0x02
    1406:	e0 2d       	mov	r30, r0
    1408:	86 81       	ldd	r24, Z+6	; 0x06
    140a:	97 81       	ldd	r25, Z+7	; 0x07
    140c:	90 93 00 07 	sts	0x0700, r25	; 0x800700 <pxCurrentTCB+0x1>
    1410:	80 93 ff 06 	sts	0x06FF, r24	; 0x8006ff <pxCurrentTCB>
    1414:	20 93 a5 06 	sts	0x06A5, r18	; 0x8006a5 <uxTopReadyPriority>
    1418:	08 95       	ret

0000141a <vTaskPlaceOnEventList>:
    141a:	cf 93       	push	r28
    141c:	df 93       	push	r29
    141e:	eb 01       	movw	r28, r22
    1420:	60 91 ff 06 	lds	r22, 0x06FF	; 0x8006ff <pxCurrentTCB>
    1424:	70 91 00 07 	lds	r23, 0x0700	; 0x800700 <pxCurrentTCB+0x1>
    1428:	64 5f       	subi	r22, 0xF4	; 244
    142a:	7f 4f       	sbci	r23, 0xFF	; 255
    142c:	0e 94 94 01 	call	0x328	; 0x328 <vListInsert>
    1430:	61 e0       	ldi	r22, 0x01	; 1
    1432:	ce 01       	movw	r24, r28
    1434:	0e 94 f4 05 	call	0xbe8	; 0xbe8 <prvAddCurrentTaskToDelayedList>
    1438:	df 91       	pop	r29
    143a:	cf 91       	pop	r28
    143c:	08 95       	ret

0000143e <vTaskPlaceOnUnorderedEventList>:
    143e:	cf 93       	push	r28
    1440:	df 93       	push	r29
    1442:	ea 01       	movw	r28, r20
    1444:	e0 91 ff 06 	lds	r30, 0x06FF	; 0x8006ff <pxCurrentTCB>
    1448:	f0 91 00 07 	lds	r31, 0x0700	; 0x800700 <pxCurrentTCB+0x1>
    144c:	70 68       	ori	r23, 0x80	; 128
    144e:	75 87       	std	Z+13, r23	; 0x0d
    1450:	64 87       	std	Z+12, r22	; 0x0c
    1452:	60 91 ff 06 	lds	r22, 0x06FF	; 0x8006ff <pxCurrentTCB>
    1456:	70 91 00 07 	lds	r23, 0x0700	; 0x800700 <pxCurrentTCB+0x1>
    145a:	64 5f       	subi	r22, 0xF4	; 244
    145c:	7f 4f       	sbci	r23, 0xFF	; 255
    145e:	0e 94 73 01 	call	0x2e6	; 0x2e6 <vListInsertEnd>
    1462:	61 e0       	ldi	r22, 0x01	; 1
    1464:	ce 01       	movw	r24, r28
    1466:	0e 94 f4 05 	call	0xbe8	; 0xbe8 <prvAddCurrentTaskToDelayedList>
    146a:	df 91       	pop	r29
    146c:	cf 91       	pop	r28
    146e:	08 95       	ret

00001470 <xTaskRemoveFromEventList>:
    1470:	0f 93       	push	r16
    1472:	1f 93       	push	r17
    1474:	cf 93       	push	r28
    1476:	df 93       	push	r29
    1478:	dc 01       	movw	r26, r24
    147a:	15 96       	adiw	r26, 0x05	; 5
    147c:	ed 91       	ld	r30, X+
    147e:	fc 91       	ld	r31, X
    1480:	16 97       	sbiw	r26, 0x06	; 6
    1482:	c6 81       	ldd	r28, Z+6	; 0x06
    1484:	d7 81       	ldd	r29, Z+7	; 0x07
    1486:	8e 01       	movw	r16, r28
    1488:	04 5f       	subi	r16, 0xF4	; 244
    148a:	1f 4f       	sbci	r17, 0xFF	; 255
    148c:	c8 01       	movw	r24, r16
    148e:	0e 94 c5 01 	call	0x38a	; 0x38a <uxListRemove>
    1492:	80 91 9a 06 	lds	r24, 0x069A	; 0x80069a <uxSchedulerSuspended>
    1496:	81 11       	cpse	r24, r1
    1498:	1c c0       	rjmp	.+56     	; 0x14d2 <xTaskRemoveFromEventList+0x62>
    149a:	0a 50       	subi	r16, 0x0A	; 10
    149c:	11 09       	sbc	r17, r1
    149e:	c8 01       	movw	r24, r16
    14a0:	0e 94 c5 01 	call	0x38a	; 0x38a <uxListRemove>
    14a4:	8e 89       	ldd	r24, Y+22	; 0x16
    14a6:	90 91 a5 06 	lds	r25, 0x06A5	; 0x8006a5 <uxTopReadyPriority>
    14aa:	98 17       	cp	r25, r24
    14ac:	10 f4       	brcc	.+4      	; 0x14b2 <xTaskRemoveFromEventList+0x42>
    14ae:	80 93 a5 06 	sts	0x06A5, r24	; 0x8006a5 <uxTopReadyPriority>
    14b2:	90 e0       	ldi	r25, 0x00	; 0
    14b4:	9c 01       	movw	r18, r24
    14b6:	22 0f       	add	r18, r18
    14b8:	33 1f       	adc	r19, r19
    14ba:	22 0f       	add	r18, r18
    14bc:	33 1f       	adc	r19, r19
    14be:	22 0f       	add	r18, r18
    14c0:	33 1f       	adc	r19, r19
    14c2:	82 0f       	add	r24, r18
    14c4:	93 1f       	adc	r25, r19
    14c6:	b8 01       	movw	r22, r16
    14c8:	85 52       	subi	r24, 0x25	; 37
    14ca:	99 4f       	sbci	r25, 0xF9	; 249
    14cc:	0e 94 73 01 	call	0x2e6	; 0x2e6 <vListInsertEnd>
    14d0:	05 c0       	rjmp	.+10     	; 0x14dc <xTaskRemoveFromEventList+0x6c>
    14d2:	b8 01       	movw	r22, r16
    14d4:	8c eb       	ldi	r24, 0xBC	; 188
    14d6:	96 e0       	ldi	r25, 0x06	; 6
    14d8:	0e 94 73 01 	call	0x2e6	; 0x2e6 <vListInsertEnd>
    14dc:	e0 91 ff 06 	lds	r30, 0x06FF	; 0x8006ff <pxCurrentTCB>
    14e0:	f0 91 00 07 	lds	r31, 0x0700	; 0x800700 <pxCurrentTCB+0x1>
    14e4:	9e 89       	ldd	r25, Y+22	; 0x16
    14e6:	86 89       	ldd	r24, Z+22	; 0x16
    14e8:	89 17       	cp	r24, r25
    14ea:	20 f4       	brcc	.+8      	; 0x14f4 <xTaskRemoveFromEventList+0x84>
    14ec:	81 e0       	ldi	r24, 0x01	; 1
    14ee:	80 93 a1 06 	sts	0x06A1, r24	; 0x8006a1 <xYieldPending>
    14f2:	01 c0       	rjmp	.+2      	; 0x14f6 <xTaskRemoveFromEventList+0x86>
    14f4:	80 e0       	ldi	r24, 0x00	; 0
    14f6:	df 91       	pop	r29
    14f8:	cf 91       	pop	r28
    14fa:	1f 91       	pop	r17
    14fc:	0f 91       	pop	r16
    14fe:	08 95       	ret

00001500 <vTaskRemoveFromUnorderedEventList>:
    1500:	0f 93       	push	r16
    1502:	1f 93       	push	r17
    1504:	cf 93       	push	r28
    1506:	df 93       	push	r29
    1508:	70 68       	ori	r23, 0x80	; 128
    150a:	fc 01       	movw	r30, r24
    150c:	71 83       	std	Z+1, r23	; 0x01
    150e:	60 83       	st	Z, r22
    1510:	c6 81       	ldd	r28, Z+6	; 0x06
    1512:	d7 81       	ldd	r29, Z+7	; 0x07
    1514:	0e 94 c5 01 	call	0x38a	; 0x38a <uxListRemove>
    1518:	8e 01       	movw	r16, r28
    151a:	0e 5f       	subi	r16, 0xFE	; 254
    151c:	1f 4f       	sbci	r17, 0xFF	; 255
    151e:	c8 01       	movw	r24, r16
    1520:	0e 94 c5 01 	call	0x38a	; 0x38a <uxListRemove>
    1524:	8e 89       	ldd	r24, Y+22	; 0x16
    1526:	90 91 a5 06 	lds	r25, 0x06A5	; 0x8006a5 <uxTopReadyPriority>
    152a:	98 17       	cp	r25, r24
    152c:	10 f4       	brcc	.+4      	; 0x1532 <vTaskRemoveFromUnorderedEventList+0x32>
    152e:	80 93 a5 06 	sts	0x06A5, r24	; 0x8006a5 <uxTopReadyPriority>
    1532:	90 e0       	ldi	r25, 0x00	; 0
    1534:	9c 01       	movw	r18, r24
    1536:	22 0f       	add	r18, r18
    1538:	33 1f       	adc	r19, r19
    153a:	22 0f       	add	r18, r18
    153c:	33 1f       	adc	r19, r19
    153e:	22 0f       	add	r18, r18
    1540:	33 1f       	adc	r19, r19
    1542:	82 0f       	add	r24, r18
    1544:	93 1f       	adc	r25, r19
    1546:	b8 01       	movw	r22, r16
    1548:	85 52       	subi	r24, 0x25	; 37
    154a:	99 4f       	sbci	r25, 0xF9	; 249
    154c:	0e 94 73 01 	call	0x2e6	; 0x2e6 <vListInsertEnd>
    1550:	e0 91 ff 06 	lds	r30, 0x06FF	; 0x8006ff <pxCurrentTCB>
    1554:	f0 91 00 07 	lds	r31, 0x0700	; 0x800700 <pxCurrentTCB+0x1>
    1558:	9e 89       	ldd	r25, Y+22	; 0x16
    155a:	86 89       	ldd	r24, Z+22	; 0x16
    155c:	89 17       	cp	r24, r25
    155e:	18 f4       	brcc	.+6      	; 0x1566 <vTaskRemoveFromUnorderedEventList+0x66>
    1560:	81 e0       	ldi	r24, 0x01	; 1
    1562:	80 93 a1 06 	sts	0x06A1, r24	; 0x8006a1 <xYieldPending>
    1566:	df 91       	pop	r29
    1568:	cf 91       	pop	r28
    156a:	1f 91       	pop	r17
    156c:	0f 91       	pop	r16
    156e:	08 95       	ret

00001570 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    1570:	20 91 a0 06 	lds	r18, 0x06A0	; 0x8006a0 <xNumOfOverflows>
    1574:	fc 01       	movw	r30, r24
    1576:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    1578:	20 91 a6 06 	lds	r18, 0x06A6	; 0x8006a6 <xTickCount>
    157c:	30 91 a7 06 	lds	r19, 0x06A7	; 0x8006a7 <xTickCount+0x1>
    1580:	32 83       	std	Z+2, r19	; 0x02
    1582:	21 83       	std	Z+1, r18	; 0x01
    1584:	08 95       	ret

00001586 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    1586:	cf 93       	push	r28
    1588:	df 93       	push	r29
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    158a:	0f b6       	in	r0, 0x3f	; 63
    158c:	f8 94       	cli
    158e:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    1590:	20 91 a6 06 	lds	r18, 0x06A6	; 0x8006a6 <xTickCount>
    1594:	30 91 a7 06 	lds	r19, 0x06A7	; 0x8006a7 <xTickCount+0x1>
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
    1598:	db 01       	movw	r26, r22
    159a:	4d 91       	ld	r20, X+
    159c:	5c 91       	ld	r21, X
    159e:	4f 3f       	cpi	r20, 0xFF	; 255
    15a0:	bf ef       	ldi	r27, 0xFF	; 255
    15a2:	5b 07       	cpc	r21, r27
    15a4:	f1 f0       	breq	.+60     	; 0x15e2 <xTaskCheckForTimeOut+0x5c>

	taskENTER_CRITICAL();
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    15a6:	ec 01       	movw	r28, r24
    15a8:	e9 81       	ldd	r30, Y+1	; 0x01
    15aa:	fa 81       	ldd	r31, Y+2	; 0x02
				xReturn = pdFALSE;
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    15ac:	a0 91 a0 06 	lds	r26, 0x06A0	; 0x8006a0 <xNumOfOverflows>
    15b0:	b8 81       	ld	r27, Y
    15b2:	ba 17       	cp	r27, r26
    15b4:	19 f0       	breq	.+6      	; 0x15bc <xTaskCheckForTimeOut+0x36>
    15b6:	2e 17       	cp	r18, r30
    15b8:	3f 07       	cpc	r19, r31
    15ba:	a8 f4       	brcc	.+42     	; 0x15e6 <xTaskCheckForTimeOut+0x60>

	taskENTER_CRITICAL();
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    15bc:	2e 1b       	sub	r18, r30
    15be:	3f 0b       	sbc	r19, r31
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    15c0:	24 17       	cp	r18, r20
    15c2:	35 07       	cpc	r19, r21
    15c4:	48 f4       	brcc	.+18     	; 0x15d8 <xTaskCheckForTimeOut+0x52>
    15c6:	fb 01       	movw	r30, r22
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
    15c8:	42 1b       	sub	r20, r18
    15ca:	53 0b       	sbc	r21, r19
    15cc:	51 83       	std	Z+1, r21	; 0x01
    15ce:	40 83       	st	Z, r20
			vTaskInternalSetTimeOutState( pxTimeOut );
    15d0:	0e 94 b8 0a 	call	0x1570	; 0x1570 <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
    15d4:	80 e0       	ldi	r24, 0x00	; 0
    15d6:	08 c0       	rjmp	.+16     	; 0x15e8 <xTaskCheckForTimeOut+0x62>
		}
		else
		{
			*pxTicksToWait = 0;
    15d8:	fb 01       	movw	r30, r22
    15da:	11 82       	std	Z+1, r1	; 0x01
    15dc:	10 82       	st	Z, r1
			xReturn = pdTRUE;
    15de:	81 e0       	ldi	r24, 0x01	; 1
    15e0:	03 c0       	rjmp	.+6      	; 0x15e8 <xTaskCheckForTimeOut+0x62>
			if( *pxTicksToWait == portMAX_DELAY )
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
    15e2:	80 e0       	ldi	r24, 0x00	; 0
    15e4:	01 c0       	rjmp	.+2      	; 0x15e8 <xTaskCheckForTimeOut+0x62>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    15e6:	81 e0       	ldi	r24, 0x01	; 1
		{
			*pxTicksToWait = 0;
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
    15e8:	0f 90       	pop	r0
    15ea:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    15ec:	df 91       	pop	r29
    15ee:	cf 91       	pop	r28
    15f0:	08 95       	ret

000015f2 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
    15f2:	81 e0       	ldi	r24, 0x01	; 1
    15f4:	80 93 a1 06 	sts	0x06A1, r24	; 0x8006a1 <xYieldPending>
    15f8:	08 95       	ret

000015fa <uxTaskResetEventItemValue>:

TickType_t uxTaskResetEventItemValue( void )
{
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    15fa:	e0 91 ff 06 	lds	r30, 0x06FF	; 0x8006ff <pxCurrentTCB>
    15fe:	f0 91 00 07 	lds	r31, 0x0700	; 0x800700 <pxCurrentTCB+0x1>
    1602:	84 85       	ldd	r24, Z+12	; 0x0c
    1604:	95 85       	ldd	r25, Z+13	; 0x0d

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1606:	e0 91 ff 06 	lds	r30, 0x06FF	; 0x8006ff <pxCurrentTCB>
    160a:	f0 91 00 07 	lds	r31, 0x0700	; 0x800700 <pxCurrentTCB+0x1>
    160e:	a0 91 ff 06 	lds	r26, 0x06FF	; 0x8006ff <pxCurrentTCB>
    1612:	b0 91 00 07 	lds	r27, 0x0700	; 0x800700 <pxCurrentTCB+0x1>
    1616:	56 96       	adiw	r26, 0x16	; 22
    1618:	4c 91       	ld	r20, X
    161a:	24 e0       	ldi	r18, 0x04	; 4
    161c:	30 e0       	ldi	r19, 0x00	; 0
    161e:	24 1b       	sub	r18, r20
    1620:	31 09       	sbc	r19, r1
    1622:	35 87       	std	Z+13, r19	; 0x0d
    1624:	24 87       	std	Z+12, r18	; 0x0c

	return uxReturn;
}
    1626:	08 95       	ret

00001628 <enableTrigger>:
//   data changes.
////////////////////////////////////////////////////////////////////
void enableTrigger(void)
{

	CLR_BIT(PORTB,2);
    1628:	c2 98       	cbi	0x18, 2	; 24
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    162a:	89 ef       	ldi	r24, 0xF9	; 249
    162c:	90 e0       	ldi	r25, 0x00	; 0
    162e:	01 97       	sbiw	r24, 0x01	; 1
    1630:	f1 f7       	brne	.-4      	; 0x162e <enableTrigger+0x6>
    1632:	00 c0       	rjmp	.+0      	; 0x1634 <enableTrigger+0xc>
    1634:	00 00       	nop
	
	_delay_ms(1);

	SET_BIT(PORTB,2);
    1636:	c2 9a       	sbi	0x18, 2	; 24
    1638:	8b ed       	ldi	r24, 0xDB	; 219
    163a:	95 e0       	ldi	r25, 0x05	; 5
    163c:	01 97       	sbiw	r24, 0x01	; 1
    163e:	f1 f7       	brne	.-4      	; 0x163c <enableTrigger+0x14>
    1640:	00 c0       	rjmp	.+0      	; 0x1642 <enableTrigger+0x1a>
    1642:	00 00       	nop
    1644:	08 95       	ret

00001646 <lcd_sendCommand>:
		
}


void lcd_sendCommand(unsigned char cmd)
{
    1646:	cf 93       	push	r28
    1648:	c8 2f       	mov	r28, r24
	unsigned char high_nibble , low_nibble ; 		
	
	HIGH_NIBBLE(high_nibble,cmd);
	LOW_NIBBLE(low_nibble,cmd);

	CLR_BIT(PORTB,0); // to enable command mode 
    164a:	c0 98       	cbi	0x18, 0	; 24
	CLR_BIT(PORTB,1); // write signal to lcd 
    164c:	c1 98       	cbi	0x18, 1	; 24

	PORTB &=0x0f;
    164e:	88 b3       	in	r24, 0x18	; 24
    1650:	8f 70       	andi	r24, 0x0F	; 15
    1652:	88 bb       	out	0x18, r24	; 24
	PORTB |=high_nibble;// to send high nibble command  
    1654:	88 b3       	in	r24, 0x18	; 24
    1656:	9c 2f       	mov	r25, r28
    1658:	90 7f       	andi	r25, 0xF0	; 240
    165a:	89 2b       	or	r24, r25
    165c:	88 bb       	out	0x18, r24	; 24
	enableTrigger(); // triggre lcd enable 
    165e:	0e 94 14 0b 	call	0x1628	; 0x1628 <enableTrigger>

	PORTB &=0x0f;
    1662:	88 b3       	in	r24, 0x18	; 24
    1664:	8f 70       	andi	r24, 0x0F	; 15
    1666:	88 bb       	out	0x18, r24	; 24
	PORTB |=low_nibble; // to send low nibble command 
    1668:	88 b3       	in	r24, 0x18	; 24
    166a:	c2 95       	swap	r28
    166c:	c0 7f       	andi	r28, 0xF0	; 240
    166e:	c8 2b       	or	r28, r24
    1670:	c8 bb       	out	0x18, r28	; 24
	enableTrigger();
    1672:	0e 94 14 0b 	call	0x1628	; 0x1628 <enableTrigger>

}
    1676:	cf 91       	pop	r28
    1678:	08 95       	ret

0000167a <lcd_init>:
//							 and pinB.0 to pinB.2 o/p for control pins 
//////////////////////////////////////////////////////////////////////////////////////
void lcd_init(void)
{

	DDRB=0xff; // init port B as O/P port 
    167a:	8f ef       	ldi	r24, 0xFF	; 255
    167c:	87 bb       	out	0x17, r24	; 23
	PORTB=0x04; // activate LCD enable 
    167e:	84 e0       	ldi	r24, 0x04	; 4
    1680:	88 bb       	out	0x18, r24	; 24

	lcd_sendCommand(0x33); // 4-bit mode 
    1682:	83 e3       	ldi	r24, 0x33	; 51
    1684:	0e 94 23 0b 	call	0x1646	; 0x1646 <lcd_sendCommand>
	lcd_sendCommand (0x32);
    1688:	82 e3       	ldi	r24, 0x32	; 50
    168a:	0e 94 23 0b 	call	0x1646	; 0x1646 <lcd_sendCommand>
	lcd_sendCommand (0x28);
    168e:	88 e2       	ldi	r24, 0x28	; 40
    1690:	0e 94 23 0b 	call	0x1646	; 0x1646 <lcd_sendCommand>



	lcd_sendCommand(0x0c); // turn on lcd 
    1694:	8c e0       	ldi	r24, 0x0C	; 12
    1696:	0e 94 23 0b 	call	0x1646	; 0x1646 <lcd_sendCommand>
    169a:	08 95       	ret

0000169c <lcd_displayChar>:
	enableTrigger();

}

void lcd_displayChar (unsigned char data)
{
    169c:	cf 93       	push	r28
    169e:	c8 2f       	mov	r28, r24

	unsigned char high_nibble , low_nibble ;

	SET_BIT(PORTB,0); //  enable data mode 
    16a0:	c0 9a       	sbi	0x18, 0	; 24
	CLR_BIT(PORTB,1); // activate lcd write 
    16a2:	c1 98       	cbi	0x18, 1	; 24

	HIGH_NIBBLE(high_nibble,data); // get high nibble data 
	LOW_NIBBLE(low_nibble,data); // get low nibble data 
	
	PORTB &= 0x0f;
    16a4:	88 b3       	in	r24, 0x18	; 24
    16a6:	8f 70       	andi	r24, 0x0F	; 15
    16a8:	88 bb       	out	0x18, r24	; 24
	PORTB |=high_nibble;// to send high nibble data  
    16aa:	88 b3       	in	r24, 0x18	; 24
    16ac:	9c 2f       	mov	r25, r28
    16ae:	90 7f       	andi	r25, 0xF0	; 240
    16b0:	89 2b       	or	r24, r25
    16b2:	88 bb       	out	0x18, r24	; 24
	enableTrigger(); // triggre lcd enable 
    16b4:	0e 94 14 0b 	call	0x1628	; 0x1628 <enableTrigger>
	
	PORTB &=0x0f;
    16b8:	88 b3       	in	r24, 0x18	; 24
    16ba:	8f 70       	andi	r24, 0x0F	; 15
    16bc:	88 bb       	out	0x18, r24	; 24
	PORTB |=low_nibble; // to send low nibble data 
    16be:	88 b3       	in	r24, 0x18	; 24
    16c0:	c2 95       	swap	r28
    16c2:	c0 7f       	andi	r28, 0xF0	; 240
    16c4:	c8 2b       	or	r28, r24
    16c6:	c8 bb       	out	0x18, r28	; 24
	enableTrigger();
    16c8:	0e 94 14 0b 	call	0x1628	; 0x1628 <enableTrigger>
	

}
    16cc:	cf 91       	pop	r28
    16ce:	08 95       	ret

000016d0 <lcd_gotoxy>:

void lcd_gotoxy(unsigned char y , unsigned char x )
{
	unsigned char position = 0x80;
	 
	switch(y)
    16d0:	81 30       	cpi	r24, 0x01	; 1
    16d2:	49 f0       	breq	.+18     	; 0x16e6 <lcd_gotoxy+0x16>
    16d4:	28 f0       	brcs	.+10     	; 0x16e0 <lcd_gotoxy+0x10>
    16d6:	82 30       	cpi	r24, 0x02	; 2
    16d8:	49 f0       	breq	.+18     	; 0x16ec <lcd_gotoxy+0x1c>
    16da:	83 30       	cpi	r24, 0x03	; 3
    16dc:	51 f0       	breq	.+20     	; 0x16f2 <lcd_gotoxy+0x22>
    16de:	0c c0       	rjmp	.+24     	; 0x16f8 <lcd_gotoxy+0x28>
	{
		case 0:

			position=position+x;
    16e0:	80 e8       	ldi	r24, 0x80	; 128
    16e2:	86 0f       	add	r24, r22
					
		break;
    16e4:	0a c0       	rjmp	.+20     	; 0x16fa <lcd_gotoxy+0x2a>

		case 1:

			position=0xc0;
			position=position+x;
    16e6:	80 ec       	ldi	r24, 0xC0	; 192
    16e8:	86 0f       	add	r24, r22

		break;
    16ea:	07 c0       	rjmp	.+14     	; 0x16fa <lcd_gotoxy+0x2a>

		case 2:

			position=position+x;
    16ec:	80 e8       	ldi	r24, 0x80	; 128
    16ee:	86 0f       	add	r24, r22

		break;
    16f0:	04 c0       	rjmp	.+8      	; 0x16fa <lcd_gotoxy+0x2a>

		case 3:
			position=position+x;
    16f2:	80 e8       	ldi	r24, 0x80	; 128
    16f4:	86 0f       	add	r24, r22
		break;
    16f6:	01 c0       	rjmp	.+2      	; 0x16fa <lcd_gotoxy+0x2a>
}


void lcd_gotoxy(unsigned char y , unsigned char x )
{
	unsigned char position = 0x80;
    16f8:	80 e8       	ldi	r24, 0x80	; 128
		break;
	
	
	}
	
	lcd_sendCommand(position); 	
    16fa:	0e 94 23 0b 	call	0x1646	; 0x1646 <lcd_sendCommand>
    16fe:	08 95       	ret

00001700 <lcd_clrScreen>:


void lcd_clrScreen(void)
{

	lcd_sendCommand(0x01);
    1700:	81 e0       	ldi	r24, 0x01	; 1
    1702:	0e 94 23 0b 	call	0x1646	; 0x1646 <lcd_sendCommand>
    1706:	08 95       	ret

00001708 <lcd_dispString>:

}


void lcd_dispString(char * ptr)
{
    1708:	cf 93       	push	r28
    170a:	df 93       	push	r29
    170c:	ec 01       	movw	r28, r24

	while(* ptr!= '\0')
    170e:	88 81       	ld	r24, Y
    1710:	88 23       	and	r24, r24
    1712:	31 f0       	breq	.+12     	; 0x1720 <lcd_dispString+0x18>
    1714:	21 96       	adiw	r28, 0x01	; 1
	{
		lcd_displayChar(* ptr);
    1716:	0e 94 4e 0b 	call	0x169c	; 0x169c <lcd_displayChar>


void lcd_dispString(char * ptr)
{

	while(* ptr!= '\0')
    171a:	89 91       	ld	r24, Y+
    171c:	81 11       	cpse	r24, r1
    171e:	fb cf       	rjmp	.-10     	; 0x1716 <lcd_dispString+0xe>
	
	}



}
    1720:	df 91       	pop	r29
    1722:	cf 91       	pop	r28
    1724:	08 95       	ret

00001726 <lcd_disp_string_xy>:

void lcd_disp_string_xy(char * ptr , int y , int x)
{
    1726:	cf 93       	push	r28
    1728:	df 93       	push	r29
    172a:	ec 01       	movw	r28, r24
    172c:	86 2f       	mov	r24, r22

	lcd_gotoxy(y,x);
    172e:	64 2f       	mov	r22, r20
    1730:	0e 94 68 0b 	call	0x16d0	; 0x16d0 <lcd_gotoxy>
	lcd_dispString(ptr);
    1734:	ce 01       	movw	r24, r28
    1736:	0e 94 84 0b 	call	0x1708	; 0x1708 <lcd_dispString>

	


}
    173a:	df 91       	pop	r29
    173c:	cf 91       	pop	r28
    173e:	08 95       	ret

00001740 <lcd_disp_number>:

void lcd_disp_number(unsigned int number){
    1740:	ef 92       	push	r14
    1742:	ff 92       	push	r15
    1744:	0f 93       	push	r16
    1746:	1f 93       	push	r17
    1748:	cf 93       	push	r28
    174a:	df 93       	push	r29
    174c:	cd b7       	in	r28, 0x3d	; 61
    174e:	de b7       	in	r29, 0x3e	; 62
    1750:	60 97       	sbiw	r28, 0x10	; 16
    1752:	0f b6       	in	r0, 0x3f	; 63
    1754:	f8 94       	cli
    1756:	de bf       	out	0x3e, r29	; 62
    1758:	0f be       	out	0x3f, r0	; 63
    175a:	cd bf       	out	0x3d, r28	; 61
    175c:	ac 01       	movw	r20, r24
	char string[16] = {0};
    175e:	fe 01       	movw	r30, r28
    1760:	31 96       	adiw	r30, 0x01	; 1
    1762:	80 e1       	ldi	r24, 0x10	; 16
    1764:	df 01       	movw	r26, r30
    1766:	1d 92       	st	X+, r1
    1768:	8a 95       	dec	r24
    176a:	e9 f7       	brne	.-6      	; 0x1766 <lcd_disp_number+0x26>
	short int i = 0;
	if(number == 0){
    176c:	41 15       	cp	r20, r1
    176e:	51 05       	cpc	r21, r1
    1770:	21 f4       	brne	.+8      	; 0x177a <lcd_disp_number+0x3a>
		lcd_displayChar('0');
    1772:	80 e3       	ldi	r24, 0x30	; 48
    1774:	0e 94 4e 0b 	call	0x169c	; 0x169c <lcd_displayChar>
    1778:	43 c0       	rjmp	.+134    	; 0x1800 <lcd_disp_number+0xc0>
    177a:	fe 01       	movw	r30, r28
    177c:	31 96       	adiw	r30, 0x01	; 1
}

void lcd_disp_number(unsigned int number){
	char string[16] = {0};
	short int i = 0;
	if(number == 0){
    177e:	00 e0       	ldi	r16, 0x00	; 0
    1780:	10 e0       	ldi	r17, 0x00	; 0
    1782:	01 c0       	rjmp	.+2      	; 0x1786 <lcd_disp_number+0x46>
	}

	while(number > 0){
		string[i] = (number%10) + '0';
		number = number / 10;
		i++;
    1784:	87 01       	movw	r16, r14
		lcd_displayChar('0');
		return;
	}

	while(number > 0){
		string[i] = (number%10) + '0';
    1786:	9a 01       	movw	r18, r20
    1788:	ad ec       	ldi	r26, 0xCD	; 205
    178a:	bc ec       	ldi	r27, 0xCC	; 204
    178c:	0e 94 81 13 	call	0x2702	; 0x2702 <__umulhisi3>
    1790:	96 95       	lsr	r25
    1792:	87 95       	ror	r24
    1794:	96 95       	lsr	r25
    1796:	87 95       	ror	r24
    1798:	96 95       	lsr	r25
    179a:	87 95       	ror	r24
    179c:	9c 01       	movw	r18, r24
    179e:	22 0f       	add	r18, r18
    17a0:	33 1f       	adc	r19, r19
    17a2:	88 0f       	add	r24, r24
    17a4:	99 1f       	adc	r25, r25
    17a6:	88 0f       	add	r24, r24
    17a8:	99 1f       	adc	r25, r25
    17aa:	88 0f       	add	r24, r24
    17ac:	99 1f       	adc	r25, r25
    17ae:	82 0f       	add	r24, r18
    17b0:	93 1f       	adc	r25, r19
    17b2:	9a 01       	movw	r18, r20
    17b4:	28 1b       	sub	r18, r24
    17b6:	39 0b       	sbc	r19, r25
    17b8:	c9 01       	movw	r24, r18
    17ba:	80 5d       	subi	r24, 0xD0	; 208
    17bc:	81 93       	st	Z+, r24
		number = number / 10;
    17be:	9a 01       	movw	r18, r20
    17c0:	0e 94 81 13 	call	0x2702	; 0x2702 <__umulhisi3>
    17c4:	ac 01       	movw	r20, r24
    17c6:	56 95       	lsr	r21
    17c8:	47 95       	ror	r20
    17ca:	56 95       	lsr	r21
    17cc:	47 95       	ror	r20
    17ce:	56 95       	lsr	r21
    17d0:	47 95       	ror	r20
    17d2:	78 01       	movw	r14, r16
    17d4:	3f ef       	ldi	r19, 0xFF	; 255
    17d6:	e3 1a       	sub	r14, r19
    17d8:	f3 0a       	sbc	r15, r19
	if(number == 0){
		lcd_displayChar('0');
		return;
	}

	while(number > 0){
    17da:	41 15       	cp	r20, r1
    17dc:	51 05       	cpc	r21, r1
    17de:	91 f6       	brne	.-92     	; 0x1784 <lcd_disp_number+0x44>
		number = number / 10;
		i++;
	}

	i--;
	while(i >= 0){
    17e0:	11 23       	and	r17, r17
    17e2:	74 f0       	brlt	.+28     	; 0x1800 <lcd_disp_number+0xc0>
    17e4:	81 e0       	ldi	r24, 0x01	; 1
    17e6:	90 e0       	ldi	r25, 0x00	; 0
    17e8:	8c 0f       	add	r24, r28
    17ea:	9d 1f       	adc	r25, r29
    17ec:	e8 0e       	add	r14, r24
    17ee:	f9 1e       	adc	r15, r25
		lcd_displayChar(string[i]);
    17f0:	d7 01       	movw	r26, r14
    17f2:	8e 91       	ld	r24, -X
    17f4:	7d 01       	movw	r14, r26
    17f6:	0e 94 4e 0b 	call	0x169c	; 0x169c <lcd_displayChar>
    17fa:	01 50       	subi	r16, 0x01	; 1
    17fc:	11 09       	sbc	r17, r1
		number = number / 10;
		i++;
	}

	i--;
	while(i >= 0){
    17fe:	c2 f7       	brpl	.-16     	; 0x17f0 <lcd_disp_number+0xb0>
		lcd_displayChar(string[i]);
		i--;
	}
}
    1800:	60 96       	adiw	r28, 0x10	; 16
    1802:	0f b6       	in	r0, 0x3f	; 63
    1804:	f8 94       	cli
    1806:	de bf       	out	0x3e, r29	; 62
    1808:	0f be       	out	0x3f, r0	; 63
    180a:	cd bf       	out	0x3d, r28	; 61
    180c:	df 91       	pop	r29
    180e:	cf 91       	pop	r28
    1810:	1f 91       	pop	r17
    1812:	0f 91       	pop	r16
    1814:	ff 90       	pop	r15
    1816:	ef 90       	pop	r14
    1818:	08 95       	ret

0000181a <gpio_init>:
	return 0;
}

void gpio_init(void){
	//Idle hook indication
	DDRA = 0xFF; //PORTA:OUTPUT
    181a:	8f ef       	ldi	r24, 0xFF	; 255
    181c:	8a bb       	out	0x1a, r24	; 26
	
	//KEYPAD
	DDRC = 0x0F; //4pins:INPUT(Read) and 4pins:OUTPUT(Write)
    181e:	9f e0       	ldi	r25, 0x0F	; 15
    1820:	94 bb       	out	0x14, r25	; 20
	PORTC = 0xFF; //Pull up resistors for inputs and Set outputs
    1822:	85 bb       	out	0x15, r24	; 21

	//SW and LED
	DDRD = (1<<7); //Switch:INPUT and LED:OUTPUT
    1824:	80 e8       	ldi	r24, 0x80	; 128
    1826:	81 bb       	out	0x11, r24	; 17
    1828:	08 95       	ret

0000182a <main>:
void *display_struct = &calc_disp;

void gpio_init(void);

int main( void )
{
    182a:	ef 92       	push	r14
    182c:	ff 92       	push	r15
    182e:	0f 93       	push	r16
	gpio_init();
    1830:	0e 94 0d 0c 	call	0x181a	; 0x181a <gpio_init>
	lcd_init();
    1834:	0e 94 3d 0b 	call	0x167a	; 0x167a <lcd_init>
	TIM2_Init();
    1838:	0e 94 ad 11 	call	0x235a	; 0x235a <TIM2_Init>
	TIM2_SetDutyCycle(0);
    183c:	80 e0       	ldi	r24, 0x00	; 0
    183e:	0e 94 bb 11 	call	0x2376	; 0x2376 <TIM2_SetDutyCycle>
	
	event_handle = xEventGroupCreate();
    1842:	0e 94 49 00 	call	0x92	; 0x92 <xEventGroupCreate>
    1846:	90 93 15 07 	sts	0x0715, r25	; 0x800715 <event_handle+0x1>
    184a:	80 93 14 07 	sts	0x0714, r24	; 0x800714 <event_handle>
	queue_handle = xQueueCreate(4,sizeof(char));
    184e:	40 e0       	ldi	r20, 0x00	; 0
    1850:	61 e0       	ldi	r22, 0x01	; 1
    1852:	84 e0       	ldi	r24, 0x04	; 4
    1854:	0e 94 7b 04 	call	0x8f6	; 0x8f6 <xQueueGenericCreate>
    1858:	90 93 0d 07 	sts	0x070D, r25	; 0x80070d <queue_handle+0x1>
    185c:	80 93 0c 07 	sts	0x070C, r24	; 0x80070c <queue_handle>
	
	#if FAST_TEST == 0
	xTaskCreate( WelcomePattern_Task, "Welcome", 100, NULL, WELCOME_PRIORITY, &WelcomePattern_Handle);
    1860:	0f 2e       	mov	r0, r31
    1862:	f2 e1       	ldi	r31, 0x12	; 18
    1864:	ef 2e       	mov	r14, r31
    1866:	f7 e0       	ldi	r31, 0x07	; 7
    1868:	ff 2e       	mov	r15, r31
    186a:	f0 2d       	mov	r31, r0
    186c:	03 e0       	ldi	r16, 0x03	; 3
    186e:	20 e0       	ldi	r18, 0x00	; 0
    1870:	30 e0       	ldi	r19, 0x00	; 0
    1872:	44 e6       	ldi	r20, 0x64	; 100
    1874:	50 e0       	ldi	r21, 0x00	; 0
    1876:	67 e6       	ldi	r22, 0x67	; 103
    1878:	70 e0       	ldi	r23, 0x00	; 0
    187a:	8c eb       	ldi	r24, 0xBC	; 188
    187c:	9c e0       	ldi	r25, 0x0C	; 12
    187e:	0e 94 86 06 	call	0xd0c	; 0xd0c <xTaskCreate>
	xTaskCreate( PromptUserPattern_Task, "Prompt", 100, NULL, PROMPTUSER_PRIORITY, &PromptUser_Handle);
    1882:	0f 2e       	mov	r0, r31
    1884:	f6 e1       	ldi	r31, 0x16	; 22
    1886:	ef 2e       	mov	r14, r31
    1888:	f7 e0       	ldi	r31, 0x07	; 7
    188a:	ff 2e       	mov	r15, r31
    188c:	f0 2d       	mov	r31, r0
    188e:	02 e0       	ldi	r16, 0x02	; 2
    1890:	20 e0       	ldi	r18, 0x00	; 0
    1892:	30 e0       	ldi	r19, 0x00	; 0
    1894:	44 e6       	ldi	r20, 0x64	; 100
    1896:	50 e0       	ldi	r21, 0x00	; 0
    1898:	6f e6       	ldi	r22, 0x6F	; 111
    189a:	70 e0       	ldi	r23, 0x00	; 0
    189c:	84 e2       	ldi	r24, 0x24	; 36
    189e:	9d e0       	ldi	r25, 0x0D	; 13
    18a0:	0e 94 86 06 	call	0xd0c	; 0xd0c <xTaskCreate>
	#endif
	
	xTaskCreate( LED_Task, "LED", 120, NULL, LED_PRIORITY, &LED_Handle);
    18a4:	0f 2e       	mov	r0, r31
    18a6:	fa e1       	ldi	r31, 0x1A	; 26
    18a8:	ef 2e       	mov	r14, r31
    18aa:	f7 e0       	ldi	r31, 0x07	; 7
    18ac:	ff 2e       	mov	r15, r31
    18ae:	f0 2d       	mov	r31, r0
    18b0:	01 e0       	ldi	r16, 0x01	; 1
    18b2:	20 e0       	ldi	r18, 0x00	; 0
    18b4:	30 e0       	ldi	r19, 0x00	; 0
    18b6:	48 e7       	ldi	r20, 0x78	; 120
    18b8:	50 e0       	ldi	r21, 0x00	; 0
    18ba:	66 e7       	ldi	r22, 0x76	; 118
    18bc:	70 e0       	ldi	r23, 0x00	; 0
    18be:	87 e0       	ldi	r24, 0x07	; 7
    18c0:	9e e0       	ldi	r25, 0x0E	; 14
    18c2:	0e 94 86 06 	call	0xd0c	; 0xd0c <xTaskCreate>
	xTaskCreate( LCD_Task, "LCD", 120, display_struct, LCD_PRIORITY, &LCD_Handle);
    18c6:	20 91 60 00 	lds	r18, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
    18ca:	30 91 61 00 	lds	r19, 0x0061	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
    18ce:	0f 2e       	mov	r0, r31
    18d0:	fe e0       	ldi	r31, 0x0E	; 14
    18d2:	ef 2e       	mov	r14, r31
    18d4:	f7 e0       	ldi	r31, 0x07	; 7
    18d6:	ff 2e       	mov	r15, r31
    18d8:	f0 2d       	mov	r31, r0
    18da:	48 e7       	ldi	r20, 0x78	; 120
    18dc:	50 e0       	ldi	r21, 0x00	; 0
    18de:	6a e7       	ldi	r22, 0x7A	; 122
    18e0:	70 e0       	ldi	r23, 0x00	; 0
    18e2:	88 ec       	ldi	r24, 0xC8	; 200
    18e4:	9d e0       	ldi	r25, 0x0D	; 13
    18e6:	0e 94 86 06 	call	0xd0c	; 0xd0c <xTaskCreate>
	xTaskCreate( KEYPAD_Task, "Keypad", 120, NULL, KEYPAD_PRIORITY, &KEYPAD_Handle);
    18ea:	0f 2e       	mov	r0, r31
    18ec:	f8 e1       	ldi	r31, 0x18	; 24
    18ee:	ef 2e       	mov	r14, r31
    18f0:	f7 e0       	ldi	r31, 0x07	; 7
    18f2:	ff 2e       	mov	r15, r31
    18f4:	f0 2d       	mov	r31, r0
    18f6:	20 e0       	ldi	r18, 0x00	; 0
    18f8:	30 e0       	ldi	r19, 0x00	; 0
    18fa:	48 e7       	ldi	r20, 0x78	; 120
    18fc:	50 e0       	ldi	r21, 0x00	; 0
    18fe:	6e e7       	ldi	r22, 0x7E	; 126
    1900:	70 e0       	ldi	r23, 0x00	; 0
    1902:	8e e6       	ldi	r24, 0x6E	; 110
    1904:	91 e1       	ldi	r25, 0x11	; 17
    1906:	0e 94 86 06 	call	0xd0c	; 0xd0c <xTaskCreate>
	xTaskCreate( SW_Task, "Switch", 120, NULL, SW_PRIORITY, &SW_Handle);
    190a:	0f 2e       	mov	r0, r31
    190c:	fa e0       	ldi	r31, 0x0A	; 10
    190e:	ef 2e       	mov	r14, r31
    1910:	f7 e0       	ldi	r31, 0x07	; 7
    1912:	ff 2e       	mov	r15, r31
    1914:	f0 2d       	mov	r31, r0
    1916:	20 e0       	ldi	r18, 0x00	; 0
    1918:	30 e0       	ldi	r19, 0x00	; 0
    191a:	48 e7       	ldi	r20, 0x78	; 120
    191c:	50 e0       	ldi	r21, 0x00	; 0
    191e:	65 e8       	ldi	r22, 0x85	; 133
    1920:	70 e0       	ldi	r23, 0x00	; 0
    1922:	80 e8       	ldi	r24, 0x80	; 128
    1924:	9e e0       	ldi	r25, 0x0E	; 14
    1926:	0e 94 86 06 	call	0xd0c	; 0xd0c <xTaskCreate>
	xTaskCreate( CALC_Task, "Calculator", 120, display_struct, CALC_PRIORITY, &CALC_Handle);
    192a:	20 91 60 00 	lds	r18, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
    192e:	30 91 61 00 	lds	r19, 0x0061	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
    1932:	0f 2e       	mov	r0, r31
    1934:	f0 e1       	ldi	r31, 0x10	; 16
    1936:	ef 2e       	mov	r14, r31
    1938:	f7 e0       	ldi	r31, 0x07	; 7
    193a:	ff 2e       	mov	r15, r31
    193c:	f0 2d       	mov	r31, r0
    193e:	48 e7       	ldi	r20, 0x78	; 120
    1940:	50 e0       	ldi	r21, 0x00	; 0
    1942:	6c e8       	ldi	r22, 0x8C	; 140
    1944:	70 e0       	ldi	r23, 0x00	; 0
    1946:	8d ee       	ldi	r24, 0xED	; 237
    1948:	9e e0       	ldi	r25, 0x0E	; 14
    194a:	0e 94 86 06 	call	0xd0c	; 0xd0c <xTaskCreate>
	
	/* Start the scheduler. */
	vTaskStartScheduler();
    194e:	0e 94 ed 07 	call	0xfda	; 0xfda <vTaskStartScheduler>
	
	return 0;
}
    1952:	80 e0       	ldi	r24, 0x00	; 0
    1954:	90 e0       	ldi	r25, 0x00	; 0
    1956:	0f 91       	pop	r16
    1958:	ff 90       	pop	r15
    195a:	ef 90       	pop	r14
    195c:	08 95       	ret

0000195e <vApplicationIdleHook>:
extern QueueHandle_t queue_handle;

extern void *display_struct;

void vApplicationIdleHook( void ){
	PORTA ^= 0xFF;
    195e:	8b b3       	in	r24, 0x1b	; 27
    1960:	80 95       	com	r24
    1962:	8b bb       	out	0x1b, r24	; 27
    1964:	2f ef       	ldi	r18, 0xFF	; 255
    1966:	84 e3       	ldi	r24, 0x34	; 52
    1968:	9c e0       	ldi	r25, 0x0C	; 12
    196a:	21 50       	subi	r18, 0x01	; 1
    196c:	80 40       	sbci	r24, 0x00	; 0
    196e:	90 40       	sbci	r25, 0x00	; 0
    1970:	e1 f7       	brne	.-8      	; 0x196a <vApplicationIdleHook+0xc>
    1972:	00 c0       	rjmp	.+0      	; 0x1974 <vApplicationIdleHook+0x16>
    1974:	00 00       	nop
    1976:	08 95       	ret

00001978 <WelcomePattern_Task>:
	_delay_ms(500);
}

void WelcomePattern_Task(void * pvParameters){
    1978:	cf 92       	push	r12
    197a:	df 92       	push	r13
    197c:	ef 92       	push	r14
    197e:	ff 92       	push	r15
    1980:	0f 93       	push	r16
    1982:	1f 93       	push	r17
    1984:	cf 93       	push	r28
    1986:	df 93       	push	r29
    1988:	00 d0       	rcall	.+0      	; 0x198a <WelcomePattern_Task+0x12>
    198a:	cd b7       	in	r28, 0x3d	; 61
    198c:	de b7       	in	r29, 0x3e	; 62
	char delay = 55;
	char y = 9, flag = 1, i = 0;
	taskENABLE_INTERRUPTS();
    198e:	78 94       	sei
	TickType_t tick = xTaskGetTickCount();
    1990:	0e 94 1d 08 	call	0x103a	; 0x103a <xTaskGetTickCount>
    1994:	9a 83       	std	Y+2, r25	; 0x02
    1996:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(500);
}

void WelcomePattern_Task(void * pvParameters){
	char delay = 55;
	char y = 9, flag = 1, i = 0;
    1998:	f1 2c       	mov	r15, r1
    199a:	ee 24       	eor	r14, r14
    199c:	e3 94       	inc	r14
    199e:	19 e0       	ldi	r17, 0x09	; 9
	PORTA ^= 0xFF;
	_delay_ms(500);
}

void WelcomePattern_Task(void * pvParameters){
	char delay = 55;
    19a0:	07 e3       	ldi	r16, 0x37	; 55
    19a2:	d1 2c       	mov	r13, r1
	taskENABLE_INTERRUPTS();
	TickType_t tick = xTaskGetTickCount();
	while(1){
		lcd_disp_string_xy("       ",0,y);
		if(y == 9){
			flag = 1;
    19a4:	cc 24       	eor	r12, r12
    19a6:	c3 94       	inc	r12
	char delay = 55;
	char y = 9, flag = 1, i = 0;
	taskENABLE_INTERRUPTS();
	TickType_t tick = xTaskGetTickCount();
	while(1){
		lcd_disp_string_xy("       ",0,y);
    19a8:	41 2f       	mov	r20, r17
    19aa:	50 e0       	ldi	r21, 0x00	; 0
    19ac:	60 e0       	ldi	r22, 0x00	; 0
    19ae:	70 e0       	ldi	r23, 0x00	; 0
    19b0:	87 e9       	ldi	r24, 0x97	; 151
    19b2:	90 e0       	ldi	r25, 0x00	; 0
    19b4:	0e 94 93 0b 	call	0x1726	; 0x1726 <lcd_disp_string_xy>
		if(y == 9){
    19b8:	19 30       	cpi	r17, 0x09	; 9
    19ba:	41 f4       	brne	.+16     	; 0x19cc <WelcomePattern_Task+0x54>
			flag = 1;
			delay = 56;
			if(i++ == WELCOME_CYCLES) break;
    19bc:	81 e0       	ldi	r24, 0x01	; 1
    19be:	8f 0d       	add	r24, r15
    19c0:	93 e0       	ldi	r25, 0x03	; 3
    19c2:	f9 16       	cp	r15, r25
    19c4:	11 f1       	breq	.+68     	; 0x1a0a <WelcomePattern_Task+0x92>
	taskENABLE_INTERRUPTS();
	TickType_t tick = xTaskGetTickCount();
	while(1){
		lcd_disp_string_xy("       ",0,y);
		if(y == 9){
			flag = 1;
    19c6:	ec 2c       	mov	r14, r12
			delay = 56;
    19c8:	08 e3       	ldi	r16, 0x38	; 56
    19ca:	0a c0       	rjmp	.+20     	; 0x19e0 <WelcomePattern_Task+0x68>
			if(i++ == WELCOME_CYCLES) break;
		}
		else if(y == 0){
    19cc:	11 23       	and	r17, r17
    19ce:	19 f0       	breq	.+6      	; 0x19d6 <WelcomePattern_Task+0x5e>
			flag = 0;
			delay = 55;
		}
		
		if(flag == 0) y++;
    19d0:	e1 10       	cpse	r14, r1
    19d2:	05 c0       	rjmp	.+10     	; 0x19de <WelcomePattern_Task+0x66>
    19d4:	01 c0       	rjmp	.+2      	; 0x19d8 <WelcomePattern_Task+0x60>
			delay = 56;
			if(i++ == WELCOME_CYCLES) break;
		}
		else if(y == 0){
			flag = 0;
			delay = 55;
    19d6:	07 e3       	ldi	r16, 0x37	; 55
		}
		
		if(flag == 0) y++;
    19d8:	1f 5f       	subi	r17, 0xFF	; 255
    19da:	ed 2c       	mov	r14, r13
    19dc:	03 c0       	rjmp	.+6      	; 0x19e4 <WelcomePattern_Task+0x6c>
    19de:	8f 2d       	mov	r24, r15
		else y--;
    19e0:	11 50       	subi	r17, 0x01	; 1
    19e2:	f8 2e       	mov	r15, r24
		
		lcd_disp_string_xy("Welcome",0,y);
    19e4:	41 2f       	mov	r20, r17
    19e6:	50 e0       	ldi	r21, 0x00	; 0
    19e8:	60 e0       	ldi	r22, 0x00	; 0
    19ea:	70 e0       	ldi	r23, 0x00	; 0
    19ec:	87 e6       	ldi	r24, 0x67	; 103
    19ee:	90 e0       	ldi	r25, 0x00	; 0
    19f0:	0e 94 93 0b 	call	0x1726	; 0x1726 <lcd_disp_string_xy>
		
		tick = xTaskGetTickCount();
    19f4:	0e 94 1d 08 	call	0x103a	; 0x103a <xTaskGetTickCount>
    19f8:	9a 83       	std	Y+2, r25	; 0x02
    19fa:	89 83       	std	Y+1, r24	; 0x01
		vTaskDelayUntil(&tick,delay);
    19fc:	60 2f       	mov	r22, r16
    19fe:	70 e0       	ldi	r23, 0x00	; 0
    1a00:	ce 01       	movw	r24, r28
    1a02:	01 96       	adiw	r24, 0x01	; 1
    1a04:	0e 94 69 09 	call	0x12d2	; 0x12d2 <vTaskDelayUntil>
	}
    1a08:	cf cf       	rjmp	.-98     	; 0x19a8 <WelcomePattern_Task+0x30>
	xEventGroupClearBits(event_handle,portMAX_DELAY);
    1a0a:	6f ef       	ldi	r22, 0xFF	; 255
    1a0c:	7f ef       	ldi	r23, 0xFF	; 255
    1a0e:	80 91 14 07 	lds	r24, 0x0714	; 0x800714 <event_handle>
    1a12:	90 91 15 07 	lds	r25, 0x0715	; 0x800715 <event_handle+0x1>
    1a16:	0e 94 e4 00 	call	0x1c8	; 0x1c8 <xEventGroupClearBits>
	xEventGroupSetBits(event_handle,BIT_WELCOME);
    1a1a:	61 e0       	ldi	r22, 0x01	; 1
    1a1c:	70 e0       	ldi	r23, 0x00	; 0
    1a1e:	80 91 14 07 	lds	r24, 0x0714	; 0x800714 <event_handle>
    1a22:	90 91 15 07 	lds	r25, 0x0715	; 0x800715 <event_handle+0x1>
    1a26:	0e 94 f3 00 	call	0x1e6	; 0x1e6 <xEventGroupSetBits>
	vTaskDelete(NULL);
    1a2a:	80 e0       	ldi	r24, 0x00	; 0
    1a2c:	90 e0       	ldi	r25, 0x00	; 0
    1a2e:	0e 94 98 07 	call	0xf30	; 0xf30 <vTaskDelete>
}
    1a32:	0f 90       	pop	r0
    1a34:	0f 90       	pop	r0
    1a36:	df 91       	pop	r29
    1a38:	cf 91       	pop	r28
    1a3a:	1f 91       	pop	r17
    1a3c:	0f 91       	pop	r16
    1a3e:	ff 90       	pop	r15
    1a40:	ef 90       	pop	r14
    1a42:	df 90       	pop	r13
    1a44:	cf 90       	pop	r12
    1a46:	08 95       	ret

00001a48 <PromptUserPattern_Task>:

void PromptUserPattern_Task(void * pvParameters){
    1a48:	ef 92       	push	r14
    1a4a:	ff 92       	push	r15
    1a4c:	0f 93       	push	r16
    1a4e:	1f 93       	push	r17
    1a50:	cf 93       	push	r28
    1a52:	df 93       	push	r29
    1a54:	00 d0       	rcall	.+0      	; 0x1a56 <PromptUserPattern_Task+0xe>
    1a56:	cd b7       	in	r28, 0x3d	; 61
    1a58:	de b7       	in	r29, 0x3e	; 62
	xEventGroupWaitBits(event_handle,BIT_WELCOME,pdFALSE,pdFALSE,portMAX_DELAY);
    1a5a:	0f ef       	ldi	r16, 0xFF	; 255
    1a5c:	1f ef       	ldi	r17, 0xFF	; 255
    1a5e:	20 e0       	ldi	r18, 0x00	; 0
    1a60:	40 e0       	ldi	r20, 0x00	; 0
    1a62:	61 e0       	ldi	r22, 0x01	; 1
    1a64:	70 e0       	ldi	r23, 0x00	; 0
    1a66:	80 91 14 07 	lds	r24, 0x0714	; 0x800714 <event_handle>
    1a6a:	90 91 15 07 	lds	r25, 0x0715	; 0x800715 <event_handle+0x1>
    1a6e:	0e 94 5c 00 	call	0xb8	; 0xb8 <xEventGroupWaitBits>
	unsigned char i = 0;
	TickType_t tick = xTaskGetTickCount();
    1a72:	0e 94 1d 08 	call	0x103a	; 0x103a <xTaskGetTickCount>
    1a76:	9a 83       	std	Y+2, r25	; 0x02
    1a78:	89 83       	std	Y+1, r24	; 0x01
	TickType_t start_tick = xTaskGetTickCount();
    1a7a:	0e 94 1d 08 	call	0x103a	; 0x103a <xTaskGetTickCount>
    1a7e:	8c 01       	movw	r16, r24
	vTaskDelete(NULL);
}

void PromptUserPattern_Task(void * pvParameters){
	xEventGroupWaitBits(event_handle,BIT_WELCOME,pdFALSE,pdFALSE,portMAX_DELAY);
	unsigned char i = 0;
    1a80:	80 e0       	ldi	r24, 0x00	; 0
			if(xEventGroupGetBits(event_handle) & BIT_START){
				i = 2;
				break;
			}
			lcd_clrScreen();
			i = 0;
    1a82:	e1 2c       	mov	r14, r1
				i = 2;
				break;
			}
			lcd_disp_string_xy("Press any key",0,1);
			lcd_disp_string_xy("to continue",1,2);
			i = 1;
    1a84:	ff 24       	eor	r15, r15
    1a86:	f3 94       	inc	r15
	xEventGroupWaitBits(event_handle,BIT_WELCOME,pdFALSE,pdFALSE,portMAX_DELAY);
	unsigned char i = 0;
	TickType_t tick = xTaskGetTickCount();
	TickType_t start_tick = xTaskGetTickCount();
	while(1){		
		if(i == 0){
    1a88:	81 11       	cpse	r24, r1
    1a8a:	36 c0       	rjmp	.+108    	; 0x1af8 <PromptUserPattern_Task+0xb0>
			if(xEventGroupGetBits(event_handle) & BIT_START){
    1a8c:	60 e0       	ldi	r22, 0x00	; 0
    1a8e:	70 e0       	ldi	r23, 0x00	; 0
    1a90:	80 91 14 07 	lds	r24, 0x0714	; 0x800714 <event_handle>
    1a94:	90 91 15 07 	lds	r25, 0x0715	; 0x800715 <event_handle+0x1>
    1a98:	0e 94 e4 00 	call	0x1c8	; 0x1c8 <xEventGroupClearBits>
    1a9c:	84 fd       	sbrc	r24, 4
    1a9e:	61 c0       	rjmp	.+194    	; 0x1b62 <PromptUserPattern_Task+0x11a>
				i = 2;
				break;
			}
			lcd_disp_string_xy("Press any key",0,1);
    1aa0:	41 e0       	ldi	r20, 0x01	; 1
    1aa2:	50 e0       	ldi	r21, 0x00	; 0
    1aa4:	60 e0       	ldi	r22, 0x00	; 0
    1aa6:	70 e0       	ldi	r23, 0x00	; 0
    1aa8:	8f e9       	ldi	r24, 0x9F	; 159
    1aaa:	90 e0       	ldi	r25, 0x00	; 0
    1aac:	0e 94 93 0b 	call	0x1726	; 0x1726 <lcd_disp_string_xy>
			lcd_disp_string_xy("to continue",1,2);
    1ab0:	42 e0       	ldi	r20, 0x02	; 2
    1ab2:	50 e0       	ldi	r21, 0x00	; 0
    1ab4:	61 e0       	ldi	r22, 0x01	; 1
    1ab6:	70 e0       	ldi	r23, 0x00	; 0
    1ab8:	8d ea       	ldi	r24, 0xAD	; 173
    1aba:	90 e0       	ldi	r25, 0x00	; 0
    1abc:	0e 94 93 0b 	call	0x1726	; 0x1726 <lcd_disp_string_xy>
			i = 1;
			if(tick - start_tick + PROMPT_ON_TIME < PROMPT_SECONDS){
    1ac0:	29 81       	ldd	r18, Y+1	; 0x01
    1ac2:	3a 81       	ldd	r19, Y+2	; 0x02
    1ac4:	c9 01       	movw	r24, r18
    1ac6:	8c 50       	subi	r24, 0x0C	; 12
    1ac8:	9e 4f       	sbci	r25, 0xFE	; 254
    1aca:	80 1b       	sub	r24, r16
    1acc:	91 0b       	sbc	r25, r17
    1ace:	80 31       	cpi	r24, 0x10	; 16
    1ad0:	97 42       	sbci	r25, 0x27	; 39
    1ad2:	40 f4       	brcc	.+16     	; 0x1ae4 <PromptUserPattern_Task+0x9c>
				vTaskDelayUntil(&tick,PROMPT_ON_TIME);	
    1ad4:	64 ef       	ldi	r22, 0xF4	; 244
    1ad6:	71 e0       	ldi	r23, 0x01	; 1
    1ad8:	ce 01       	movw	r24, r28
    1ada:	01 96       	adiw	r24, 0x01	; 1
    1adc:	0e 94 69 09 	call	0x12d2	; 0x12d2 <vTaskDelayUntil>
				i = 2;
				break;
			}
			lcd_disp_string_xy("Press any key",0,1);
			lcd_disp_string_xy("to continue",1,2);
			i = 1;
    1ae0:	8f 2d       	mov	r24, r15
    1ae2:	d2 cf       	rjmp	.-92     	; 0x1a88 <PromptUserPattern_Task+0x40>
			if(tick - start_tick + PROMPT_ON_TIME < PROMPT_SECONDS){
				vTaskDelayUntil(&tick,PROMPT_ON_TIME);	
			}else{
				vTaskDelayUntil(&tick,PROMPT_SECONDS-(tick-start_tick));
    1ae4:	b8 01       	movw	r22, r16
    1ae6:	60 5f       	subi	r22, 0xF0	; 240
    1ae8:	78 4d       	sbci	r23, 0xD8	; 216
    1aea:	62 1b       	sub	r22, r18
    1aec:	73 0b       	sbc	r23, r19
    1aee:	ce 01       	movw	r24, r28
    1af0:	01 96       	adiw	r24, 0x01	; 1
    1af2:	0e 94 69 09 	call	0x12d2	; 0x12d2 <vTaskDelayUntil>
				break;
    1af6:	38 c0       	rjmp	.+112    	; 0x1b68 <PromptUserPattern_Task+0x120>
			}
		}else{
			if(xEventGroupGetBits(event_handle) & BIT_START){
    1af8:	60 e0       	ldi	r22, 0x00	; 0
    1afa:	70 e0       	ldi	r23, 0x00	; 0
    1afc:	80 91 14 07 	lds	r24, 0x0714	; 0x800714 <event_handle>
    1b00:	90 91 15 07 	lds	r25, 0x0715	; 0x800715 <event_handle+0x1>
    1b04:	0e 94 e4 00 	call	0x1c8	; 0x1c8 <xEventGroupClearBits>
    1b08:	84 fd       	sbrc	r24, 4
    1b0a:	2b c0       	rjmp	.+86     	; 0x1b62 <PromptUserPattern_Task+0x11a>
				i = 2;
				break;
			}
			lcd_clrScreen();
    1b0c:	0e 94 80 0b 	call	0x1700	; 0x1700 <lcd_clrScreen>
			i = 0;
			if(tick - start_tick + PROMPT_OFF_TIME < PROMPT_SECONDS){
    1b10:	29 81       	ldd	r18, Y+1	; 0x01
    1b12:	3a 81       	ldd	r19, Y+2	; 0x02
    1b14:	c9 01       	movw	r24, r18
    1b16:	86 50       	subi	r24, 0x06	; 6
    1b18:	9f 4f       	sbci	r25, 0xFF	; 255
    1b1a:	80 1b       	sub	r24, r16
    1b1c:	91 0b       	sbc	r25, r17
    1b1e:	80 31       	cpi	r24, 0x10	; 16
    1b20:	97 42       	sbci	r25, 0x27	; 39
    1b22:	40 f4       	brcc	.+16     	; 0x1b34 <PromptUserPattern_Task+0xec>
				vTaskDelayUntil(&tick,PROMPT_OFF_TIME);
    1b24:	6a ef       	ldi	r22, 0xFA	; 250
    1b26:	70 e0       	ldi	r23, 0x00	; 0
    1b28:	ce 01       	movw	r24, r28
    1b2a:	01 96       	adiw	r24, 0x01	; 1
    1b2c:	0e 94 69 09 	call	0x12d2	; 0x12d2 <vTaskDelayUntil>
			if(xEventGroupGetBits(event_handle) & BIT_START){
				i = 2;
				break;
			}
			lcd_clrScreen();
			i = 0;
    1b30:	8e 2d       	mov	r24, r14
    1b32:	aa cf       	rjmp	.-172    	; 0x1a88 <PromptUserPattern_Task+0x40>
			if(tick - start_tick + PROMPT_OFF_TIME < PROMPT_SECONDS){
				vTaskDelayUntil(&tick,PROMPT_OFF_TIME);
			}else{
				vTaskDelayUntil(&tick,PROMPT_SECONDS-(tick-start_tick));
    1b34:	b8 01       	movw	r22, r16
    1b36:	60 5f       	subi	r22, 0xF0	; 240
    1b38:	78 4d       	sbci	r23, 0xD8	; 216
    1b3a:	62 1b       	sub	r22, r18
    1b3c:	73 0b       	sbc	r23, r19
    1b3e:	ce 01       	movw	r24, r28
    1b40:	01 96       	adiw	r24, 0x01	; 1
    1b42:	0e 94 69 09 	call	0x12d2	; 0x12d2 <vTaskDelayUntil>
				break;
    1b46:	10 c0       	rjmp	.+32     	; 0x1b68 <PromptUserPattern_Task+0x120>
	}
	lcd_clrScreen();
	if(i != 2){
		xEventGroupSetBits(event_handle,BIT_LED);
	}
	xEventGroupSetBits(event_handle,BIT_PROMPT);
    1b48:	62 e0       	ldi	r22, 0x02	; 2
    1b4a:	70 e0       	ldi	r23, 0x00	; 0
    1b4c:	80 91 14 07 	lds	r24, 0x0714	; 0x800714 <event_handle>
    1b50:	90 91 15 07 	lds	r25, 0x0715	; 0x800715 <event_handle+0x1>
    1b54:	0e 94 f3 00 	call	0x1e6	; 0x1e6 <xEventGroupSetBits>
	vTaskDelete(NULL);
    1b58:	80 e0       	ldi	r24, 0x00	; 0
    1b5a:	90 e0       	ldi	r25, 0x00	; 0
    1b5c:	0e 94 98 07 	call	0xf30	; 0xf30 <vTaskDelete>
}
    1b60:	0e c0       	rjmp	.+28     	; 0x1b7e <PromptUserPattern_Task+0x136>
				vTaskDelayUntil(&tick,PROMPT_SECONDS-(tick-start_tick));
				break;
			}
		}
	}
	lcd_clrScreen();
    1b62:	0e 94 80 0b 	call	0x1700	; 0x1700 <lcd_clrScreen>
    1b66:	f0 cf       	rjmp	.-32     	; 0x1b48 <PromptUserPattern_Task+0x100>
    1b68:	0e 94 80 0b 	call	0x1700	; 0x1700 <lcd_clrScreen>
	if(i != 2){
		xEventGroupSetBits(event_handle,BIT_LED);
    1b6c:	68 e0       	ldi	r22, 0x08	; 8
    1b6e:	70 e0       	ldi	r23, 0x00	; 0
    1b70:	80 91 14 07 	lds	r24, 0x0714	; 0x800714 <event_handle>
    1b74:	90 91 15 07 	lds	r25, 0x0715	; 0x800715 <event_handle+0x1>
    1b78:	0e 94 f3 00 	call	0x1e6	; 0x1e6 <xEventGroupSetBits>
    1b7c:	e5 cf       	rjmp	.-54     	; 0x1b48 <PromptUserPattern_Task+0x100>
	}
	xEventGroupSetBits(event_handle,BIT_PROMPT);
	vTaskDelete(NULL);
}
    1b7e:	0f 90       	pop	r0
    1b80:	0f 90       	pop	r0
    1b82:	df 91       	pop	r29
    1b84:	cf 91       	pop	r28
    1b86:	1f 91       	pop	r17
    1b88:	0f 91       	pop	r16
    1b8a:	ff 90       	pop	r15
    1b8c:	ef 90       	pop	r14
    1b8e:	08 95       	ret

00001b90 <LCD_Task>:
		vTaskDelayUntil(&tick,20);
	}
	
}

void LCD_Task(void * pvParameters){
    1b90:	ec 01       	movw	r28, r24
	#if FAST_TEST == 0
	xEventGroupWaitBits(event_handle,BIT_WELCOME,pdFALSE,pdFALSE,portMAX_DELAY);
    1b92:	0f ef       	ldi	r16, 0xFF	; 255
    1b94:	1f ef       	ldi	r17, 0xFF	; 255
    1b96:	20 e0       	ldi	r18, 0x00	; 0
    1b98:	40 e0       	ldi	r20, 0x00	; 0
    1b9a:	61 e0       	ldi	r22, 0x01	; 1
    1b9c:	70 e0       	ldi	r23, 0x00	; 0
    1b9e:	80 91 14 07 	lds	r24, 0x0714	; 0x800714 <event_handle>
    1ba2:	90 91 15 07 	lds	r25, 0x0715	; 0x800715 <event_handle+0x1>
    1ba6:	0e 94 5c 00 	call	0xb8	; 0xb8 <xEventGroupWaitBits>
	xEventGroupWaitBits(event_handle,BIT_PROMPT,pdFALSE,pdFALSE,portMAX_DELAY);
    1baa:	20 e0       	ldi	r18, 0x00	; 0
    1bac:	40 e0       	ldi	r20, 0x00	; 0
    1bae:	62 e0       	ldi	r22, 0x02	; 2
    1bb0:	70 e0       	ldi	r23, 0x00	; 0
    1bb2:	80 91 14 07 	lds	r24, 0x0714	; 0x800714 <event_handle>
    1bb6:	90 91 15 07 	lds	r25, 0x0715	; 0x800715 <event_handle+0x1>
    1bba:	0e 94 5c 00 	call	0xb8	; 0xb8 <xEventGroupWaitBits>
	#endif
	CALC_DISP* struct_ptr = pvParameters;
	char newNum = 0;
    1bbe:	f1 2c       	mov	r15, r1
	while(1){
		xEventGroupWaitBits(event_handle,BIT_CALC,pdTRUE,pdFALSE,portMAX_DELAY);
    1bc0:	0f ef       	ldi	r16, 0xFF	; 255
    1bc2:	1f ef       	ldi	r17, 0xFF	; 255
    1bc4:	20 e0       	ldi	r18, 0x00	; 0
    1bc6:	41 e0       	ldi	r20, 0x01	; 1
    1bc8:	64 e0       	ldi	r22, 0x04	; 4
    1bca:	70 e0       	ldi	r23, 0x00	; 0
    1bcc:	80 91 14 07 	lds	r24, 0x0714	; 0x800714 <event_handle>
    1bd0:	90 91 15 07 	lds	r25, 0x0715	; 0x800715 <event_handle+0x1>
    1bd4:	0e 94 5c 00 	call	0xb8	; 0xb8 <xEventGroupWaitBits>
		if(struct_ptr->lastDigit != 0){
    1bd8:	88 81       	ld	r24, Y
    1bda:	88 23       	and	r24, r24
    1bdc:	79 f0       	breq	.+30     	; 0x1bfc <LCD_Task+0x6c>
			if(newNum == 1 || (struct_ptr->CurrentNumber == 0)){
    1bde:	81 e0       	ldi	r24, 0x01	; 1
    1be0:	f8 16       	cp	r15, r24
    1be2:	21 f0       	breq	.+8      	; 0x1bec <LCD_Task+0x5c>
    1be4:	8b 81       	ldd	r24, Y+3	; 0x03
    1be6:	9c 81       	ldd	r25, Y+4	; 0x04
    1be8:	89 2b       	or	r24, r25
    1bea:	11 f4       	brne	.+4      	; 0x1bf0 <LCD_Task+0x60>
				lcd_clrScreen();
    1bec:	0e 94 80 0b 	call	0x1700	; 0x1700 <lcd_clrScreen>
			}
			lcd_displayChar(struct_ptr->lastDigit);
    1bf0:	88 81       	ld	r24, Y
    1bf2:	0e 94 4e 0b 	call	0x169c	; 0x169c <lcd_displayChar>
			struct_ptr->lastDigit = 0;
    1bf6:	18 82       	st	Y, r1
			newNum = 0;
    1bf8:	f1 2c       	mov	r15, r1
    1bfa:	e2 cf       	rjmp	.-60     	; 0x1bc0 <LCD_Task+0x30>
		}else{
			lcd_clrScreen();
    1bfc:	0e 94 80 0b 	call	0x1700	; 0x1700 <lcd_clrScreen>
			lcd_disp_number(struct_ptr->display);
    1c00:	89 81       	ldd	r24, Y+1	; 0x01
    1c02:	9a 81       	ldd	r25, Y+2	; 0x02
    1c04:	0e 94 a0 0b 	call	0x1740	; 0x1740 <lcd_disp_number>
			newNum = 1;
    1c08:	ff 24       	eor	r15, r15
    1c0a:	f3 94       	inc	r15
    1c0c:	d9 cf       	rjmp	.-78     	; 0x1bc0 <LCD_Task+0x30>

00001c0e <LED_Task>:
		}
	}
}

void LED_Task(void * pvParameters){
    1c0e:	cf 93       	push	r28
    1c10:	df 93       	push	r29
    1c12:	00 d0       	rcall	.+0      	; 0x1c14 <LED_Task+0x6>
    1c14:	cd b7       	in	r28, 0x3d	; 61
    1c16:	de b7       	in	r29, 0x3e	; 62
	#if FAST_TEST == 0
	xEventGroupWaitBits(event_handle,BIT_WELCOME,pdFALSE,pdFALSE,portMAX_DELAY);
    1c18:	0f ef       	ldi	r16, 0xFF	; 255
    1c1a:	1f ef       	ldi	r17, 0xFF	; 255
    1c1c:	20 e0       	ldi	r18, 0x00	; 0
    1c1e:	40 e0       	ldi	r20, 0x00	; 0
    1c20:	61 e0       	ldi	r22, 0x01	; 1
    1c22:	70 e0       	ldi	r23, 0x00	; 0
    1c24:	80 91 14 07 	lds	r24, 0x0714	; 0x800714 <event_handle>
    1c28:	90 91 15 07 	lds	r25, 0x0715	; 0x800715 <event_handle+0x1>
    1c2c:	0e 94 5c 00 	call	0xb8	; 0xb8 <xEventGroupWaitBits>
	xEventGroupWaitBits(event_handle,BIT_PROMPT,pdFALSE,pdFALSE,portMAX_DELAY);
    1c30:	20 e0       	ldi	r18, 0x00	; 0
    1c32:	40 e0       	ldi	r20, 0x00	; 0
    1c34:	62 e0       	ldi	r22, 0x02	; 2
    1c36:	70 e0       	ldi	r23, 0x00	; 0
    1c38:	80 91 14 07 	lds	r24, 0x0714	; 0x800714 <event_handle>
    1c3c:	90 91 15 07 	lds	r25, 0x0715	; 0x800715 <event_handle+0x1>
    1c40:	0e 94 5c 00 	call	0xb8	; 0xb8 <xEventGroupWaitBits>
	#endif
	STAGE stage = RISING_STAGE;
	char duty_cycle = 0;
	TickType_t tick = xTaskGetTickCount();
    1c44:	0e 94 1d 08 	call	0x103a	; 0x103a <xTaskGetTickCount>
    1c48:	9a 83       	std	Y+2, r25	; 0x02
    1c4a:	89 83       	std	Y+1, r24	; 0x01
	#if FAST_TEST == 0
	xEventGroupWaitBits(event_handle,BIT_WELCOME,pdFALSE,pdFALSE,portMAX_DELAY);
	xEventGroupWaitBits(event_handle,BIT_PROMPT,pdFALSE,pdFALSE,portMAX_DELAY);
	#endif
	STAGE stage = RISING_STAGE;
	char duty_cycle = 0;
    1c4c:	e1 2c       	mov	r14, r1
void LED_Task(void * pvParameters){
	#if FAST_TEST == 0
	xEventGroupWaitBits(event_handle,BIT_WELCOME,pdFALSE,pdFALSE,portMAX_DELAY);
	xEventGroupWaitBits(event_handle,BIT_PROMPT,pdFALSE,pdFALSE,portMAX_DELAY);
	#endif
	STAGE stage = RISING_STAGE;
    1c4e:	ff 24       	eor	r15, r15
    1c50:	f3 94       	inc	r15
			break;
		case FALLING_STAGE:
			duty_cycle -= 10;
			TIM2_SetDutyCycle(duty_cycle);
			if(duty_cycle == 0){
				stage = LOW_STAGE;
    1c52:	68 94       	set
    1c54:	bb 24       	eor	r11, r11
    1c56:	b2 f8       	bld	r11, 2
			}
			vTaskDelayUntil(&tick,25);
			break;
		case LOW_STAGE:
			vTaskDelayUntil(&tick,250);
			stage = RISING_STAGE;
    1c58:	cc 24       	eor	r12, r12
    1c5a:	c3 94       	inc	r12
		switch(stage){
		case RISING_STAGE:
			duty_cycle += 10;
			TIM2_SetDutyCycle(duty_cycle);
			if(duty_cycle == 100){
				stage = HIGH_STAGE;
    1c5c:	68 94       	set
    1c5e:	aa 24       	eor	r10, r10
    1c60:	a1 f8       	bld	r10, 1
			}
			vTaskDelayUntil(&tick,25);
			break;
		case HIGH_STAGE:
			vTaskDelayUntil(&tick,250);
			stage = FALLING_STAGE;
    1c62:	0f 2e       	mov	r0, r31
    1c64:	f3 e0       	ldi	r31, 0x03	; 3
    1c66:	df 2e       	mov	r13, r31
    1c68:	f0 2d       	mov	r31, r0
	#endif
	STAGE stage = RISING_STAGE;
	char duty_cycle = 0;
	TickType_t tick = xTaskGetTickCount();
	while(1){
		xEventGroupWaitBits(event_handle,BIT_LED,pdFALSE,pdFALSE,portMAX_DELAY);
    1c6a:	0f ef       	ldi	r16, 0xFF	; 255
    1c6c:	1f ef       	ldi	r17, 0xFF	; 255
    1c6e:	20 e0       	ldi	r18, 0x00	; 0
    1c70:	40 e0       	ldi	r20, 0x00	; 0
    1c72:	68 e0       	ldi	r22, 0x08	; 8
    1c74:	70 e0       	ldi	r23, 0x00	; 0
    1c76:	80 91 14 07 	lds	r24, 0x0714	; 0x800714 <event_handle>
    1c7a:	90 91 15 07 	lds	r25, 0x0715	; 0x800715 <event_handle+0x1>
    1c7e:	0e 94 5c 00 	call	0xb8	; 0xb8 <xEventGroupWaitBits>
		switch(stage){
    1c82:	82 e0       	ldi	r24, 0x02	; 2
    1c84:	f8 16       	cp	r15, r24
    1c86:	e9 f0       	breq	.+58     	; 0x1cc2 <LED_Task+0xb4>
    1c88:	8f 15       	cp	r24, r15
    1c8a:	20 f0       	brcs	.+8      	; 0x1c94 <LED_Task+0x86>
    1c8c:	81 e0       	ldi	r24, 0x01	; 1
    1c8e:	f8 16       	cp	r15, r24
    1c90:	41 f0       	breq	.+16     	; 0x1ca2 <LED_Task+0x94>
    1c92:	eb cf       	rjmp	.-42     	; 0x1c6a <LED_Task+0x5c>
    1c94:	83 e0       	ldi	r24, 0x03	; 3
    1c96:	f8 16       	cp	r15, r24
    1c98:	e1 f0       	breq	.+56     	; 0x1cd2 <LED_Task+0xc4>
    1c9a:	84 e0       	ldi	r24, 0x04	; 4
    1c9c:	f8 16       	cp	r15, r24
    1c9e:	41 f1       	breq	.+80     	; 0x1cf0 <LED_Task+0xe2>
    1ca0:	e4 cf       	rjmp	.-56     	; 0x1c6a <LED_Task+0x5c>
		case RISING_STAGE:
			duty_cycle += 10;
    1ca2:	8a e0       	ldi	r24, 0x0A	; 10
    1ca4:	e8 0e       	add	r14, r24
			TIM2_SetDutyCycle(duty_cycle);
    1ca6:	8e 2d       	mov	r24, r14
    1ca8:	0e 94 bb 11 	call	0x2376	; 0x2376 <TIM2_SetDutyCycle>
			if(duty_cycle == 100){
    1cac:	84 e6       	ldi	r24, 0x64	; 100
    1cae:	e8 12       	cpse	r14, r24
    1cb0:	01 c0       	rjmp	.+2      	; 0x1cb4 <LED_Task+0xa6>
				stage = HIGH_STAGE;
    1cb2:	fa 2c       	mov	r15, r10
			}
			vTaskDelayUntil(&tick,25);
    1cb4:	69 e1       	ldi	r22, 0x19	; 25
    1cb6:	70 e0       	ldi	r23, 0x00	; 0
    1cb8:	ce 01       	movw	r24, r28
    1cba:	01 96       	adiw	r24, 0x01	; 1
    1cbc:	0e 94 69 09 	call	0x12d2	; 0x12d2 <vTaskDelayUntil>
			break;
    1cc0:	d4 cf       	rjmp	.-88     	; 0x1c6a <LED_Task+0x5c>
		case HIGH_STAGE:
			vTaskDelayUntil(&tick,250);
    1cc2:	6a ef       	ldi	r22, 0xFA	; 250
    1cc4:	70 e0       	ldi	r23, 0x00	; 0
    1cc6:	ce 01       	movw	r24, r28
    1cc8:	01 96       	adiw	r24, 0x01	; 1
    1cca:	0e 94 69 09 	call	0x12d2	; 0x12d2 <vTaskDelayUntil>
			stage = FALLING_STAGE;
    1cce:	fd 2c       	mov	r15, r13
			break;
    1cd0:	cc cf       	rjmp	.-104    	; 0x1c6a <LED_Task+0x5c>
		case FALLING_STAGE:
			duty_cycle -= 10;
    1cd2:	86 ef       	ldi	r24, 0xF6	; 246
    1cd4:	e8 0e       	add	r14, r24
			TIM2_SetDutyCycle(duty_cycle);
    1cd6:	8e 2d       	mov	r24, r14
    1cd8:	0e 94 bb 11 	call	0x2376	; 0x2376 <TIM2_SetDutyCycle>
			if(duty_cycle == 0){
    1cdc:	e1 10       	cpse	r14, r1
    1cde:	01 c0       	rjmp	.+2      	; 0x1ce2 <LED_Task+0xd4>
				stage = LOW_STAGE;
    1ce0:	fb 2c       	mov	r15, r11
			}
			vTaskDelayUntil(&tick,25);
    1ce2:	69 e1       	ldi	r22, 0x19	; 25
    1ce4:	70 e0       	ldi	r23, 0x00	; 0
    1ce6:	ce 01       	movw	r24, r28
    1ce8:	01 96       	adiw	r24, 0x01	; 1
    1cea:	0e 94 69 09 	call	0x12d2	; 0x12d2 <vTaskDelayUntil>
			break;
    1cee:	bd cf       	rjmp	.-134    	; 0x1c6a <LED_Task+0x5c>
		case LOW_STAGE:
			vTaskDelayUntil(&tick,250);
    1cf0:	6a ef       	ldi	r22, 0xFA	; 250
    1cf2:	70 e0       	ldi	r23, 0x00	; 0
    1cf4:	ce 01       	movw	r24, r28
    1cf6:	01 96       	adiw	r24, 0x01	; 1
    1cf8:	0e 94 69 09 	call	0x12d2	; 0x12d2 <vTaskDelayUntil>
			stage = RISING_STAGE;
    1cfc:	fc 2c       	mov	r15, r12
			break;	
    1cfe:	b5 cf       	rjmp	.-150    	; 0x1c6a <LED_Task+0x5c>

00001d00 <SW_Task>:
		}
	}
}

void SW_Task(void * pvParameters){
    1d00:	cf 93       	push	r28
    1d02:	df 93       	push	r29
    1d04:	00 d0       	rcall	.+0      	; 0x1d06 <SW_Task+0x6>
    1d06:	1f 92       	push	r1
    1d08:	cd b7       	in	r28, 0x3d	; 61
    1d0a:	de b7       	in	r29, 0x3e	; 62
	#if FAST_TEST == 0
	xEventGroupWaitBits(event_handle,BIT_WELCOME,pdFALSE,pdFALSE,portMAX_DELAY);
    1d0c:	0f ef       	ldi	r16, 0xFF	; 255
    1d0e:	1f ef       	ldi	r17, 0xFF	; 255
    1d10:	20 e0       	ldi	r18, 0x00	; 0
    1d12:	40 e0       	ldi	r20, 0x00	; 0
    1d14:	61 e0       	ldi	r22, 0x01	; 1
    1d16:	70 e0       	ldi	r23, 0x00	; 0
    1d18:	80 91 14 07 	lds	r24, 0x0714	; 0x800714 <event_handle>
    1d1c:	90 91 15 07 	lds	r25, 0x0715	; 0x800715 <event_handle+0x1>
    1d20:	0e 94 5c 00 	call	0xb8	; 0xb8 <xEventGroupWaitBits>
	xEventGroupWaitBits(event_handle,BIT_PROMPT,pdFALSE,pdFALSE,portMAX_DELAY);
    1d24:	20 e0       	ldi	r18, 0x00	; 0
    1d26:	40 e0       	ldi	r20, 0x00	; 0
    1d28:	62 e0       	ldi	r22, 0x02	; 2
    1d2a:	70 e0       	ldi	r23, 0x00	; 0
    1d2c:	80 91 14 07 	lds	r24, 0x0714	; 0x800714 <event_handle>
    1d30:	90 91 15 07 	lds	r25, 0x0715	; 0x800715 <event_handle+0x1>
    1d34:	0e 94 5c 00 	call	0xb8	; 0xb8 <xEventGroupWaitBits>
	#endif
	char new = 0, old = 0, less = LESS_THAN_3;
    1d38:	83 e6       	ldi	r24, 0x63	; 99
    1d3a:	89 83       	std	Y+1, r24	; 0x01
	TickType_t tick = xTaskGetTickCount();
    1d3c:	0e 94 1d 08 	call	0x103a	; 0x103a <xTaskGetTickCount>
    1d40:	9b 83       	std	Y+3, r25	; 0x03
    1d42:	8a 83       	std	Y+2, r24	; 0x02
	TickType_t begin = xTaskGetTickCount();
    1d44:	0e 94 1d 08 	call	0x103a	; 0x103a <xTaskGetTickCount>
    1d48:	5c 01       	movw	r10, r24
	TickType_t count = 0;
    1d4a:	00 e0       	ldi	r16, 0x00	; 0
    1d4c:	10 e0       	ldi	r17, 0x00	; 0
void SW_Task(void * pvParameters){
	#if FAST_TEST == 0
	xEventGroupWaitBits(event_handle,BIT_WELCOME,pdFALSE,pdFALSE,portMAX_DELAY);
	xEventGroupWaitBits(event_handle,BIT_PROMPT,pdFALSE,pdFALSE,portMAX_DELAY);
	#endif
	char new = 0, old = 0, less = LESS_THAN_3;
    1d4e:	f1 2c       	mov	r15, r1
				count = xTaskGetTickCount() - begin;
			}
		}else{ //Button Released
			old = 1;
			new = 1;
			count = 0;
    1d50:	91 2c       	mov	r9, r1
    1d52:	c1 2c       	mov	r12, r1
			}else{
				count = xTaskGetTickCount() - begin;
			}
		}else{ //Button Released
			old = 1;
			new = 1;
    1d54:	dd 24       	eor	r13, r13
    1d56:	d3 94       	inc	r13
	char new = 0, old = 0, less = LESS_THAN_3;
	TickType_t tick = xTaskGetTickCount();
	TickType_t begin = xTaskGetTickCount();
	TickType_t count = 0;
	while(1){
		new = (READ_SW_PIN);
    1d58:	80 b3       	in	r24, 0x10	; 16
		if(new == 0){ //Button Pressed
    1d5a:	98 2f       	mov	r25, r24
    1d5c:	91 70       	andi	r25, 0x01	; 1
    1d5e:	e9 2e       	mov	r14, r25
    1d60:	80 fd       	sbrc	r24, 0
    1d62:	2a c0       	rjmp	.+84     	; 0x1db8 <SW_Task+0xb8>
			if(old != new){
    1d64:	ff 20       	and	r15, r15
    1d66:	21 f0       	breq	.+8      	; 0x1d70 <SW_Task+0x70>
				old = new;
				begin = xTaskGetTickCount();
    1d68:	0e 94 1d 08 	call	0x103a	; 0x103a <xTaskGetTickCount>
    1d6c:	5c 01       	movw	r10, r24
    1d6e:	30 c0       	rjmp	.+96     	; 0x1dd0 <SW_Task+0xd0>
			}else{
				count = xTaskGetTickCount() - begin;
    1d70:	0e 94 1d 08 	call	0x103a	; 0x103a <xTaskGetTickCount>
    1d74:	8c 01       	movw	r16, r24
    1d76:	0a 19       	sub	r16, r10
    1d78:	1b 09       	sbc	r17, r11
    1d7a:	2a c0       	rjmp	.+84     	; 0x1dd0 <SW_Task+0xd0>
			new = 1;
			count = 0;
		}
		if(new == 0){
			if(count < 3000){
				xQueueSend(queue_handle,&less,10);
    1d7c:	20 e0       	ldi	r18, 0x00	; 0
    1d7e:	4a e0       	ldi	r20, 0x0A	; 10
    1d80:	50 e0       	ldi	r21, 0x00	; 0
    1d82:	be 01       	movw	r22, r28
    1d84:	6f 5f       	subi	r22, 0xFF	; 255
    1d86:	7f 4f       	sbci	r23, 0xFF	; 255
    1d88:	80 91 0c 07 	lds	r24, 0x070C	; 0x80070c <queue_handle>
    1d8c:	90 91 0d 07 	lds	r25, 0x070D	; 0x80070d <queue_handle+0x1>
    1d90:	0e 94 9e 04 	call	0x93c	; 0x93c <xQueueGenericSend>
    1d94:	fe 2c       	mov	r15, r14
    1d96:	15 c0       	rjmp	.+42     	; 0x1dc2 <SW_Task+0xc2>
			}else if(count > 3000){
    1d98:	09 3b       	cpi	r16, 0xB9	; 185
    1d9a:	8b e0       	ldi	r24, 0x0B	; 11
    1d9c:	18 07       	cpc	r17, r24
    1d9e:	80 f0       	brcs	.+32     	; 0x1dc0 <SW_Task+0xc0>
				lcd_clrScreen(); //BIG VIOLATION
    1da0:	0e 94 80 0b 	call	0x1700	; 0x1700 <lcd_clrScreen>
				xEventGroupSetBits(event_handle,BIT_LED);
    1da4:	68 e0       	ldi	r22, 0x08	; 8
    1da6:	70 e0       	ldi	r23, 0x00	; 0
    1da8:	80 91 14 07 	lds	r24, 0x0714	; 0x800714 <event_handle>
    1dac:	90 91 15 07 	lds	r25, 0x0715	; 0x800715 <event_handle+0x1>
    1db0:	0e 94 f3 00 	call	0x1e6	; 0x1e6 <xEventGroupSetBits>
    1db4:	fe 2c       	mov	r15, r14
    1db6:	05 c0       	rjmp	.+10     	; 0x1dc2 <SW_Task+0xc2>
				count = xTaskGetTickCount() - begin;
			}
		}else{ //Button Released
			old = 1;
			new = 1;
			count = 0;
    1db8:	09 2d       	mov	r16, r9
    1dba:	1c 2d       	mov	r17, r12
			}else{
				count = xTaskGetTickCount() - begin;
			}
		}else{ //Button Released
			old = 1;
			new = 1;
    1dbc:	fd 2c       	mov	r15, r13
    1dbe:	01 c0       	rjmp	.+2      	; 0x1dc2 <SW_Task+0xc2>
    1dc0:	fe 2c       	mov	r15, r14
			}else if(count > 3000){
				lcd_clrScreen(); //BIG VIOLATION
				xEventGroupSetBits(event_handle,BIT_LED);
			}
		}
		vTaskDelayUntil(&tick,20);
    1dc2:	64 e1       	ldi	r22, 0x14	; 20
    1dc4:	70 e0       	ldi	r23, 0x00	; 0
    1dc6:	ce 01       	movw	r24, r28
    1dc8:	02 96       	adiw	r24, 0x02	; 2
    1dca:	0e 94 69 09 	call	0x12d2	; 0x12d2 <vTaskDelayUntil>
	}
    1dce:	c4 cf       	rjmp	.-120    	; 0x1d58 <SW_Task+0x58>
			old = 1;
			new = 1;
			count = 0;
		}
		if(new == 0){
			if(count < 3000){
    1dd0:	08 3b       	cpi	r16, 0xB8	; 184
    1dd2:	9b e0       	ldi	r25, 0x0B	; 11
    1dd4:	19 07       	cpc	r17, r25
    1dd6:	00 f7       	brcc	.-64     	; 0x1d98 <SW_Task+0x98>
    1dd8:	d1 cf       	rjmp	.-94     	; 0x1d7c <SW_Task+0x7c>

00001dda <CALC_Task>:
		vTaskDelayUntil(&tick,20);
	}
	
}

void CALC_Task(void * pvParameters){
    1dda:	cf 93       	push	r28
    1ddc:	df 93       	push	r29
    1dde:	1f 92       	push	r1
    1de0:	cd b7       	in	r28, 0x3d	; 61
    1de2:	de b7       	in	r29, 0x3e	; 62
    1de4:	7c 01       	movw	r14, r24
	#if FAST_TEST == 0
	xEventGroupWaitBits(event_handle,BIT_WELCOME,pdFALSE,pdFALSE,portMAX_DELAY);
    1de6:	0f ef       	ldi	r16, 0xFF	; 255
    1de8:	1f ef       	ldi	r17, 0xFF	; 255
    1dea:	20 e0       	ldi	r18, 0x00	; 0
    1dec:	40 e0       	ldi	r20, 0x00	; 0
    1dee:	61 e0       	ldi	r22, 0x01	; 1
    1df0:	70 e0       	ldi	r23, 0x00	; 0
    1df2:	80 91 14 07 	lds	r24, 0x0714	; 0x800714 <event_handle>
    1df6:	90 91 15 07 	lds	r25, 0x0715	; 0x800715 <event_handle+0x1>
    1dfa:	0e 94 5c 00 	call	0xb8	; 0xb8 <xEventGroupWaitBits>
	xEventGroupWaitBits(event_handle,BIT_PROMPT,pdFALSE,pdFALSE,portMAX_DELAY);
    1dfe:	20 e0       	ldi	r18, 0x00	; 0
    1e00:	40 e0       	ldi	r20, 0x00	; 0
    1e02:	62 e0       	ldi	r22, 0x02	; 2
    1e04:	70 e0       	ldi	r23, 0x00	; 0
    1e06:	80 91 14 07 	lds	r24, 0x0714	; 0x800714 <event_handle>
    1e0a:	90 91 15 07 	lds	r25, 0x0715	; 0x800715 <event_handle+0x1>
    1e0e:	0e 94 5c 00 	call	0xb8	; 0xb8 <xEventGroupWaitBits>
	#endif
	char receive = 0;
    1e12:	19 82       	std	Y+1, r1	; 0x01
	char last_receive = 0;
	char newCalculation = 0;
	CALC_DISP* struct_ptr = pvParameters;
	struct_ptr->lastDigit = 0;
    1e14:	f7 01       	movw	r30, r14
    1e16:	10 82       	st	Z, r1
	struct_ptr->LastOperation = ADD;
    1e18:	8c e0       	ldi	r24, 0x0C	; 12
    1e1a:	87 83       	std	Z+7, r24	; 0x07
	struct_ptr->CurrentNumber = 0;
    1e1c:	14 82       	std	Z+4, r1	; 0x04
    1e1e:	13 82       	std	Z+3, r1	; 0x03
	struct_ptr->Answer = 0;
    1e20:	16 82       	std	Z+6, r1	; 0x06
    1e22:	15 82       	std	Z+5, r1	; 0x05
	struct_ptr->display = 0;
    1e24:	12 82       	std	Z+2, r1	; 0x02
    1e26:	11 82       	std	Z+1, r1	; 0x01
	xEventGroupWaitBits(event_handle,BIT_WELCOME,pdFALSE,pdFALSE,portMAX_DELAY);
	xEventGroupWaitBits(event_handle,BIT_PROMPT,pdFALSE,pdFALSE,portMAX_DELAY);
	#endif
	char receive = 0;
	char last_receive = 0;
	char newCalculation = 0;
    1e28:	d1 2c       	mov	r13, r1
	#if FAST_TEST == 0
	xEventGroupWaitBits(event_handle,BIT_WELCOME,pdFALSE,pdFALSE,portMAX_DELAY);
	xEventGroupWaitBits(event_handle,BIT_PROMPT,pdFALSE,pdFALSE,portMAX_DELAY);
	#endif
	char receive = 0;
	char last_receive = 0;
    1e2a:	00 e0       	ldi	r16, 0x00	; 0
			
		}else{ //Switch
			if(last_receive != receive){
				struct_ptr->CurrentNumber = 0;
				struct_ptr->display = 0;
				struct_ptr->lastDigit = '0';
    1e2c:	0f 2e       	mov	r0, r31
    1e2e:	f0 e3       	ldi	r31, 0x30	; 48
    1e30:	af 2e       	mov	r10, r31
    1e32:	f0 2d       	mov	r31, r0
				struct_ptr->lastDigit = receive;
				last_receive = 0;
				break;
			}
			if(newCalculation == 1){
				struct_ptr->LastOperation = ADD;
    1e34:	0f 2e       	mov	r0, r31
    1e36:	fc e0       	ldi	r31, 0x0C	; 12
    1e38:	bf 2e       	mov	r11, r31
    1e3a:	f0 2d       	mov	r31, r0
				struct_ptr->Answer = 0;
				newCalculation = 0;	
    1e3c:	c1 2c       	mov	r12, r1
				struct_ptr->display = struct_ptr->Answer;
				last_receive = receive;
				break;
			default:
				if(receive == ZERO) receive = '0';
				if(struct_ptr->LastOperation == EQUAL) newCalculation = 1;
    1e3e:	55 24       	eor	r5, r5
    1e40:	53 94       	inc	r5
				case DIV:
					struct_ptr->Answer /= struct_ptr->CurrentNumber;
					break;
				}
				struct_ptr->CurrentNumber = 0;
				struct_ptr->LastOperation = MUL;
    1e42:	0f 2e       	mov	r0, r31
    1e44:	fe e0       	ldi	r31, 0x0E	; 14
    1e46:	6f 2e       	mov	r6, r31
    1e48:	f0 2d       	mov	r31, r0
				case DIV:
					struct_ptr->Answer /= struct_ptr->CurrentNumber;
					break;
				}
				struct_ptr->CurrentNumber = 0;
				struct_ptr->LastOperation = SUB;
    1e4a:	0f 2e       	mov	r0, r31
    1e4c:	fd e0       	ldi	r31, 0x0D	; 13
    1e4e:	7f 2e       	mov	r7, r31
    1e50:	f0 2d       	mov	r31, r0
					case DIV:
				struct_ptr->Answer /= struct_ptr->CurrentNumber;
					break;
				}
				struct_ptr->CurrentNumber = 0;
				struct_ptr->LastOperation = DIV;
    1e52:	0f 2e       	mov	r0, r31
    1e54:	ff e0       	ldi	r31, 0x0F	; 15
    1e56:	8f 2e       	mov	r8, r31
    1e58:	f0 2d       	mov	r31, r0
				case DIV:
					struct_ptr->Answer /= struct_ptr->CurrentNumber;
					break;
				}
				struct_ptr->CurrentNumber = 0;
				struct_ptr->LastOperation = EQUAL;
    1e5a:	0f 2e       	mov	r0, r31
    1e5c:	f3 e0       	ldi	r31, 0x03	; 3
    1e5e:	9f 2e       	mov	r9, r31
    1e60:	f0 2d       	mov	r31, r0
	struct_ptr->CurrentNumber = 0;
	struct_ptr->Answer = 0;
	struct_ptr->display = 0;
	
	while(1){
		xQueueReceive(queue_handle,&receive,portMAX_DELAY);
    1e62:	4f ef       	ldi	r20, 0xFF	; 255
    1e64:	5f ef       	ldi	r21, 0xFF	; 255
    1e66:	be 01       	movw	r22, r28
    1e68:	6f 5f       	subi	r22, 0xFF	; 255
    1e6a:	7f 4f       	sbci	r23, 0xFF	; 255
    1e6c:	80 91 0c 07 	lds	r24, 0x070C	; 0x80070c <queue_handle>
    1e70:	90 91 0d 07 	lds	r25, 0x070D	; 0x80070d <queue_handle+0x1>
    1e74:	0e 94 3f 05 	call	0xa7e	; 0xa7e <xQueueReceive>
		if((last_receive >= ADD && last_receive <= DIV) && (receive >= ADD && receive <= DIV)){
    1e78:	84 ef       	ldi	r24, 0xF4	; 244
    1e7a:	80 0f       	add	r24, r16
    1e7c:	84 30       	cpi	r24, 0x04	; 4
    1e7e:	48 f4       	brcc	.+18     	; 0x1e92 <CALC_Task+0xb8>
    1e80:	89 81       	ldd	r24, Y+1	; 0x01
    1e82:	94 ef       	ldi	r25, 0xF4	; 244
    1e84:	98 0f       	add	r25, r24
    1e86:	94 30       	cpi	r25, 0x04	; 4
    1e88:	20 f4       	brcc	.+8      	; 0x1e92 <CALC_Task+0xb8>
			struct_ptr->LastOperation = receive;
    1e8a:	f7 01       	movw	r30, r14
    1e8c:	87 83       	std	Z+7, r24	; 0x07
			last_receive = receive;
    1e8e:	08 2f       	mov	r16, r24
    1e90:	af c1       	rjmp	.+862    	; 0x21f0 <CALC_Task+0x416>
		}
		else if(receive != LESS_THAN_3){ //Keypad
    1e92:	19 81       	ldd	r17, Y+1	; 0x01
    1e94:	13 36       	cpi	r17, 0x63	; 99
    1e96:	09 f4       	brne	.+2      	; 0x1e9a <CALC_Task+0xc0>
    1e98:	9a c1       	rjmp	.+820    	; 0x21ce <CALC_Task+0x3f4>
			switch(receive){
    1e9a:	1c 30       	cpi	r17, 0x0C	; 12
    1e9c:	89 f0       	breq	.+34     	; 0x1ec0 <CALC_Task+0xe6>
    1e9e:	38 f4       	brcc	.+14     	; 0x1eae <CALC_Task+0xd4>
    1ea0:	11 30       	cpi	r17, 0x01	; 1
    1ea2:	09 f4       	brne	.+2      	; 0x1ea6 <CALC_Task+0xcc>
    1ea4:	19 c1       	rjmp	.+562    	; 0x20d8 <CALC_Task+0x2fe>
    1ea6:	13 30       	cpi	r17, 0x03	; 3
    1ea8:	09 f4       	brne	.+2      	; 0x1eac <CALC_Task+0xd2>
    1eaa:	1d c1       	rjmp	.+570    	; 0x20e6 <CALC_Task+0x30c>
    1eac:	5f c1       	rjmp	.+702    	; 0x216c <CALC_Task+0x392>
    1eae:	1e 30       	cpi	r17, 0x0E	; 14
    1eb0:	09 f4       	brne	.+2      	; 0x1eb4 <CALC_Task+0xda>
    1eb2:	8c c0       	rjmp	.+280    	; 0x1fcc <CALC_Task+0x1f2>
    1eb4:	08 f4       	brcc	.+2      	; 0x1eb8 <CALC_Task+0xde>
    1eb6:	47 c0       	rjmp	.+142    	; 0x1f46 <CALC_Task+0x16c>
    1eb8:	1f 30       	cpi	r17, 0x0F	; 15
    1eba:	09 f4       	brne	.+2      	; 0x1ebe <CALC_Task+0xe4>
    1ebc:	ca c0       	rjmp	.+404    	; 0x2052 <CALC_Task+0x278>
    1ebe:	56 c1       	rjmp	.+684    	; 0x216c <CALC_Task+0x392>
			case ADD:
				switch(struct_ptr->LastOperation){
    1ec0:	f7 01       	movw	r30, r14
    1ec2:	87 81       	ldd	r24, Z+7	; 0x07
    1ec4:	8d 30       	cpi	r24, 0x0D	; 13
    1ec6:	99 f0       	breq	.+38     	; 0x1eee <CALC_Task+0x114>
    1ec8:	18 f4       	brcc	.+6      	; 0x1ed0 <CALC_Task+0xf6>
    1eca:	8c 30       	cpi	r24, 0x0C	; 12
    1ecc:	31 f0       	breq	.+12     	; 0x1eda <CALC_Task+0x100>
    1ece:	31 c0       	rjmp	.+98     	; 0x1f32 <CALC_Task+0x158>
    1ed0:	8e 30       	cpi	r24, 0x0E	; 14
    1ed2:	b9 f0       	breq	.+46     	; 0x1f02 <CALC_Task+0x128>
    1ed4:	8f 30       	cpi	r24, 0x0F	; 15
    1ed6:	21 f1       	breq	.+72     	; 0x1f20 <CALC_Task+0x146>
    1ed8:	2c c0       	rjmp	.+88     	; 0x1f32 <CALC_Task+0x158>
				case ADD:
					struct_ptr->Answer += struct_ptr->CurrentNumber;
    1eda:	f7 01       	movw	r30, r14
    1edc:	25 81       	ldd	r18, Z+5	; 0x05
    1ede:	36 81       	ldd	r19, Z+6	; 0x06
    1ee0:	83 81       	ldd	r24, Z+3	; 0x03
    1ee2:	94 81       	ldd	r25, Z+4	; 0x04
    1ee4:	82 0f       	add	r24, r18
    1ee6:	93 1f       	adc	r25, r19
    1ee8:	96 83       	std	Z+6, r25	; 0x06
    1eea:	85 83       	std	Z+5, r24	; 0x05
					break;	
    1eec:	22 c0       	rjmp	.+68     	; 0x1f32 <CALC_Task+0x158>
				case SUB:
					struct_ptr->Answer -= struct_ptr->CurrentNumber;
    1eee:	f7 01       	movw	r30, r14
    1ef0:	85 81       	ldd	r24, Z+5	; 0x05
    1ef2:	96 81       	ldd	r25, Z+6	; 0x06
    1ef4:	23 81       	ldd	r18, Z+3	; 0x03
    1ef6:	34 81       	ldd	r19, Z+4	; 0x04
    1ef8:	82 1b       	sub	r24, r18
    1efa:	93 0b       	sbc	r25, r19
    1efc:	96 83       	std	Z+6, r25	; 0x06
    1efe:	85 83       	std	Z+5, r24	; 0x05
					break;
    1f00:	18 c0       	rjmp	.+48     	; 0x1f32 <CALC_Task+0x158>
				case MUL:
					struct_ptr->Answer *= struct_ptr->CurrentNumber;
    1f02:	f7 01       	movw	r30, r14
    1f04:	45 81       	ldd	r20, Z+5	; 0x05
    1f06:	56 81       	ldd	r21, Z+6	; 0x06
    1f08:	23 81       	ldd	r18, Z+3	; 0x03
    1f0a:	34 81       	ldd	r19, Z+4	; 0x04
    1f0c:	42 9f       	mul	r20, r18
    1f0e:	c0 01       	movw	r24, r0
    1f10:	43 9f       	mul	r20, r19
    1f12:	90 0d       	add	r25, r0
    1f14:	52 9f       	mul	r21, r18
    1f16:	90 0d       	add	r25, r0
    1f18:	11 24       	eor	r1, r1
    1f1a:	96 83       	std	Z+6, r25	; 0x06
    1f1c:	85 83       	std	Z+5, r24	; 0x05
					break;
    1f1e:	09 c0       	rjmp	.+18     	; 0x1f32 <CALC_Task+0x158>
				case DIV:
					struct_ptr->Answer /= struct_ptr->CurrentNumber;
    1f20:	f7 01       	movw	r30, r14
    1f22:	85 81       	ldd	r24, Z+5	; 0x05
    1f24:	96 81       	ldd	r25, Z+6	; 0x06
    1f26:	63 81       	ldd	r22, Z+3	; 0x03
    1f28:	74 81       	ldd	r23, Z+4	; 0x04
    1f2a:	0e 94 6d 13 	call	0x26da	; 0x26da <__udivmodhi4>
    1f2e:	76 83       	std	Z+6, r23	; 0x06
    1f30:	65 83       	std	Z+5, r22	; 0x05
					break;				
				}
				struct_ptr->CurrentNumber = 0;
    1f32:	f7 01       	movw	r30, r14
    1f34:	14 82       	std	Z+4, r1	; 0x04
    1f36:	13 82       	std	Z+3, r1	; 0x03
				struct_ptr->LastOperation = ADD;
    1f38:	b7 82       	std	Z+7, r11	; 0x07
				struct_ptr->display = struct_ptr->Answer;
    1f3a:	85 81       	ldd	r24, Z+5	; 0x05
    1f3c:	96 81       	ldd	r25, Z+6	; 0x06
    1f3e:	92 83       	std	Z+2, r25	; 0x02
    1f40:	81 83       	std	Z+1, r24	; 0x01
				last_receive = receive;
    1f42:	01 2f       	mov	r16, r17
				break;
    1f44:	33 c1       	rjmp	.+614    	; 0x21ac <CALC_Task+0x3d2>
			case SUB:
				switch(struct_ptr->LastOperation){
    1f46:	f7 01       	movw	r30, r14
    1f48:	87 81       	ldd	r24, Z+7	; 0x07
    1f4a:	8d 30       	cpi	r24, 0x0D	; 13
    1f4c:	99 f0       	breq	.+38     	; 0x1f74 <CALC_Task+0x19a>
    1f4e:	18 f4       	brcc	.+6      	; 0x1f56 <CALC_Task+0x17c>
    1f50:	8c 30       	cpi	r24, 0x0C	; 12
    1f52:	31 f0       	breq	.+12     	; 0x1f60 <CALC_Task+0x186>
    1f54:	31 c0       	rjmp	.+98     	; 0x1fb8 <CALC_Task+0x1de>
    1f56:	8e 30       	cpi	r24, 0x0E	; 14
    1f58:	b9 f0       	breq	.+46     	; 0x1f88 <CALC_Task+0x1ae>
    1f5a:	8f 30       	cpi	r24, 0x0F	; 15
    1f5c:	21 f1       	breq	.+72     	; 0x1fa6 <CALC_Task+0x1cc>
    1f5e:	2c c0       	rjmp	.+88     	; 0x1fb8 <CALC_Task+0x1de>
				case ADD:
					struct_ptr->Answer += struct_ptr->CurrentNumber;
    1f60:	f7 01       	movw	r30, r14
    1f62:	25 81       	ldd	r18, Z+5	; 0x05
    1f64:	36 81       	ldd	r19, Z+6	; 0x06
    1f66:	83 81       	ldd	r24, Z+3	; 0x03
    1f68:	94 81       	ldd	r25, Z+4	; 0x04
    1f6a:	82 0f       	add	r24, r18
    1f6c:	93 1f       	adc	r25, r19
    1f6e:	96 83       	std	Z+6, r25	; 0x06
    1f70:	85 83       	std	Z+5, r24	; 0x05
					break;
    1f72:	22 c0       	rjmp	.+68     	; 0x1fb8 <CALC_Task+0x1de>
				case SUB:
					struct_ptr->Answer -= struct_ptr->CurrentNumber;
    1f74:	f7 01       	movw	r30, r14
    1f76:	85 81       	ldd	r24, Z+5	; 0x05
    1f78:	96 81       	ldd	r25, Z+6	; 0x06
    1f7a:	23 81       	ldd	r18, Z+3	; 0x03
    1f7c:	34 81       	ldd	r19, Z+4	; 0x04
    1f7e:	82 1b       	sub	r24, r18
    1f80:	93 0b       	sbc	r25, r19
    1f82:	96 83       	std	Z+6, r25	; 0x06
    1f84:	85 83       	std	Z+5, r24	; 0x05
					break;
    1f86:	18 c0       	rjmp	.+48     	; 0x1fb8 <CALC_Task+0x1de>
				case MUL:
					struct_ptr->Answer *= struct_ptr->CurrentNumber;
    1f88:	f7 01       	movw	r30, r14
    1f8a:	45 81       	ldd	r20, Z+5	; 0x05
    1f8c:	56 81       	ldd	r21, Z+6	; 0x06
    1f8e:	23 81       	ldd	r18, Z+3	; 0x03
    1f90:	34 81       	ldd	r19, Z+4	; 0x04
    1f92:	42 9f       	mul	r20, r18
    1f94:	c0 01       	movw	r24, r0
    1f96:	43 9f       	mul	r20, r19
    1f98:	90 0d       	add	r25, r0
    1f9a:	52 9f       	mul	r21, r18
    1f9c:	90 0d       	add	r25, r0
    1f9e:	11 24       	eor	r1, r1
    1fa0:	96 83       	std	Z+6, r25	; 0x06
    1fa2:	85 83       	std	Z+5, r24	; 0x05
					break;
    1fa4:	09 c0       	rjmp	.+18     	; 0x1fb8 <CALC_Task+0x1de>
				case DIV:
					struct_ptr->Answer /= struct_ptr->CurrentNumber;
    1fa6:	f7 01       	movw	r30, r14
    1fa8:	85 81       	ldd	r24, Z+5	; 0x05
    1faa:	96 81       	ldd	r25, Z+6	; 0x06
    1fac:	63 81       	ldd	r22, Z+3	; 0x03
    1fae:	74 81       	ldd	r23, Z+4	; 0x04
    1fb0:	0e 94 6d 13 	call	0x26da	; 0x26da <__udivmodhi4>
    1fb4:	76 83       	std	Z+6, r23	; 0x06
    1fb6:	65 83       	std	Z+5, r22	; 0x05
					break;
				}
				struct_ptr->CurrentNumber = 0;
    1fb8:	f7 01       	movw	r30, r14
    1fba:	14 82       	std	Z+4, r1	; 0x04
    1fbc:	13 82       	std	Z+3, r1	; 0x03
				struct_ptr->LastOperation = SUB;
    1fbe:	77 82       	std	Z+7, r7	; 0x07
				struct_ptr->display = struct_ptr->Answer;
    1fc0:	85 81       	ldd	r24, Z+5	; 0x05
    1fc2:	96 81       	ldd	r25, Z+6	; 0x06
    1fc4:	92 83       	std	Z+2, r25	; 0x02
    1fc6:	81 83       	std	Z+1, r24	; 0x01
				last_receive = receive;
    1fc8:	01 2f       	mov	r16, r17
				break;
    1fca:	f0 c0       	rjmp	.+480    	; 0x21ac <CALC_Task+0x3d2>
			case MUL:
				switch(struct_ptr->LastOperation){
    1fcc:	f7 01       	movw	r30, r14
    1fce:	87 81       	ldd	r24, Z+7	; 0x07
    1fd0:	8d 30       	cpi	r24, 0x0D	; 13
    1fd2:	99 f0       	breq	.+38     	; 0x1ffa <CALC_Task+0x220>
    1fd4:	18 f4       	brcc	.+6      	; 0x1fdc <CALC_Task+0x202>
    1fd6:	8c 30       	cpi	r24, 0x0C	; 12
    1fd8:	31 f0       	breq	.+12     	; 0x1fe6 <CALC_Task+0x20c>
    1fda:	31 c0       	rjmp	.+98     	; 0x203e <CALC_Task+0x264>
    1fdc:	8e 30       	cpi	r24, 0x0E	; 14
    1fde:	b9 f0       	breq	.+46     	; 0x200e <CALC_Task+0x234>
    1fe0:	8f 30       	cpi	r24, 0x0F	; 15
    1fe2:	21 f1       	breq	.+72     	; 0x202c <CALC_Task+0x252>
    1fe4:	2c c0       	rjmp	.+88     	; 0x203e <CALC_Task+0x264>
				case ADD:
					struct_ptr->Answer += struct_ptr->CurrentNumber;
    1fe6:	f7 01       	movw	r30, r14
    1fe8:	25 81       	ldd	r18, Z+5	; 0x05
    1fea:	36 81       	ldd	r19, Z+6	; 0x06
    1fec:	83 81       	ldd	r24, Z+3	; 0x03
    1fee:	94 81       	ldd	r25, Z+4	; 0x04
    1ff0:	82 0f       	add	r24, r18
    1ff2:	93 1f       	adc	r25, r19
    1ff4:	96 83       	std	Z+6, r25	; 0x06
    1ff6:	85 83       	std	Z+5, r24	; 0x05
					break;
    1ff8:	22 c0       	rjmp	.+68     	; 0x203e <CALC_Task+0x264>
				case SUB:
					struct_ptr->Answer -= struct_ptr->CurrentNumber;
    1ffa:	f7 01       	movw	r30, r14
    1ffc:	85 81       	ldd	r24, Z+5	; 0x05
    1ffe:	96 81       	ldd	r25, Z+6	; 0x06
    2000:	23 81       	ldd	r18, Z+3	; 0x03
    2002:	34 81       	ldd	r19, Z+4	; 0x04
    2004:	82 1b       	sub	r24, r18
    2006:	93 0b       	sbc	r25, r19
    2008:	96 83       	std	Z+6, r25	; 0x06
    200a:	85 83       	std	Z+5, r24	; 0x05
					break;
    200c:	18 c0       	rjmp	.+48     	; 0x203e <CALC_Task+0x264>
				case MUL:
					struct_ptr->Answer *= struct_ptr->CurrentNumber;
    200e:	f7 01       	movw	r30, r14
    2010:	45 81       	ldd	r20, Z+5	; 0x05
    2012:	56 81       	ldd	r21, Z+6	; 0x06
    2014:	23 81       	ldd	r18, Z+3	; 0x03
    2016:	34 81       	ldd	r19, Z+4	; 0x04
    2018:	42 9f       	mul	r20, r18
    201a:	c0 01       	movw	r24, r0
    201c:	43 9f       	mul	r20, r19
    201e:	90 0d       	add	r25, r0
    2020:	52 9f       	mul	r21, r18
    2022:	90 0d       	add	r25, r0
    2024:	11 24       	eor	r1, r1
    2026:	96 83       	std	Z+6, r25	; 0x06
    2028:	85 83       	std	Z+5, r24	; 0x05
					break;
    202a:	09 c0       	rjmp	.+18     	; 0x203e <CALC_Task+0x264>
				case DIV:
					struct_ptr->Answer /= struct_ptr->CurrentNumber;
    202c:	f7 01       	movw	r30, r14
    202e:	85 81       	ldd	r24, Z+5	; 0x05
    2030:	96 81       	ldd	r25, Z+6	; 0x06
    2032:	63 81       	ldd	r22, Z+3	; 0x03
    2034:	74 81       	ldd	r23, Z+4	; 0x04
    2036:	0e 94 6d 13 	call	0x26da	; 0x26da <__udivmodhi4>
    203a:	76 83       	std	Z+6, r23	; 0x06
    203c:	65 83       	std	Z+5, r22	; 0x05
					break;
				}
				struct_ptr->CurrentNumber = 0;
    203e:	f7 01       	movw	r30, r14
    2040:	14 82       	std	Z+4, r1	; 0x04
    2042:	13 82       	std	Z+3, r1	; 0x03
				struct_ptr->LastOperation = MUL;
    2044:	67 82       	std	Z+7, r6	; 0x07
				struct_ptr->display = struct_ptr->Answer;
    2046:	85 81       	ldd	r24, Z+5	; 0x05
    2048:	96 81       	ldd	r25, Z+6	; 0x06
    204a:	92 83       	std	Z+2, r25	; 0x02
    204c:	81 83       	std	Z+1, r24	; 0x01
				last_receive = receive;
    204e:	01 2f       	mov	r16, r17
				break;
    2050:	ad c0       	rjmp	.+346    	; 0x21ac <CALC_Task+0x3d2>
			case DIV:
				switch(struct_ptr->LastOperation){
    2052:	f7 01       	movw	r30, r14
    2054:	87 81       	ldd	r24, Z+7	; 0x07
    2056:	8d 30       	cpi	r24, 0x0D	; 13
    2058:	99 f0       	breq	.+38     	; 0x2080 <CALC_Task+0x2a6>
    205a:	18 f4       	brcc	.+6      	; 0x2062 <CALC_Task+0x288>
    205c:	8c 30       	cpi	r24, 0x0C	; 12
    205e:	31 f0       	breq	.+12     	; 0x206c <CALC_Task+0x292>
    2060:	31 c0       	rjmp	.+98     	; 0x20c4 <CALC_Task+0x2ea>
    2062:	8e 30       	cpi	r24, 0x0E	; 14
    2064:	b9 f0       	breq	.+46     	; 0x2094 <CALC_Task+0x2ba>
    2066:	8f 30       	cpi	r24, 0x0F	; 15
    2068:	21 f1       	breq	.+72     	; 0x20b2 <CALC_Task+0x2d8>
    206a:	2c c0       	rjmp	.+88     	; 0x20c4 <CALC_Task+0x2ea>
					case ADD:
				struct_ptr->Answer += struct_ptr->CurrentNumber;
    206c:	f7 01       	movw	r30, r14
    206e:	25 81       	ldd	r18, Z+5	; 0x05
    2070:	36 81       	ldd	r19, Z+6	; 0x06
    2072:	83 81       	ldd	r24, Z+3	; 0x03
    2074:	94 81       	ldd	r25, Z+4	; 0x04
    2076:	82 0f       	add	r24, r18
    2078:	93 1f       	adc	r25, r19
    207a:	96 83       	std	Z+6, r25	; 0x06
    207c:	85 83       	std	Z+5, r24	; 0x05
					break;
    207e:	22 c0       	rjmp	.+68     	; 0x20c4 <CALC_Task+0x2ea>
					case SUB:
				struct_ptr->Answer -= struct_ptr->CurrentNumber;
    2080:	f7 01       	movw	r30, r14
    2082:	85 81       	ldd	r24, Z+5	; 0x05
    2084:	96 81       	ldd	r25, Z+6	; 0x06
    2086:	23 81       	ldd	r18, Z+3	; 0x03
    2088:	34 81       	ldd	r19, Z+4	; 0x04
    208a:	82 1b       	sub	r24, r18
    208c:	93 0b       	sbc	r25, r19
    208e:	96 83       	std	Z+6, r25	; 0x06
    2090:	85 83       	std	Z+5, r24	; 0x05
					break;
    2092:	18 c0       	rjmp	.+48     	; 0x20c4 <CALC_Task+0x2ea>
					case MUL:
				struct_ptr->Answer *= struct_ptr->CurrentNumber;
    2094:	f7 01       	movw	r30, r14
    2096:	45 81       	ldd	r20, Z+5	; 0x05
    2098:	56 81       	ldd	r21, Z+6	; 0x06
    209a:	23 81       	ldd	r18, Z+3	; 0x03
    209c:	34 81       	ldd	r19, Z+4	; 0x04
    209e:	42 9f       	mul	r20, r18
    20a0:	c0 01       	movw	r24, r0
    20a2:	43 9f       	mul	r20, r19
    20a4:	90 0d       	add	r25, r0
    20a6:	52 9f       	mul	r21, r18
    20a8:	90 0d       	add	r25, r0
    20aa:	11 24       	eor	r1, r1
    20ac:	96 83       	std	Z+6, r25	; 0x06
    20ae:	85 83       	std	Z+5, r24	; 0x05
					break;
    20b0:	09 c0       	rjmp	.+18     	; 0x20c4 <CALC_Task+0x2ea>
					case DIV:
				struct_ptr->Answer /= struct_ptr->CurrentNumber;
    20b2:	f7 01       	movw	r30, r14
    20b4:	85 81       	ldd	r24, Z+5	; 0x05
    20b6:	96 81       	ldd	r25, Z+6	; 0x06
    20b8:	63 81       	ldd	r22, Z+3	; 0x03
    20ba:	74 81       	ldd	r23, Z+4	; 0x04
    20bc:	0e 94 6d 13 	call	0x26da	; 0x26da <__udivmodhi4>
    20c0:	76 83       	std	Z+6, r23	; 0x06
    20c2:	65 83       	std	Z+5, r22	; 0x05
					break;
				}
				struct_ptr->CurrentNumber = 0;
    20c4:	f7 01       	movw	r30, r14
    20c6:	14 82       	std	Z+4, r1	; 0x04
    20c8:	13 82       	std	Z+3, r1	; 0x03
				struct_ptr->LastOperation = DIV;
    20ca:	87 82       	std	Z+7, r8	; 0x07
				struct_ptr->display = struct_ptr->Answer;
    20cc:	85 81       	ldd	r24, Z+5	; 0x05
    20ce:	96 81       	ldd	r25, Z+6	; 0x06
    20d0:	92 83       	std	Z+2, r25	; 0x02
    20d2:	81 83       	std	Z+1, r24	; 0x01
				last_receive = receive;
    20d4:	01 2f       	mov	r16, r17
				break;
    20d6:	6a c0       	rjmp	.+212    	; 0x21ac <CALC_Task+0x3d2>
			case ON_C:
				struct_ptr->CurrentNumber = 0;
    20d8:	f7 01       	movw	r30, r14
    20da:	14 82       	std	Z+4, r1	; 0x04
    20dc:	13 82       	std	Z+3, r1	; 0x03
				struct_ptr->display = 0;
    20de:	12 82       	std	Z+2, r1	; 0x02
    20e0:	11 82       	std	Z+1, r1	; 0x01
				newCalculation = 1;
				last_receive = 0;
    20e2:	0c 2d       	mov	r16, r12
    20e4:	66 c0       	rjmp	.+204    	; 0x21b2 <CALC_Task+0x3d8>
				break;
				
			case EQUAL:
				switch(struct_ptr->LastOperation){
    20e6:	f7 01       	movw	r30, r14
    20e8:	87 81       	ldd	r24, Z+7	; 0x07
    20ea:	8d 30       	cpi	r24, 0x0D	; 13
    20ec:	99 f0       	breq	.+38     	; 0x2114 <CALC_Task+0x33a>
    20ee:	18 f4       	brcc	.+6      	; 0x20f6 <CALC_Task+0x31c>
    20f0:	8c 30       	cpi	r24, 0x0C	; 12
    20f2:	31 f0       	breq	.+12     	; 0x2100 <CALC_Task+0x326>
    20f4:	31 c0       	rjmp	.+98     	; 0x2158 <CALC_Task+0x37e>
    20f6:	8e 30       	cpi	r24, 0x0E	; 14
    20f8:	b9 f0       	breq	.+46     	; 0x2128 <CALC_Task+0x34e>
    20fa:	8f 30       	cpi	r24, 0x0F	; 15
    20fc:	21 f1       	breq	.+72     	; 0x2146 <CALC_Task+0x36c>
    20fe:	2c c0       	rjmp	.+88     	; 0x2158 <CALC_Task+0x37e>
				case ADD:
					struct_ptr->Answer += struct_ptr->CurrentNumber;
    2100:	f7 01       	movw	r30, r14
    2102:	25 81       	ldd	r18, Z+5	; 0x05
    2104:	36 81       	ldd	r19, Z+6	; 0x06
    2106:	83 81       	ldd	r24, Z+3	; 0x03
    2108:	94 81       	ldd	r25, Z+4	; 0x04
    210a:	82 0f       	add	r24, r18
    210c:	93 1f       	adc	r25, r19
    210e:	96 83       	std	Z+6, r25	; 0x06
    2110:	85 83       	std	Z+5, r24	; 0x05
					break;
    2112:	22 c0       	rjmp	.+68     	; 0x2158 <CALC_Task+0x37e>
				case SUB:
					struct_ptr->Answer -= struct_ptr->CurrentNumber;
    2114:	f7 01       	movw	r30, r14
    2116:	85 81       	ldd	r24, Z+5	; 0x05
    2118:	96 81       	ldd	r25, Z+6	; 0x06
    211a:	23 81       	ldd	r18, Z+3	; 0x03
    211c:	34 81       	ldd	r19, Z+4	; 0x04
    211e:	82 1b       	sub	r24, r18
    2120:	93 0b       	sbc	r25, r19
    2122:	96 83       	std	Z+6, r25	; 0x06
    2124:	85 83       	std	Z+5, r24	; 0x05
					break;
    2126:	18 c0       	rjmp	.+48     	; 0x2158 <CALC_Task+0x37e>
				case MUL:
					struct_ptr->Answer *= struct_ptr->CurrentNumber;
    2128:	f7 01       	movw	r30, r14
    212a:	45 81       	ldd	r20, Z+5	; 0x05
    212c:	56 81       	ldd	r21, Z+6	; 0x06
    212e:	23 81       	ldd	r18, Z+3	; 0x03
    2130:	34 81       	ldd	r19, Z+4	; 0x04
    2132:	42 9f       	mul	r20, r18
    2134:	c0 01       	movw	r24, r0
    2136:	43 9f       	mul	r20, r19
    2138:	90 0d       	add	r25, r0
    213a:	52 9f       	mul	r21, r18
    213c:	90 0d       	add	r25, r0
    213e:	11 24       	eor	r1, r1
    2140:	96 83       	std	Z+6, r25	; 0x06
    2142:	85 83       	std	Z+5, r24	; 0x05
					break;
    2144:	09 c0       	rjmp	.+18     	; 0x2158 <CALC_Task+0x37e>
				case DIV:
					struct_ptr->Answer /= struct_ptr->CurrentNumber;
    2146:	f7 01       	movw	r30, r14
    2148:	85 81       	ldd	r24, Z+5	; 0x05
    214a:	96 81       	ldd	r25, Z+6	; 0x06
    214c:	63 81       	ldd	r22, Z+3	; 0x03
    214e:	74 81       	ldd	r23, Z+4	; 0x04
    2150:	0e 94 6d 13 	call	0x26da	; 0x26da <__udivmodhi4>
    2154:	76 83       	std	Z+6, r23	; 0x06
    2156:	65 83       	std	Z+5, r22	; 0x05
					break;
				}
				struct_ptr->CurrentNumber = 0;
    2158:	f7 01       	movw	r30, r14
    215a:	14 82       	std	Z+4, r1	; 0x04
    215c:	13 82       	std	Z+3, r1	; 0x03
				struct_ptr->LastOperation = EQUAL;
    215e:	97 82       	std	Z+7, r9	; 0x07
				struct_ptr->display = struct_ptr->Answer;
    2160:	85 81       	ldd	r24, Z+5	; 0x05
    2162:	96 81       	ldd	r25, Z+6	; 0x06
    2164:	92 83       	std	Z+2, r25	; 0x02
    2166:	81 83       	std	Z+1, r24	; 0x01
				last_receive = receive;
    2168:	01 2f       	mov	r16, r17
				break;
    216a:	20 c0       	rjmp	.+64     	; 0x21ac <CALC_Task+0x3d2>
			default:
				if(receive == ZERO) receive = '0';
    216c:	12 30       	cpi	r17, 0x02	; 2
    216e:	09 f4       	brne	.+2      	; 0x2172 <CALC_Task+0x398>
    2170:	a9 82       	std	Y+1, r10	; 0x01
				if(struct_ptr->LastOperation == EQUAL) newCalculation = 1;
    2172:	f7 01       	movw	r30, r14
    2174:	87 81       	ldd	r24, Z+7	; 0x07
    2176:	83 30       	cpi	r24, 0x03	; 3
    2178:	09 f4       	brne	.+2      	; 0x217c <CALC_Task+0x3a2>
    217a:	d5 2c       	mov	r13, r5
				struct_ptr->CurrentNumber = struct_ptr->CurrentNumber * 10 + (receive-'0');
    217c:	49 81       	ldd	r20, Y+1	; 0x01
    217e:	f7 01       	movw	r30, r14
    2180:	23 81       	ldd	r18, Z+3	; 0x03
    2182:	34 81       	ldd	r19, Z+4	; 0x04
    2184:	c9 01       	movw	r24, r18
    2186:	88 0f       	add	r24, r24
    2188:	99 1f       	adc	r25, r25
    218a:	22 0f       	add	r18, r18
    218c:	33 1f       	adc	r19, r19
    218e:	22 0f       	add	r18, r18
    2190:	33 1f       	adc	r19, r19
    2192:	22 0f       	add	r18, r18
    2194:	33 1f       	adc	r19, r19
    2196:	82 0f       	add	r24, r18
    2198:	93 1f       	adc	r25, r19
    219a:	84 0f       	add	r24, r20
    219c:	91 1d       	adc	r25, r1
    219e:	c0 97       	sbiw	r24, 0x30	; 48
    21a0:	94 83       	std	Z+4, r25	; 0x04
    21a2:	83 83       	std	Z+3, r24	; 0x03
				struct_ptr->display = struct_ptr->CurrentNumber;
    21a4:	92 83       	std	Z+2, r25	; 0x02
    21a6:	81 83       	std	Z+1, r24	; 0x01
				struct_ptr->lastDigit = receive;
    21a8:	40 83       	st	Z, r20
				last_receive = 0;
    21aa:	0c 2d       	mov	r16, r12
				break;
			}
			if(newCalculation == 1){
    21ac:	f1 e0       	ldi	r31, 0x01	; 1
    21ae:	df 12       	cpse	r13, r31
    21b0:	05 c0       	rjmp	.+10     	; 0x21bc <CALC_Task+0x3e2>
				struct_ptr->LastOperation = ADD;
    21b2:	f7 01       	movw	r30, r14
    21b4:	b7 82       	std	Z+7, r11	; 0x07
				struct_ptr->Answer = 0;
    21b6:	16 82       	std	Z+6, r1	; 0x06
    21b8:	15 82       	std	Z+5, r1	; 0x05
				newCalculation = 0;	
    21ba:	dc 2c       	mov	r13, r12
			}
			xEventGroupSetBits(event_handle,BIT_CALC);
    21bc:	64 e0       	ldi	r22, 0x04	; 4
    21be:	70 e0       	ldi	r23, 0x00	; 0
    21c0:	80 91 14 07 	lds	r24, 0x0714	; 0x800714 <event_handle>
    21c4:	90 91 15 07 	lds	r25, 0x0715	; 0x800715 <event_handle+0x1>
    21c8:	0e 94 f3 00 	call	0x1e6	; 0x1e6 <xEventGroupSetBits>
    21cc:	11 c0       	rjmp	.+34     	; 0x21f0 <CALC_Task+0x416>
			
		}else{ //Switch
			if(last_receive != receive){
    21ce:	03 36       	cpi	r16, 0x63	; 99
    21d0:	79 f0       	breq	.+30     	; 0x21f0 <CALC_Task+0x416>
				struct_ptr->CurrentNumber = 0;
    21d2:	f7 01       	movw	r30, r14
    21d4:	14 82       	std	Z+4, r1	; 0x04
    21d6:	13 82       	std	Z+3, r1	; 0x03
				struct_ptr->display = 0;
    21d8:	12 82       	std	Z+2, r1	; 0x02
    21da:	11 82       	std	Z+1, r1	; 0x01
				struct_ptr->lastDigit = '0';
    21dc:	a0 82       	st	Z, r10
				last_receive = receive;
				xEventGroupSetBits(event_handle,BIT_CALC);
    21de:	64 e0       	ldi	r22, 0x04	; 4
    21e0:	70 e0       	ldi	r23, 0x00	; 0
    21e2:	80 91 14 07 	lds	r24, 0x0714	; 0x800714 <event_handle>
    21e6:	90 91 15 07 	lds	r25, 0x0715	; 0x800715 <event_handle+0x1>
    21ea:	0e 94 f3 00 	call	0x1e6	; 0x1e6 <xEventGroupSetBits>
		}else{ //Switch
			if(last_receive != receive){
				struct_ptr->CurrentNumber = 0;
				struct_ptr->display = 0;
				struct_ptr->lastDigit = '0';
				last_receive = receive;
    21ee:	01 2f       	mov	r16, r17
				xEventGroupSetBits(event_handle,BIT_CALC);
			}
		}
		
		xEventGroupSetBits(event_handle,BIT_CALC);
    21f0:	64 e0       	ldi	r22, 0x04	; 4
    21f2:	70 e0       	ldi	r23, 0x00	; 0
    21f4:	80 91 14 07 	lds	r24, 0x0714	; 0x800714 <event_handle>
    21f8:	90 91 15 07 	lds	r25, 0x0715	; 0x800715 <event_handle+0x1>
    21fc:	0e 94 f3 00 	call	0x1e6	; 0x1e6 <xEventGroupSetBits>
	}
    2200:	30 ce       	rjmp	.-928    	; 0x1e62 <CALC_Task+0x88>

00002202 <KEYPAD_Scan>:
}

//Warning: This can not handle 2 buttons pressed at the same time
char KEYPAD_Scan(void){
    2202:	0f 93       	push	r16
    2204:	1f 93       	push	r17
    2206:	cf 93       	push	r28
    2208:	df 93       	push	r29
    220a:	a0 e0       	ldi	r26, 0x00	; 0
    220c:	b0 e0       	ldi	r27, 0x00	; 0
	char i = 0, j = 0, flag = 0, new = 0;
	static char old = 0;
	
	for(i = 0; i < 4; i++){
		PORTC |= 0x0F;
		PORTC &= ~(1<<i);
    220e:	c1 e0       	ldi	r28, 0x01	; 1
    2210:	d0 e0       	ldi	r29, 0x00	; 0
    2212:	8a 2f       	mov	r24, r26
char KEYPAD_Scan(void){
	char i = 0, j = 0, flag = 0, new = 0;
	static char old = 0;
	
	for(i = 0; i < 4; i++){
		PORTC |= 0x0F;
    2214:	95 b3       	in	r25, 0x15	; 21
    2216:	9f 60       	ori	r25, 0x0F	; 15
    2218:	95 bb       	out	0x15, r25	; 21
		PORTC &= ~(1<<i);
    221a:	25 b3       	in	r18, 0x15	; 21
    221c:	ae 01       	movw	r20, r28
    221e:	0a 2e       	mov	r0, r26
    2220:	02 c0       	rjmp	.+4      	; 0x2226 <KEYPAD_Scan+0x24>
    2222:	44 0f       	add	r20, r20
    2224:	55 1f       	adc	r21, r21
    2226:	0a 94       	dec	r0
    2228:	e2 f7       	brpl	.-8      	; 0x2222 <KEYPAD_Scan+0x20>
    222a:	94 2f       	mov	r25, r20
    222c:	90 95       	com	r25
    222e:	92 23       	and	r25, r18
    2230:	95 bb       	out	0x15, r25	; 21
    2232:	20 e0       	ldi	r18, 0x00	; 0
    2234:	30 e0       	ldi	r19, 0x00	; 0
    2236:	92 2f       	mov	r25, r18
		for(j = 0; j < 4; j++){
			if( (( ~PINC & (1<<(j+4)) ) == (1<<(j+4))) && j != 0 && i != 3){ //For buttons : 1->9
    2238:	43 b3       	in	r20, 0x13	; 19
    223a:	89 01       	movw	r16, r18
    223c:	b9 01       	movw	r22, r18
    223e:	6c 5f       	subi	r22, 0xFC	; 252
    2240:	7f 4f       	sbci	r23, 0xFF	; 255
    2242:	fe 01       	movw	r30, r28
    2244:	02 c0       	rjmp	.+4      	; 0x224a <KEYPAD_Scan+0x48>
    2246:	ee 0f       	add	r30, r30
    2248:	ff 1f       	adc	r31, r31
    224a:	6a 95       	dec	r22
    224c:	e2 f7       	brpl	.-8      	; 0x2246 <KEYPAD_Scan+0x44>
    224e:	50 e0       	ldi	r21, 0x00	; 0
    2250:	4e 23       	and	r20, r30
    2252:	5f 23       	and	r21, r31
    2254:	45 2b       	or	r20, r21
    2256:	61 f4       	brne	.+24     	; 0x2270 <KEYPAD_Scan+0x6e>
    2258:	22 23       	and	r18, r18
    225a:	51 f0       	breq	.+20     	; 0x2270 <KEYPAD_Scan+0x6e>
    225c:	83 30       	cpi	r24, 0x03	; 3
    225e:	69 f1       	breq	.+90     	; 0x22ba <KEYPAD_Scan+0xb8>
				new = (j-1)*3 + i + 49;
    2260:	01 50       	subi	r16, 0x01	; 1
    2262:	11 09       	sbc	r17, r1
    2264:	90 2f       	mov	r25, r16
    2266:	99 0f       	add	r25, r25
    2268:	09 0f       	add	r16, r25
    226a:	8f 5c       	subi	r24, 0xCF	; 207
    226c:	80 0f       	add	r24, r16
				flag = 1;
				break;
    226e:	2c c0       	rjmp	.+88     	; 0x22c8 <KEYPAD_Scan+0xc6>
			}else if( (( ~PINC & (1<<(j+4)) ) == (1<<(j+4))) && i == 3){ //For Buttons: Operations(ADD,SUB,MUL,DIV)
    2270:	63 b3       	in	r22, 0x13	; 19
    2272:	70 e0       	ldi	r23, 0x00	; 0
    2274:	ab 01       	movw	r20, r22
    2276:	4e 23       	and	r20, r30
    2278:	5f 23       	and	r21, r31
    227a:	45 2b       	or	r20, r21
    227c:	29 f4       	brne	.+10     	; 0x2288 <KEYPAD_Scan+0x86>
    227e:	83 30       	cpi	r24, 0x03	; 3
    2280:	19 f4       	brne	.+6      	; 0x2288 <KEYPAD_Scan+0x86>
				new = j + ADD;
    2282:	8c e0       	ldi	r24, 0x0C	; 12
    2284:	89 0f       	add	r24, r25
				flag = 1;
				break;
    2286:	20 c0       	rjmp	.+64     	; 0x22c8 <KEYPAD_Scan+0xc6>
			}else if( (( ~PINC & (1<<4) ) == (1<<4)) ){ //For buttons: ON_C,0,EQUAL
    2288:	9c 99       	sbic	0x13, 4	; 19
    228a:	05 c0       	rjmp	.+10     	; 0x2296 <KEYPAD_Scan+0x94>
				new = i+1;
    228c:	8f 5f       	subi	r24, 0xFF	; 255
				flag = 1;
				if(new == 2) new = '0';
    228e:	82 30       	cpi	r24, 0x02	; 2
    2290:	d9 f4       	brne	.+54     	; 0x22c8 <KEYPAD_Scan+0xc6>
    2292:	80 e3       	ldi	r24, 0x30	; 48
    2294:	19 c0       	rjmp	.+50     	; 0x22c8 <KEYPAD_Scan+0xc6>
    2296:	2f 5f       	subi	r18, 0xFF	; 255
    2298:	3f 4f       	sbci	r19, 0xFF	; 255
	static char old = 0;
	
	for(i = 0; i < 4; i++){
		PORTC |= 0x0F;
		PORTC &= ~(1<<i);
		for(j = 0; j < 4; j++){
    229a:	24 30       	cpi	r18, 0x04	; 4
    229c:	31 05       	cpc	r19, r1
    229e:	59 f6       	brne	.-106    	; 0x2236 <KEYPAD_Scan+0x34>
    22a0:	11 96       	adiw	r26, 0x01	; 1
//Warning: This can not handle 2 buttons pressed at the same time
char KEYPAD_Scan(void){
	char i = 0, j = 0, flag = 0, new = 0;
	static char old = 0;
	
	for(i = 0; i < 4; i++){
    22a2:	a4 30       	cpi	r26, 0x04	; 4
    22a4:	b1 05       	cpc	r27, r1
    22a6:	09 f0       	breq	.+2      	; 0x22aa <KEYPAD_Scan+0xa8>
    22a8:	b4 cf       	rjmp	.-152    	; 0x2212 <KEYPAD_Scan+0x10>
    22aa:	03 c0       	rjmp	.+6      	; 0x22b2 <KEYPAD_Scan+0xb0>
		if(flag == 1) break;
	}
	
	if(flag == 1){ //Button Pressed
		if(old != new){
			old = new;
    22ac:	80 93 09 07 	sts	0x0709, r24	; 0x800709 <old.2438>
    22b0:	10 c0       	rjmp	.+32     	; 0x22d2 <KEYPAD_Scan+0xd0>
		}else{
			new = 0;
		}
	}else{ //Button Released
		old = 0;
    22b2:	10 92 09 07 	sts	0x0709, r1	; 0x800709 <old.2438>
		new = 0;
    22b6:	80 e0       	ldi	r24, 0x00	; 0
    22b8:	0c c0       	rjmp	.+24     	; 0x22d2 <KEYPAD_Scan+0xd0>
		for(j = 0; j < 4; j++){
			if( (( ~PINC & (1<<(j+4)) ) == (1<<(j+4))) && j != 0 && i != 3){ //For buttons : 1->9
				new = (j-1)*3 + i + 49;
				flag = 1;
				break;
			}else if( (( ~PINC & (1<<(j+4)) ) == (1<<(j+4))) && i == 3){ //For Buttons: Operations(ADD,SUB,MUL,DIV)
    22ba:	43 b3       	in	r20, 0x13	; 19
    22bc:	50 e0       	ldi	r21, 0x00	; 0
    22be:	4e 23       	and	r20, r30
    22c0:	5f 23       	and	r21, r31
    22c2:	45 2b       	or	r20, r21
    22c4:	09 f7       	brne	.-62     	; 0x2288 <KEYPAD_Scan+0x86>
    22c6:	dd cf       	rjmp	.-70     	; 0x2282 <KEYPAD_Scan+0x80>
		}
		if(flag == 1) break;
	}
	
	if(flag == 1){ //Button Pressed
		if(old != new){
    22c8:	90 91 09 07 	lds	r25, 0x0709	; 0x800709 <old.2438>
    22cc:	98 13       	cpse	r25, r24
    22ce:	ee cf       	rjmp	.-36     	; 0x22ac <KEYPAD_Scan+0xaa>
			old = new;
		}else{
			new = 0;
    22d0:	80 e0       	ldi	r24, 0x00	; 0
		old = 0;
		new = 0;
	}
	
	return new;
}
    22d2:	df 91       	pop	r29
    22d4:	cf 91       	pop	r28
    22d6:	1f 91       	pop	r17
    22d8:	0f 91       	pop	r16
    22da:	08 95       	ret

000022dc <KEYPAD_Task>:
	}
	xEventGroupSetBits(event_handle,BIT_PROMPT);
	vTaskDelete(NULL);
}

void KEYPAD_Task(void * pvParameters){
    22dc:	cf 93       	push	r28
    22de:	df 93       	push	r29
    22e0:	00 d0       	rcall	.+0      	; 0x22e2 <KEYPAD_Task+0x6>
    22e2:	1f 92       	push	r1
    22e4:	cd b7       	in	r28, 0x3d	; 61
    22e6:	de b7       	in	r29, 0x3e	; 62
	#if FAST_TEST == 0
	xEventGroupWaitBits(event_handle,BIT_WELCOME,pdFALSE,pdFALSE,portMAX_DELAY);
    22e8:	0f ef       	ldi	r16, 0xFF	; 255
    22ea:	1f ef       	ldi	r17, 0xFF	; 255
    22ec:	20 e0       	ldi	r18, 0x00	; 0
    22ee:	40 e0       	ldi	r20, 0x00	; 0
    22f0:	61 e0       	ldi	r22, 0x01	; 1
    22f2:	70 e0       	ldi	r23, 0x00	; 0
    22f4:	80 91 14 07 	lds	r24, 0x0714	; 0x800714 <event_handle>
    22f8:	90 91 15 07 	lds	r25, 0x0715	; 0x800715 <event_handle+0x1>
    22fc:	0e 94 5c 00 	call	0xb8	; 0xb8 <xEventGroupWaitBits>
	#endif
	char receive = 0;
    2300:	19 82       	std	Y+1, r1	; 0x01
	TickType_t tick = xTaskGetTickCount();
    2302:	0e 94 1d 08 	call	0x103a	; 0x103a <xTaskGetTickCount>
    2306:	9b 83       	std	Y+3, r25	; 0x03
    2308:	8a 83       	std	Y+2, r24	; 0x02
	while(1){
		receive = KEYPAD_Scan();
    230a:	0e 94 01 11 	call	0x2202	; 0x2202 <KEYPAD_Scan>
    230e:	89 83       	std	Y+1, r24	; 0x01
		if(receive != 0){
    2310:	88 23       	and	r24, r24
    2312:	e1 f0       	breq	.+56     	; 0x234c <KEYPAD_Task+0x70>
			xEventGroupClearBits(event_handle,BIT_LED);
    2314:	68 e0       	ldi	r22, 0x08	; 8
    2316:	70 e0       	ldi	r23, 0x00	; 0
    2318:	80 91 14 07 	lds	r24, 0x0714	; 0x800714 <event_handle>
    231c:	90 91 15 07 	lds	r25, 0x0715	; 0x800715 <event_handle+0x1>
    2320:	0e 94 e4 00 	call	0x1c8	; 0x1c8 <xEventGroupClearBits>
			xEventGroupSetBits(event_handle,BIT_START);
    2324:	60 e1       	ldi	r22, 0x10	; 16
    2326:	70 e0       	ldi	r23, 0x00	; 0
    2328:	80 91 14 07 	lds	r24, 0x0714	; 0x800714 <event_handle>
    232c:	90 91 15 07 	lds	r25, 0x0715	; 0x800715 <event_handle+0x1>
    2330:	0e 94 f3 00 	call	0x1e6	; 0x1e6 <xEventGroupSetBits>
			xQueueSend(queue_handle,&receive,100);
    2334:	20 e0       	ldi	r18, 0x00	; 0
    2336:	44 e6       	ldi	r20, 0x64	; 100
    2338:	50 e0       	ldi	r21, 0x00	; 0
    233a:	be 01       	movw	r22, r28
    233c:	6f 5f       	subi	r22, 0xFF	; 255
    233e:	7f 4f       	sbci	r23, 0xFF	; 255
    2340:	80 91 0c 07 	lds	r24, 0x070C	; 0x80070c <queue_handle>
    2344:	90 91 0d 07 	lds	r25, 0x070D	; 0x80070d <queue_handle+0x1>
    2348:	0e 94 9e 04 	call	0x93c	; 0x93c <xQueueGenericSend>
			
		}
		vTaskDelayUntil(&tick,20);
    234c:	64 e1       	ldi	r22, 0x14	; 20
    234e:	70 e0       	ldi	r23, 0x00	; 0
    2350:	ce 01       	movw	r24, r28
    2352:	02 96       	adiw	r24, 0x02	; 2
    2354:	0e 94 69 09 	call	0x12d2	; 0x12d2 <vTaskDelayUntil>
	}
    2358:	d8 cf       	rjmp	.-80     	; 0x230a <KEYPAD_Task+0x2e>

0000235a <TIM2_Init>:

#include "avr/io.h"
#include "TIM.h"

void TIM2_Init(void){
	SetBit(TCCR2,3);
    235a:	85 b5       	in	r24, 0x25	; 37
    235c:	88 60       	ori	r24, 0x08	; 8
    235e:	85 bd       	out	0x25, r24	; 37
	SetBit(TCCR2,6);
    2360:	85 b5       	in	r24, 0x25	; 37
    2362:	80 64       	ori	r24, 0x40	; 64
    2364:	85 bd       	out	0x25, r24	; 37

	SetBit(TCCR2,5);
    2366:	85 b5       	in	r24, 0x25	; 37
    2368:	80 62       	ori	r24, 0x20	; 32
    236a:	85 bd       	out	0x25, r24	; 37

	if(((float)Clk_Freq/(Req_Freq*256.0)) < 8){
		TCCR2 = (TCCR2 & (~0x07)) | (1 << 0);
	}else if(((float)Clk_Freq/(Req_Freq*256.0)) < 32){
		TCCR2 = (TCCR2 & (~0x07)) | (2 << 0);
    236c:	85 b5       	in	r24, 0x25	; 37
    236e:	88 7f       	andi	r24, 0xF8	; 248
    2370:	82 60       	ori	r24, 0x02	; 2
    2372:	85 bd       	out	0x25, r24	; 37
    2374:	08 95       	ret

00002376 <TIM2_SetDutyCycle>:
		TCCR2 = (TCCR2 & (~0x07)) | (7 << 0);
	}
}

void TIM2_SetDutyCycle(unsigned char DC){
	OCR2 = (unsigned char)((DC/100.0)*255);
    2376:	68 2f       	mov	r22, r24
    2378:	70 e0       	ldi	r23, 0x00	; 0
    237a:	80 e0       	ldi	r24, 0x00	; 0
    237c:	90 e0       	ldi	r25, 0x00	; 0
    237e:	0e 94 74 12 	call	0x24e8	; 0x24e8 <__floatsisf>
    2382:	20 e0       	ldi	r18, 0x00	; 0
    2384:	30 e0       	ldi	r19, 0x00	; 0
    2386:	48 ec       	ldi	r20, 0xC8	; 200
    2388:	52 e4       	ldi	r21, 0x42	; 66
    238a:	0e 94 d1 11 	call	0x23a2	; 0x23a2 <__divsf3>
    238e:	20 e0       	ldi	r18, 0x00	; 0
    2390:	30 e0       	ldi	r19, 0x00	; 0
    2392:	4f e7       	ldi	r20, 0x7F	; 127
    2394:	53 e4       	ldi	r21, 0x43	; 67
    2396:	0e 94 00 13 	call	0x2600	; 0x2600 <__mulsf3>
    239a:	0e 94 43 12 	call	0x2486	; 0x2486 <__fixunssfsi>
    239e:	63 bd       	out	0x23, r22	; 35
    23a0:	08 95       	ret

000023a2 <__divsf3>:
    23a2:	0e 94 e5 11 	call	0x23ca	; 0x23ca <__divsf3x>
    23a6:	0c 94 c6 12 	jmp	0x258c	; 0x258c <__fp_round>
    23aa:	0e 94 bf 12 	call	0x257e	; 0x257e <__fp_pscB>
    23ae:	58 f0       	brcs	.+22     	; 0x23c6 <__divsf3+0x24>
    23b0:	0e 94 b8 12 	call	0x2570	; 0x2570 <__fp_pscA>
    23b4:	40 f0       	brcs	.+16     	; 0x23c6 <__divsf3+0x24>
    23b6:	29 f4       	brne	.+10     	; 0x23c2 <__divsf3+0x20>
    23b8:	5f 3f       	cpi	r21, 0xFF	; 255
    23ba:	29 f0       	breq	.+10     	; 0x23c6 <__divsf3+0x24>
    23bc:	0c 94 af 12 	jmp	0x255e	; 0x255e <__fp_inf>
    23c0:	51 11       	cpse	r21, r1
    23c2:	0c 94 fa 12 	jmp	0x25f4	; 0x25f4 <__fp_szero>
    23c6:	0c 94 b5 12 	jmp	0x256a	; 0x256a <__fp_nan>

000023ca <__divsf3x>:
    23ca:	0e 94 d7 12 	call	0x25ae	; 0x25ae <__fp_split3>
    23ce:	68 f3       	brcs	.-38     	; 0x23aa <__divsf3+0x8>

000023d0 <__divsf3_pse>:
    23d0:	99 23       	and	r25, r25
    23d2:	b1 f3       	breq	.-20     	; 0x23c0 <__divsf3+0x1e>
    23d4:	55 23       	and	r21, r21
    23d6:	91 f3       	breq	.-28     	; 0x23bc <__divsf3+0x1a>
    23d8:	95 1b       	sub	r25, r21
    23da:	55 0b       	sbc	r21, r21
    23dc:	bb 27       	eor	r27, r27
    23de:	aa 27       	eor	r26, r26
    23e0:	62 17       	cp	r22, r18
    23e2:	73 07       	cpc	r23, r19
    23e4:	84 07       	cpc	r24, r20
    23e6:	38 f0       	brcs	.+14     	; 0x23f6 <__divsf3_pse+0x26>
    23e8:	9f 5f       	subi	r25, 0xFF	; 255
    23ea:	5f 4f       	sbci	r21, 0xFF	; 255
    23ec:	22 0f       	add	r18, r18
    23ee:	33 1f       	adc	r19, r19
    23f0:	44 1f       	adc	r20, r20
    23f2:	aa 1f       	adc	r26, r26
    23f4:	a9 f3       	breq	.-22     	; 0x23e0 <__divsf3_pse+0x10>
    23f6:	35 d0       	rcall	.+106    	; 0x2462 <__divsf3_pse+0x92>
    23f8:	0e 2e       	mov	r0, r30
    23fa:	3a f0       	brmi	.+14     	; 0x240a <__divsf3_pse+0x3a>
    23fc:	e0 e8       	ldi	r30, 0x80	; 128
    23fe:	32 d0       	rcall	.+100    	; 0x2464 <__divsf3_pse+0x94>
    2400:	91 50       	subi	r25, 0x01	; 1
    2402:	50 40       	sbci	r21, 0x00	; 0
    2404:	e6 95       	lsr	r30
    2406:	00 1c       	adc	r0, r0
    2408:	ca f7       	brpl	.-14     	; 0x23fc <__divsf3_pse+0x2c>
    240a:	2b d0       	rcall	.+86     	; 0x2462 <__divsf3_pse+0x92>
    240c:	fe 2f       	mov	r31, r30
    240e:	29 d0       	rcall	.+82     	; 0x2462 <__divsf3_pse+0x92>
    2410:	66 0f       	add	r22, r22
    2412:	77 1f       	adc	r23, r23
    2414:	88 1f       	adc	r24, r24
    2416:	bb 1f       	adc	r27, r27
    2418:	26 17       	cp	r18, r22
    241a:	37 07       	cpc	r19, r23
    241c:	48 07       	cpc	r20, r24
    241e:	ab 07       	cpc	r26, r27
    2420:	b0 e8       	ldi	r27, 0x80	; 128
    2422:	09 f0       	breq	.+2      	; 0x2426 <__divsf3_pse+0x56>
    2424:	bb 0b       	sbc	r27, r27
    2426:	80 2d       	mov	r24, r0
    2428:	bf 01       	movw	r22, r30
    242a:	ff 27       	eor	r31, r31
    242c:	93 58       	subi	r25, 0x83	; 131
    242e:	5f 4f       	sbci	r21, 0xFF	; 255
    2430:	3a f0       	brmi	.+14     	; 0x2440 <__divsf3_pse+0x70>
    2432:	9e 3f       	cpi	r25, 0xFE	; 254
    2434:	51 05       	cpc	r21, r1
    2436:	78 f0       	brcs	.+30     	; 0x2456 <__divsf3_pse+0x86>
    2438:	0c 94 af 12 	jmp	0x255e	; 0x255e <__fp_inf>
    243c:	0c 94 fa 12 	jmp	0x25f4	; 0x25f4 <__fp_szero>
    2440:	5f 3f       	cpi	r21, 0xFF	; 255
    2442:	e4 f3       	brlt	.-8      	; 0x243c <__divsf3_pse+0x6c>
    2444:	98 3e       	cpi	r25, 0xE8	; 232
    2446:	d4 f3       	brlt	.-12     	; 0x243c <__divsf3_pse+0x6c>
    2448:	86 95       	lsr	r24
    244a:	77 95       	ror	r23
    244c:	67 95       	ror	r22
    244e:	b7 95       	ror	r27
    2450:	f7 95       	ror	r31
    2452:	9f 5f       	subi	r25, 0xFF	; 255
    2454:	c9 f7       	brne	.-14     	; 0x2448 <__divsf3_pse+0x78>
    2456:	88 0f       	add	r24, r24
    2458:	91 1d       	adc	r25, r1
    245a:	96 95       	lsr	r25
    245c:	87 95       	ror	r24
    245e:	97 f9       	bld	r25, 7
    2460:	08 95       	ret
    2462:	e1 e0       	ldi	r30, 0x01	; 1
    2464:	66 0f       	add	r22, r22
    2466:	77 1f       	adc	r23, r23
    2468:	88 1f       	adc	r24, r24
    246a:	bb 1f       	adc	r27, r27
    246c:	62 17       	cp	r22, r18
    246e:	73 07       	cpc	r23, r19
    2470:	84 07       	cpc	r24, r20
    2472:	ba 07       	cpc	r27, r26
    2474:	20 f0       	brcs	.+8      	; 0x247e <__divsf3_pse+0xae>
    2476:	62 1b       	sub	r22, r18
    2478:	73 0b       	sbc	r23, r19
    247a:	84 0b       	sbc	r24, r20
    247c:	ba 0b       	sbc	r27, r26
    247e:	ee 1f       	adc	r30, r30
    2480:	88 f7       	brcc	.-30     	; 0x2464 <__divsf3_pse+0x94>
    2482:	e0 95       	com	r30
    2484:	08 95       	ret

00002486 <__fixunssfsi>:
    2486:	0e 94 df 12 	call	0x25be	; 0x25be <__fp_splitA>
    248a:	88 f0       	brcs	.+34     	; 0x24ae <__fixunssfsi+0x28>
    248c:	9f 57       	subi	r25, 0x7F	; 127
    248e:	98 f0       	brcs	.+38     	; 0x24b6 <__fixunssfsi+0x30>
    2490:	b9 2f       	mov	r27, r25
    2492:	99 27       	eor	r25, r25
    2494:	b7 51       	subi	r27, 0x17	; 23
    2496:	b0 f0       	brcs	.+44     	; 0x24c4 <__fixunssfsi+0x3e>
    2498:	e1 f0       	breq	.+56     	; 0x24d2 <__fixunssfsi+0x4c>
    249a:	66 0f       	add	r22, r22
    249c:	77 1f       	adc	r23, r23
    249e:	88 1f       	adc	r24, r24
    24a0:	99 1f       	adc	r25, r25
    24a2:	1a f0       	brmi	.+6      	; 0x24aa <__fixunssfsi+0x24>
    24a4:	ba 95       	dec	r27
    24a6:	c9 f7       	brne	.-14     	; 0x249a <__fixunssfsi+0x14>
    24a8:	14 c0       	rjmp	.+40     	; 0x24d2 <__fixunssfsi+0x4c>
    24aa:	b1 30       	cpi	r27, 0x01	; 1
    24ac:	91 f0       	breq	.+36     	; 0x24d2 <__fixunssfsi+0x4c>
    24ae:	0e 94 f9 12 	call	0x25f2	; 0x25f2 <__fp_zero>
    24b2:	b1 e0       	ldi	r27, 0x01	; 1
    24b4:	08 95       	ret
    24b6:	0c 94 f9 12 	jmp	0x25f2	; 0x25f2 <__fp_zero>
    24ba:	67 2f       	mov	r22, r23
    24bc:	78 2f       	mov	r23, r24
    24be:	88 27       	eor	r24, r24
    24c0:	b8 5f       	subi	r27, 0xF8	; 248
    24c2:	39 f0       	breq	.+14     	; 0x24d2 <__fixunssfsi+0x4c>
    24c4:	b9 3f       	cpi	r27, 0xF9	; 249
    24c6:	cc f3       	brlt	.-14     	; 0x24ba <__fixunssfsi+0x34>
    24c8:	86 95       	lsr	r24
    24ca:	77 95       	ror	r23
    24cc:	67 95       	ror	r22
    24ce:	b3 95       	inc	r27
    24d0:	d9 f7       	brne	.-10     	; 0x24c8 <__fixunssfsi+0x42>
    24d2:	3e f4       	brtc	.+14     	; 0x24e2 <__fixunssfsi+0x5c>
    24d4:	90 95       	com	r25
    24d6:	80 95       	com	r24
    24d8:	70 95       	com	r23
    24da:	61 95       	neg	r22
    24dc:	7f 4f       	sbci	r23, 0xFF	; 255
    24de:	8f 4f       	sbci	r24, 0xFF	; 255
    24e0:	9f 4f       	sbci	r25, 0xFF	; 255
    24e2:	08 95       	ret

000024e4 <__floatunsisf>:
    24e4:	e8 94       	clt
    24e6:	09 c0       	rjmp	.+18     	; 0x24fa <__floatsisf+0x12>

000024e8 <__floatsisf>:
    24e8:	97 fb       	bst	r25, 7
    24ea:	3e f4       	brtc	.+14     	; 0x24fa <__floatsisf+0x12>
    24ec:	90 95       	com	r25
    24ee:	80 95       	com	r24
    24f0:	70 95       	com	r23
    24f2:	61 95       	neg	r22
    24f4:	7f 4f       	sbci	r23, 0xFF	; 255
    24f6:	8f 4f       	sbci	r24, 0xFF	; 255
    24f8:	9f 4f       	sbci	r25, 0xFF	; 255
    24fa:	99 23       	and	r25, r25
    24fc:	a9 f0       	breq	.+42     	; 0x2528 <__floatsisf+0x40>
    24fe:	f9 2f       	mov	r31, r25
    2500:	96 e9       	ldi	r25, 0x96	; 150
    2502:	bb 27       	eor	r27, r27
    2504:	93 95       	inc	r25
    2506:	f6 95       	lsr	r31
    2508:	87 95       	ror	r24
    250a:	77 95       	ror	r23
    250c:	67 95       	ror	r22
    250e:	b7 95       	ror	r27
    2510:	f1 11       	cpse	r31, r1
    2512:	f8 cf       	rjmp	.-16     	; 0x2504 <__floatsisf+0x1c>
    2514:	fa f4       	brpl	.+62     	; 0x2554 <__floatsisf+0x6c>
    2516:	bb 0f       	add	r27, r27
    2518:	11 f4       	brne	.+4      	; 0x251e <__floatsisf+0x36>
    251a:	60 ff       	sbrs	r22, 0
    251c:	1b c0       	rjmp	.+54     	; 0x2554 <__floatsisf+0x6c>
    251e:	6f 5f       	subi	r22, 0xFF	; 255
    2520:	7f 4f       	sbci	r23, 0xFF	; 255
    2522:	8f 4f       	sbci	r24, 0xFF	; 255
    2524:	9f 4f       	sbci	r25, 0xFF	; 255
    2526:	16 c0       	rjmp	.+44     	; 0x2554 <__floatsisf+0x6c>
    2528:	88 23       	and	r24, r24
    252a:	11 f0       	breq	.+4      	; 0x2530 <__floatsisf+0x48>
    252c:	96 e9       	ldi	r25, 0x96	; 150
    252e:	11 c0       	rjmp	.+34     	; 0x2552 <__floatsisf+0x6a>
    2530:	77 23       	and	r23, r23
    2532:	21 f0       	breq	.+8      	; 0x253c <__floatsisf+0x54>
    2534:	9e e8       	ldi	r25, 0x8E	; 142
    2536:	87 2f       	mov	r24, r23
    2538:	76 2f       	mov	r23, r22
    253a:	05 c0       	rjmp	.+10     	; 0x2546 <__floatsisf+0x5e>
    253c:	66 23       	and	r22, r22
    253e:	71 f0       	breq	.+28     	; 0x255c <__floatsisf+0x74>
    2540:	96 e8       	ldi	r25, 0x86	; 134
    2542:	86 2f       	mov	r24, r22
    2544:	70 e0       	ldi	r23, 0x00	; 0
    2546:	60 e0       	ldi	r22, 0x00	; 0
    2548:	2a f0       	brmi	.+10     	; 0x2554 <__floatsisf+0x6c>
    254a:	9a 95       	dec	r25
    254c:	66 0f       	add	r22, r22
    254e:	77 1f       	adc	r23, r23
    2550:	88 1f       	adc	r24, r24
    2552:	da f7       	brpl	.-10     	; 0x254a <__floatsisf+0x62>
    2554:	88 0f       	add	r24, r24
    2556:	96 95       	lsr	r25
    2558:	87 95       	ror	r24
    255a:	97 f9       	bld	r25, 7
    255c:	08 95       	ret

0000255e <__fp_inf>:
    255e:	97 f9       	bld	r25, 7
    2560:	9f 67       	ori	r25, 0x7F	; 127
    2562:	80 e8       	ldi	r24, 0x80	; 128
    2564:	70 e0       	ldi	r23, 0x00	; 0
    2566:	60 e0       	ldi	r22, 0x00	; 0
    2568:	08 95       	ret

0000256a <__fp_nan>:
    256a:	9f ef       	ldi	r25, 0xFF	; 255
    256c:	80 ec       	ldi	r24, 0xC0	; 192
    256e:	08 95       	ret

00002570 <__fp_pscA>:
    2570:	00 24       	eor	r0, r0
    2572:	0a 94       	dec	r0
    2574:	16 16       	cp	r1, r22
    2576:	17 06       	cpc	r1, r23
    2578:	18 06       	cpc	r1, r24
    257a:	09 06       	cpc	r0, r25
    257c:	08 95       	ret

0000257e <__fp_pscB>:
    257e:	00 24       	eor	r0, r0
    2580:	0a 94       	dec	r0
    2582:	12 16       	cp	r1, r18
    2584:	13 06       	cpc	r1, r19
    2586:	14 06       	cpc	r1, r20
    2588:	05 06       	cpc	r0, r21
    258a:	08 95       	ret

0000258c <__fp_round>:
    258c:	09 2e       	mov	r0, r25
    258e:	03 94       	inc	r0
    2590:	00 0c       	add	r0, r0
    2592:	11 f4       	brne	.+4      	; 0x2598 <__fp_round+0xc>
    2594:	88 23       	and	r24, r24
    2596:	52 f0       	brmi	.+20     	; 0x25ac <__fp_round+0x20>
    2598:	bb 0f       	add	r27, r27
    259a:	40 f4       	brcc	.+16     	; 0x25ac <__fp_round+0x20>
    259c:	bf 2b       	or	r27, r31
    259e:	11 f4       	brne	.+4      	; 0x25a4 <__fp_round+0x18>
    25a0:	60 ff       	sbrs	r22, 0
    25a2:	04 c0       	rjmp	.+8      	; 0x25ac <__fp_round+0x20>
    25a4:	6f 5f       	subi	r22, 0xFF	; 255
    25a6:	7f 4f       	sbci	r23, 0xFF	; 255
    25a8:	8f 4f       	sbci	r24, 0xFF	; 255
    25aa:	9f 4f       	sbci	r25, 0xFF	; 255
    25ac:	08 95       	ret

000025ae <__fp_split3>:
    25ae:	57 fd       	sbrc	r21, 7
    25b0:	90 58       	subi	r25, 0x80	; 128
    25b2:	44 0f       	add	r20, r20
    25b4:	55 1f       	adc	r21, r21
    25b6:	59 f0       	breq	.+22     	; 0x25ce <__fp_splitA+0x10>
    25b8:	5f 3f       	cpi	r21, 0xFF	; 255
    25ba:	71 f0       	breq	.+28     	; 0x25d8 <__fp_splitA+0x1a>
    25bc:	47 95       	ror	r20

000025be <__fp_splitA>:
    25be:	88 0f       	add	r24, r24
    25c0:	97 fb       	bst	r25, 7
    25c2:	99 1f       	adc	r25, r25
    25c4:	61 f0       	breq	.+24     	; 0x25de <__fp_splitA+0x20>
    25c6:	9f 3f       	cpi	r25, 0xFF	; 255
    25c8:	79 f0       	breq	.+30     	; 0x25e8 <__fp_splitA+0x2a>
    25ca:	87 95       	ror	r24
    25cc:	08 95       	ret
    25ce:	12 16       	cp	r1, r18
    25d0:	13 06       	cpc	r1, r19
    25d2:	14 06       	cpc	r1, r20
    25d4:	55 1f       	adc	r21, r21
    25d6:	f2 cf       	rjmp	.-28     	; 0x25bc <__fp_split3+0xe>
    25d8:	46 95       	lsr	r20
    25da:	f1 df       	rcall	.-30     	; 0x25be <__fp_splitA>
    25dc:	08 c0       	rjmp	.+16     	; 0x25ee <__fp_splitA+0x30>
    25de:	16 16       	cp	r1, r22
    25e0:	17 06       	cpc	r1, r23
    25e2:	18 06       	cpc	r1, r24
    25e4:	99 1f       	adc	r25, r25
    25e6:	f1 cf       	rjmp	.-30     	; 0x25ca <__fp_splitA+0xc>
    25e8:	86 95       	lsr	r24
    25ea:	71 05       	cpc	r23, r1
    25ec:	61 05       	cpc	r22, r1
    25ee:	08 94       	sec
    25f0:	08 95       	ret

000025f2 <__fp_zero>:
    25f2:	e8 94       	clt

000025f4 <__fp_szero>:
    25f4:	bb 27       	eor	r27, r27
    25f6:	66 27       	eor	r22, r22
    25f8:	77 27       	eor	r23, r23
    25fa:	cb 01       	movw	r24, r22
    25fc:	97 f9       	bld	r25, 7
    25fe:	08 95       	ret

00002600 <__mulsf3>:
    2600:	0e 94 13 13 	call	0x2626	; 0x2626 <__mulsf3x>
    2604:	0c 94 c6 12 	jmp	0x258c	; 0x258c <__fp_round>
    2608:	0e 94 b8 12 	call	0x2570	; 0x2570 <__fp_pscA>
    260c:	38 f0       	brcs	.+14     	; 0x261c <__mulsf3+0x1c>
    260e:	0e 94 bf 12 	call	0x257e	; 0x257e <__fp_pscB>
    2612:	20 f0       	brcs	.+8      	; 0x261c <__mulsf3+0x1c>
    2614:	95 23       	and	r25, r21
    2616:	11 f0       	breq	.+4      	; 0x261c <__mulsf3+0x1c>
    2618:	0c 94 af 12 	jmp	0x255e	; 0x255e <__fp_inf>
    261c:	0c 94 b5 12 	jmp	0x256a	; 0x256a <__fp_nan>
    2620:	11 24       	eor	r1, r1
    2622:	0c 94 fa 12 	jmp	0x25f4	; 0x25f4 <__fp_szero>

00002626 <__mulsf3x>:
    2626:	0e 94 d7 12 	call	0x25ae	; 0x25ae <__fp_split3>
    262a:	70 f3       	brcs	.-36     	; 0x2608 <__mulsf3+0x8>

0000262c <__mulsf3_pse>:
    262c:	95 9f       	mul	r25, r21
    262e:	c1 f3       	breq	.-16     	; 0x2620 <__mulsf3+0x20>
    2630:	95 0f       	add	r25, r21
    2632:	50 e0       	ldi	r21, 0x00	; 0
    2634:	55 1f       	adc	r21, r21
    2636:	62 9f       	mul	r22, r18
    2638:	f0 01       	movw	r30, r0
    263a:	72 9f       	mul	r23, r18
    263c:	bb 27       	eor	r27, r27
    263e:	f0 0d       	add	r31, r0
    2640:	b1 1d       	adc	r27, r1
    2642:	63 9f       	mul	r22, r19
    2644:	aa 27       	eor	r26, r26
    2646:	f0 0d       	add	r31, r0
    2648:	b1 1d       	adc	r27, r1
    264a:	aa 1f       	adc	r26, r26
    264c:	64 9f       	mul	r22, r20
    264e:	66 27       	eor	r22, r22
    2650:	b0 0d       	add	r27, r0
    2652:	a1 1d       	adc	r26, r1
    2654:	66 1f       	adc	r22, r22
    2656:	82 9f       	mul	r24, r18
    2658:	22 27       	eor	r18, r18
    265a:	b0 0d       	add	r27, r0
    265c:	a1 1d       	adc	r26, r1
    265e:	62 1f       	adc	r22, r18
    2660:	73 9f       	mul	r23, r19
    2662:	b0 0d       	add	r27, r0
    2664:	a1 1d       	adc	r26, r1
    2666:	62 1f       	adc	r22, r18
    2668:	83 9f       	mul	r24, r19
    266a:	a0 0d       	add	r26, r0
    266c:	61 1d       	adc	r22, r1
    266e:	22 1f       	adc	r18, r18
    2670:	74 9f       	mul	r23, r20
    2672:	33 27       	eor	r19, r19
    2674:	a0 0d       	add	r26, r0
    2676:	61 1d       	adc	r22, r1
    2678:	23 1f       	adc	r18, r19
    267a:	84 9f       	mul	r24, r20
    267c:	60 0d       	add	r22, r0
    267e:	21 1d       	adc	r18, r1
    2680:	82 2f       	mov	r24, r18
    2682:	76 2f       	mov	r23, r22
    2684:	6a 2f       	mov	r22, r26
    2686:	11 24       	eor	r1, r1
    2688:	9f 57       	subi	r25, 0x7F	; 127
    268a:	50 40       	sbci	r21, 0x00	; 0
    268c:	9a f0       	brmi	.+38     	; 0x26b4 <__mulsf3_pse+0x88>
    268e:	f1 f0       	breq	.+60     	; 0x26cc <__mulsf3_pse+0xa0>
    2690:	88 23       	and	r24, r24
    2692:	4a f0       	brmi	.+18     	; 0x26a6 <__mulsf3_pse+0x7a>
    2694:	ee 0f       	add	r30, r30
    2696:	ff 1f       	adc	r31, r31
    2698:	bb 1f       	adc	r27, r27
    269a:	66 1f       	adc	r22, r22
    269c:	77 1f       	adc	r23, r23
    269e:	88 1f       	adc	r24, r24
    26a0:	91 50       	subi	r25, 0x01	; 1
    26a2:	50 40       	sbci	r21, 0x00	; 0
    26a4:	a9 f7       	brne	.-22     	; 0x2690 <__mulsf3_pse+0x64>
    26a6:	9e 3f       	cpi	r25, 0xFE	; 254
    26a8:	51 05       	cpc	r21, r1
    26aa:	80 f0       	brcs	.+32     	; 0x26cc <__mulsf3_pse+0xa0>
    26ac:	0c 94 af 12 	jmp	0x255e	; 0x255e <__fp_inf>
    26b0:	0c 94 fa 12 	jmp	0x25f4	; 0x25f4 <__fp_szero>
    26b4:	5f 3f       	cpi	r21, 0xFF	; 255
    26b6:	e4 f3       	brlt	.-8      	; 0x26b0 <__mulsf3_pse+0x84>
    26b8:	98 3e       	cpi	r25, 0xE8	; 232
    26ba:	d4 f3       	brlt	.-12     	; 0x26b0 <__mulsf3_pse+0x84>
    26bc:	86 95       	lsr	r24
    26be:	77 95       	ror	r23
    26c0:	67 95       	ror	r22
    26c2:	b7 95       	ror	r27
    26c4:	f7 95       	ror	r31
    26c6:	e7 95       	ror	r30
    26c8:	9f 5f       	subi	r25, 0xFF	; 255
    26ca:	c1 f7       	brne	.-16     	; 0x26bc <__mulsf3_pse+0x90>
    26cc:	fe 2b       	or	r31, r30
    26ce:	88 0f       	add	r24, r24
    26d0:	91 1d       	adc	r25, r1
    26d2:	96 95       	lsr	r25
    26d4:	87 95       	ror	r24
    26d6:	97 f9       	bld	r25, 7
    26d8:	08 95       	ret

000026da <__udivmodhi4>:
    26da:	aa 1b       	sub	r26, r26
    26dc:	bb 1b       	sub	r27, r27
    26de:	51 e1       	ldi	r21, 0x11	; 17
    26e0:	07 c0       	rjmp	.+14     	; 0x26f0 <__udivmodhi4_ep>

000026e2 <__udivmodhi4_loop>:
    26e2:	aa 1f       	adc	r26, r26
    26e4:	bb 1f       	adc	r27, r27
    26e6:	a6 17       	cp	r26, r22
    26e8:	b7 07       	cpc	r27, r23
    26ea:	10 f0       	brcs	.+4      	; 0x26f0 <__udivmodhi4_ep>
    26ec:	a6 1b       	sub	r26, r22
    26ee:	b7 0b       	sbc	r27, r23

000026f0 <__udivmodhi4_ep>:
    26f0:	88 1f       	adc	r24, r24
    26f2:	99 1f       	adc	r25, r25
    26f4:	5a 95       	dec	r21
    26f6:	a9 f7       	brne	.-22     	; 0x26e2 <__udivmodhi4_loop>
    26f8:	80 95       	com	r24
    26fa:	90 95       	com	r25
    26fc:	bc 01       	movw	r22, r24
    26fe:	cd 01       	movw	r24, r26
    2700:	08 95       	ret

00002702 <__umulhisi3>:
    2702:	a2 9f       	mul	r26, r18
    2704:	b0 01       	movw	r22, r0
    2706:	b3 9f       	mul	r27, r19
    2708:	c0 01       	movw	r24, r0
    270a:	a3 9f       	mul	r26, r19
    270c:	70 0d       	add	r23, r0
    270e:	81 1d       	adc	r24, r1
    2710:	11 24       	eor	r1, r1
    2712:	91 1d       	adc	r25, r1
    2714:	b2 9f       	mul	r27, r18
    2716:	70 0d       	add	r23, r0
    2718:	81 1d       	adc	r24, r1
    271a:	11 24       	eor	r1, r1
    271c:	91 1d       	adc	r25, r1
    271e:	08 95       	ret

00002720 <memcpy>:
    2720:	fb 01       	movw	r30, r22
    2722:	dc 01       	movw	r26, r24
    2724:	02 c0       	rjmp	.+4      	; 0x272a <memcpy+0xa>
    2726:	01 90       	ld	r0, Z+
    2728:	0d 92       	st	X+, r0
    272a:	41 50       	subi	r20, 0x01	; 1
    272c:	50 40       	sbci	r21, 0x00	; 0
    272e:	d8 f7       	brcc	.-10     	; 0x2726 <memcpy+0x6>
    2730:	08 95       	ret

00002732 <_exit>:
    2732:	f8 94       	cli

00002734 <__stop_program>:
    2734:	ff cf       	rjmp	.-2      	; 0x2734 <__stop_program>
